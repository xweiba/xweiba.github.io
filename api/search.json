[{"id":"27aab0825c321448b30acc595fc9bf6c","title":"设计模式-适配器模式","content":"模式定义适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。1\n应用场景适配器模式适用于以下场景：\n\n当需要使用一个已存在的类，但其接口与你的需求不匹配时\n当需要创建一个可复用的类，该类可以与其他不相关或不可预见的类协同工作\n当需要使用一些已存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口时\n当对象适配器需要适配多个被适配类时\n\n模式结构适配器模式包含以下角色：\n\nTarget（目标接口）：客户端所期望的接口\nAdaptee（被适配者）：需要被适配的类或接口\nAdapter（适配器）：将被适配者的接口转换为目标接口\n\n代码实现以下是一个简单的适配器模式示例，通过适配器模式来适配不同的支付方式：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 目标接口interface Payment &#123;    void pay(double amount);&#125;// 被适配者 - 支付宝支付（假设这是一个已存在的类，我们无法修改）class AliPay &#123;    public void aliPayment(double money) &#123;        System.out.println(&quot;使用支付宝支付：&quot; + money + &quot;元&quot;);    &#125;&#125;// 被适配者 - 微信支付（假设这是一个已存在的类，我们无法修改）class WeChatPay &#123;    public void wechatPay(double fee) &#123;        System.out.println(&quot;使用微信支付：&quot; + fee + &quot;元&quot;);    &#125;&#125;// 适配器 - 支付宝支付适配器class AliPayAdapter implements Payment &#123;    private AliPay aliPay;    public AliPayAdapter(AliPay aliPay) &#123;        this.aliPay = aliPay;    &#125;    @Override    public void pay(double amount) &#123;        aliPay.aliPayment(amount);    &#125;&#125;// 适配器 - 微信支付适配器class WeChatPayAdapter implements Payment &#123;    private WeChatPay weChatPay;    public WeChatPayAdapter(WeChatPay weChatPay) &#123;        this.weChatPay = weChatPay;    &#125;    @Override    public void pay(double amount) &#123;        weChatPay.wechatPay(amount);    &#125;&#125;// 客户端使用public class Client &#123;    public static void main(String[] args) &#123;        // 创建被适配者对象        AliPay aliPay = new AliPay();        WeChatPay weChatPay = new WeChatPay();        // 创建适配器对象        Payment aliPayAdapter = new AliPayAdapter(aliPay);        Payment weChatPayAdapter = new WeChatPayAdapter(weChatPay);        // 使用适配器进行支付        aliPayAdapter.pay(100);        weChatPayAdapter.pay(200);    &#125;&#125;\n\n优缺点优点\n将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类\n增加了类的透明性和复用性\n提高了代码的可扩展性和灵活性\n符合开闭原则\n\n缺点\n适配器模式可能会增加系统的复杂性\n使用对象适配器时，需要额外的引用来适配被适配者\n过多使用适配器会使系统变得凌乱\n\n适配器模式的两种实现方式在Java中，适配器模式有两种实现方式：\n\n类适配器（Class Adapter）：\n\n通过继承被适配者来实现适配\n使用Java的继承机制\n只能适配一个被适配者类\n可以重写被适配者的方法\n\n\n对象适配器（Object Adapter）：\n\n通过组合的方式来实现适配\n使用Java的对象组合\n可以适配多个被适配者类\n只能使用被适配者的公有方法\n\n\n\n实际应用适配器模式在Java开发中的应用：\n\nJava IO中的InputStreamReader和OutputStreamWriter\nSpring AOP中的AdvisorAdapter接口\nSpring MVC中的HandlerAdapter接口\nJDBC中的数据库驱动适配\n\n","slug":"设计模式-适配器模式","date":"2025-05-01T13:52:20.000Z","categories_index":"编程,设计模式","tags_index":"Java,设计模式,适配器模式","author_index":"Weiba"},{"id":"ba36f7fdf24221629f84d123d60f7a05","title":"设计模式-原型模式","content":"模式定义原型模式（Prototype Pattern）是一种创建型设计模式，它允许你复制已有对象，而无需使代码依赖它们所属的类。该模式通过克隆现有对象来创建新对象，而不是通过实例化的方式。1\n应用场景原型模式适用于以下场景：\n\n当创建对象的成本较大，且需要创建多个相似对象时\n当系统应该独立于产品的创建、构成和表示时\n当要实例化的类是在运行时刻指定时\n当避免创建一个与产品类层次平行的工厂类层次时\n\n模式结构原型模式包含以下角色：\n\nPrototype（抽象原型类）：声明一个克隆自身的接口\nConcretePrototype（具体原型类）：实现克隆的具体操作\nClient（客户类）：让一个原型克隆自身，从而创建一个新的对象\n\n代码实现以下是一个简单的原型模式示例，通过原型模式来克隆不同类型的文档：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 抽象原型类interface Document extends Cloneable &#123;    Document clone();    void display();&#125;// 具体原型类 - Word文档class WordDocument implements Document &#123;    private String content;    private String format;    public WordDocument(String content, String format) &#123;        this.content = content;        this.format = format;    &#125;    @Override    public Document clone() &#123;        try &#123;            return (Document) super.clone();        &#125; catch (CloneNotSupportedException e) &#123;            return null;        &#125;    &#125;    @Override    public void display() &#123;        System.out.println(&quot;Word文档 [内容=&quot; + content + &quot;, 格式=&quot; + format + &quot;]&quot;);    &#125;&#125;// 具体原型类 - PDF文档class PDFDocument implements Document &#123;    private String content;    private int pageCount;    public PDFDocument(String content, int pageCount) &#123;        this.content = content;        this.pageCount = pageCount;    &#125;    @Override    public Document clone() &#123;        try &#123;            return (Document) super.clone();        &#125; catch (CloneNotSupportedException e) &#123;            return null;        &#125;    &#125;    @Override    public void display() &#123;        System.out.println(&quot;PDF文档 [内容=&quot; + content + &quot;, 页数=&quot; + pageCount + &quot;]&quot;);    &#125;&#125;// 客户端使用public class Client &#123;    public static void main(String[] args) &#123;        // 创建原型对象        WordDocument wordDoc = new WordDocument(&quot;Hello World&quot;, &quot;docx&quot;);        PDFDocument pdfDoc = new PDFDocument(&quot;Hello World&quot;, 1);        // 克隆对象        Document wordClone = wordDoc.clone();        Document pdfClone = pdfDoc.clone();        // 显示原型对象        System.out.println(&quot;原型对象：&quot;);        wordDoc.display();        pdfDoc.display();        // 显示克隆对象        System.out.println(&quot;\\n克隆对象：&quot;);        wordClone.display();        pdfClone.display();    &#125;&#125;\n\n优缺点优点\n可以不耦合具体类的情况下克隆对象\n避免重复的初始化代码\n快速生成复杂对象\n用于生成不同状态的对象\n\n缺点\n对象中包含循环引用的情况下，克隆可能会很复杂\n实现深克隆时可能需要较为复杂的代码\n\n浅克隆与深克隆在Java中，原型模式的实现涉及到两种克隆方式：\n\n浅克隆（Shallow Clone）：\n\n只复制对象本身，不复制对象中的引用类型的成员变量\n复制后的对象与原对象共享引用类型的成员变量\n实现简单，但可能存在数据安全问题\n\n\n深克隆（Deep Clone）：\n\n复制对象本身及其引用类型的成员变量\n复制后的对象与原对象完全独立\n实现较复杂，但数据更安全\n\n\n\n实际应用原型模式在Java开发中的应用：\n\nJava中的Object.clone()方法\nSpring Framework中的Bean作用域prototype\n对象池技术中的对象复制\n在需要频繁创建复杂对象的场景中使用\n\n","slug":"设计模式-原型模式","date":"2025-04-30T13:52:20.000Z","categories_index":"编程,设计模式","tags_index":"Java,设计模式,原型模式","author_index":"Weiba"},{"id":"3ea889d0200adbef6f577008a7289f16","title":"Mysql-事务与MVCC","content":"Mysql ACID 特性\n原子性: 事务是最小的执行单位，不允许分割。要么全部成功，要么全部失败。\n一致性: 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；比如转账：我给你转100，我原来是100，你是0，总数100，执行完毕后总数还是100.\n隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\n持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n\nAID 是手段 D是目标。\nMysql 事务隔离级别，都是事务执行过程中查询数据的限制和结果READ UNCOMMITTED：读未提交可以看到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读。\nREAD COMMITTED：读已提交（MVCC）。能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读。事务过程中每次查询的都是已提交的最新数据。\nREPEATABLE READ：可重复读(默认)(MVCC)每次查询的都是当前事务开始前的数据快照，因此查询不会出现不一样的情况，解决了不可重复读问题。\n但如果其他事务新增&#x2F;删除了数据，它再查询，会查询到新的\n注意：幻读和不可重复读的侧重点是不同的，不可重复读侧重于数据修改，两次读取到的同一行数据不一样；而幻读侧重于添加或删除，两次查询返回的数据行数不同。\n幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。\nSERIALIZABLE：序列化(锁)事务最高隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。\n事务并发控制方式锁通过锁来显式控制共享资源而不是通过调度手段，MySQL 中主要是通过 读写锁 来实现并发控制。\n\n共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。\n排他锁（X 锁）：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。\n\n读写锁可以做到读读并行，但是无法做到写读、写写并行。\n另外，根据根据锁粒度的不同，又被分为 表级锁(table-level locking) 和 行级锁(row-level locking) 。\nInnoDB 支持\n\n表级锁 执行ALTER TABLE、DROP TABLE、TRUNCATE TABLE等DDL语句时\n行级锁(默认) \n写操作（INSERT、UPDATE、DELETE）时，InnoDB会自动对受影响的行加排他锁（X锁）\n当存在外键约束时，插入或更新操作会对相关的外键行加共享锁\n当插入或更新操作导致唯一索引冲突时，会对冲突的行加共享锁\n\n\n\n行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。\n不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。\nMVCC多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。\nMVCC 在 MySQL 中实现所依赖的手段主要是:隐藏字段：\n\nDB_TRX_ID（事务ID）\nDB_ROLL_PTR（回滚指针），通过回滚指针找到上一个logundo log : undo log 用于记录某行数据的多个版本的数据。read view : 用来判断当前版本数据的可见性。\n\n","slug":"Mysql-事务与MVCC","date":"2025-04-30T04:20:26.000Z","categories_index":"","tags_index":"Mysql,事务,MVCC","author_index":"Weiba"},{"id":"8a95a847ba41df9a0cdac0faf9ed7ebe","title":"设计模式-桥接模式","content":"模式定义桥接模式（Bridge Pattern）是一种结构型设计模式，它将抽象部分与其实现部分分离，使它们都可以独立地变化。这种模式通过组合的方式，将类的抽象与实现解耦，使得两者可以独立地进行变化和扩展。1\n应用场景桥接模式适用于以下场景：\n\n需要在运行时切换不同的实现方式\n需要跨平台开发时，处理不同平台的实现差异\n需要将抽象与实现解耦，使它们可以独立变化\n处理多维度变化的系统，如不同的数据库服务器、不同的操作系统等 5\n\n实现方式1. 基本结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 实现接口public interface DrawAPI &#123;    void drawCircle(int radius, int x, int y);&#125;// 具体实现类public class RedCircle implements DrawAPI &#123;    @Override    public void drawCircle(int radius, int x, int y) &#123;        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot; + radius + &quot;, x: &quot; + x + &quot;, y: &quot; + y + &quot;]&quot;);    &#125;&#125;public class BlueCircle implements DrawAPI &#123;    @Override    public void drawCircle(int radius, int x, int y) &#123;        System.out.println(&quot;Drawing Circle[ color: blue, radius: &quot; + radius + &quot;, x: &quot; + x + &quot;, y: &quot; + y + &quot;]&quot;);    &#125;&#125;// 抽象类public abstract class Shape &#123;    protected DrawAPI drawAPI;        protected Shape(DrawAPI drawAPI) &#123;        this.drawAPI = drawAPI;    &#125;        public abstract void draw();&#125;// 扩展抽象类public class Circle extends Shape &#123;    private int x, y, radius;        public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;        super(drawAPI);        this.x = x;        this.y = y;        this.radius = radius;    &#125;        @Override    public void draw() &#123;        drawAPI.drawCircle(radius, x, y);    &#125;&#125;\n\n2. 使用示例123456789public class BridgePatternDemo &#123;    public static void main(String[] args) &#123;        Shape redCircle = new Circle(100, 100, 10, new RedCircle());        Shape blueCircle = new Circle(200, 200, 20, new BlueCircle());                redCircle.draw();        blueCircle.draw();    &#125;&#125;\n\n实现要点\n将抽象与实现分离，使它们可以独立变化 2\n使用组合而不是继承来实现解耦\n确保接口的设计足够抽象，以适应未来的变化\n实现类和抽象类可以独立扩展，不会互相影响\n\n优缺点优点\n实现平台独立性，提高系统的可扩展性\n抽象和实现可以独立进行改变，不会相互影响\n可以在运行时切换不同的实现\n有利于系统的分层设计 3\n\n缺点\n增加了系统的复杂度\n需要正确识别系统中的两个独立变化的维度\n\n注意事项\n在设计之初就需要考虑抽象和实现的分离\n确保抽象和实现的接口设计合理，避免后期难以扩展\n不要过度使用桥接模式，只在必要时才使用\n\n","slug":"设计模式-桥接模式","date":"2025-04-29T14:11:58.000Z","categories_index":"编程,设计模式","tags_index":"Java,设计模式,桥接模式","author_index":"Weiba"},{"id":"c6662e642ba385f9913bf17f12cb4f9e","title":"设计模式-建造者模式","content":"模式定义建造者模式(Builder Pattern)是一种创建型设计模式，它允许你分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。1\n应用场景建造者模式适用于以下场景：\n\n需要创建的对象有复杂的内部结构（包含多个成员属性）\n需要生成的对象内部属性之间的建造顺序有依赖关系\n对象的创建过程独立于创建该对象的类\n隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品\n\n模式结构建造者模式包含以下角色：\n\nBuilder（抽象建造者）：规范产品的组建，一般由抽象类或接口实现\nConcreteBuilder（具体建造者）：实现抽象建造者定义的方法，并返回一个组建好的对象\nDirector（指挥者）：负责安排已有模块的顺序，然后告诉建造者开始建造\nProduct（产品）：要创建的复杂对象\n\n代码实现以下是一个简单的建造者模式示例，通过建造者模式来创建不同类型的计算机：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 产品类class Computer &#123;    private String cpu;    private String ram;    private String storage;    private String gpu;    public void setCpu(String cpu) &#123;        this.cpu = cpu;    &#125;    public void setRam(String ram) &#123;        this.ram = ram;    &#125;    public void setStorage(String storage) &#123;        this.storage = storage;    &#125;    public void setGpu(String gpu) &#123;        this.gpu = gpu;    &#125;    @Override    public String toString() &#123;        return &quot;Computer&#123;&quot; +                &quot;cpu=&#x27;&quot; + cpu + &quot;\\&#x27;&#x27; +                &quot;, ram=&#x27;&quot; + ram + &quot;\\&#x27;&#x27; +                &quot;, storage=&#x27;&quot; + storage + &quot;\\&#x27;&#x27; +                &quot;, gpu=&#x27;&quot; + gpu + &quot;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;// 抽象建造者interface ComputerBuilder &#123;    void buildCpu();    void buildRam();    void buildStorage();    void buildGpu();    Computer getResult();&#125;// 具体建造者 - 游戏电脑class GamingComputerBuilder implements ComputerBuilder &#123;    private Computer computer = new Computer();    @Override    public void buildCpu() &#123;        computer.setCpu(&quot;高性能游戏CPU&quot;);    &#125;    @Override    public void buildRam() &#123;        computer.setRam(&quot;32GB高速内存&quot;);    &#125;    @Override    public void buildStorage() &#123;        computer.setStorage(&quot;2TB NVMe SSD&quot;);    &#125;    @Override    public void buildGpu() &#123;        computer.setGpu(&quot;顶级游戏显卡&quot;);    &#125;    @Override    public Computer getResult() &#123;        return computer;    &#125;&#125;// 具体建造者 - 办公电脑class OfficeComputerBuilder implements ComputerBuilder &#123;    private Computer computer = new Computer();    @Override    public void buildCpu() &#123;        computer.setCpu(&quot;标准办公CPU&quot;);    &#125;    @Override    public void buildRam() &#123;        computer.setRam(&quot;8GB内存&quot;);    &#125;    @Override    public void buildStorage() &#123;        computer.setStorage(&quot;256GB SSD&quot;);    &#125;    @Override    public void buildGpu() &#123;        computer.setGpu(&quot;集成显卡&quot;);    &#125;    @Override    public Computer getResult() &#123;        return computer;    &#125;&#125;// 指挥者class Director &#123;    public void construct(ComputerBuilder builder) &#123;        builder.buildCpu();        builder.buildRam();        builder.buildStorage();        builder.buildGpu();    &#125;&#125;// 客户端使用public class Client &#123;    public static void main(String[] args) &#123;        Director director = new Director();                ComputerBuilder gamingBuilder = new GamingComputerBuilder();        director.construct(gamingBuilder);        Computer gamingComputer = gamingBuilder.getResult();        System.out.println(&quot;游戏电脑配置：&quot; + gamingComputer);                ComputerBuilder officeBuilder = new OfficeComputerBuilder();        director.construct(officeBuilder);        Computer officeComputer = officeBuilder.getResult();        System.out.println(&quot;办公电脑配置：&quot; + officeComputer);    &#125;&#125;\n\n优缺点优点\n将一个复杂对象的创建过程封装在一个对象中\n允许对象通过多个步骤来创建，并且可以改变过程（这是与工厂模式最大的不同）\n向客户端隐藏产品内部的表示，使得产品的内部结构可以独立地变化\n可以更好地控制创建过程\n\n缺点\n产品必须有共同点，范围有限制\n如果产品内部变化复杂，可能会导致需要定义很多具体建造者类\n\n与抽象工厂模式的区别建造者模式与抽象工厂模式的主要区别：\n\n建造者模式更注重方法的调用顺序，而抽象工厂模式注重产品族的创建\n建造者模式可以更精细地控制产品的创建过程，而抽象工厂模式一般用来创建一系列相关的对象\n建造者模式通常需要更多的代码量，但是会有更好的灵活性\n\n实际应用建造者模式在Java开发中的应用：\n\nStringBuilder类的实现\nLombok的@Builder注解\nSpring框架中的BeanDefinitionBuilder\nMyBatis框架中的SqlSessionFactoryBuilder\n\n","slug":"设计模式-建造者模式","date":"2025-04-29T13:52:20.000Z","categories_index":"编程,设计模式","tags_index":"Java,设计模式,建造者模式","author_index":"Weiba"},{"id":"3e408f42174f172f57057703c67ff561","title":"设计模式-抽象工厂模式","content":"模式定义抽象工厂模式(Abstract Factory Pattern)是一种创建型设计模式，它提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式。2\n应用场景抽象工厂模式适用于以下场景：\n\n一个系统要独立于它的产品的创建、组合和表示时\n一个系统要由多个产品系列中的一个来配置时\n需要强调一系列相关的产品对象的设计以便进行联合使用时\n提供一个产品类库，只想显示它们的接口而不是实现时\n\n模式结构抽象工厂模式包含以下角色：\n\nAbstractFactory（抽象工厂）：声明一组用于创建产品族的方法\nConcreteFactory（具体工厂）：实现抽象工厂的方法来创建具体产品\nAbstractProduct（抽象产品）：为一类产品声明接口\nConcreteProduct（具体产品）：实现抽象产品接口\n\n代码实现以下是一个简单的抽象工厂模式示例，通过不同的工厂创建不同品牌的电子产品：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 抽象产品A - 手机interface Phone &#123;    void call();&#125;// 具体产品A1class XiaomiPhone implements Phone &#123;    @Override    public void call() &#123;        System.out.println(&quot;使用小米手机打电话&quot;);    &#125;&#125;// 具体产品A2class HuaweiPhone implements Phone &#123;    @Override    public void call() &#123;        System.out.println(&quot;使用华为手机打电话&quot;);    &#125;&#125;// 抽象产品B - 笔记本interface Laptop &#123;    void code();&#125;// 具体产品B1class XiaomiLaptop implements Laptop &#123;    @Override    public void code() &#123;        System.out.println(&quot;使用小米笔记本编程&quot;);    &#125;&#125;// 具体产品B2class HuaweiLaptop implements Laptop &#123;    @Override    public void code() &#123;        System.out.println(&quot;使用华为笔记本编程&quot;);    &#125;&#125;// 抽象工厂interface ElectronicsFactory &#123;    Phone createPhone();    Laptop createLaptop();&#125;// 具体工厂1class XiaomiFactory implements ElectronicsFactory &#123;    @Override    public Phone createPhone() &#123;        return new XiaomiPhone();    &#125;    @Override    public Laptop createLaptop() &#123;        return new XiaomiLaptop();    &#125;&#125;// 具体工厂2class HuaweiFactory implements ElectronicsFactory &#123;    @Override    public Phone createPhone() &#123;        return new HuaweiPhone();    &#125;    @Override    public Laptop createLaptop() &#123;        return new HuaweiLaptop();    &#125;&#125;// 客户端使用public class Client &#123;    public static void main(String[] args) &#123;        ElectronicsFactory xiaomiFactory = new XiaomiFactory();        Phone xiaomiPhone = xiaomiFactory.createPhone();        Laptop xiaomiLaptop = xiaomiFactory.createLaptop();                xiaomiPhone.call();        xiaomiLaptop.code();                ElectronicsFactory huaweiFactory = new HuaweiFactory();        Phone huaweiPhone = huaweiFactory.createPhone();        Laptop huaweiLaptop = huaweiFactory.createLaptop();                huaweiPhone.call();        huaweiLaptop.code();    &#125;&#125;\n\n优缺点优点\n保证了同一产品族中产品的一致性\n隔离了具体类的生成，使得客户端不需要知道什么被创建\n当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象\n\n缺点\n产品族扩展困难，需要修改抽象工厂的接口\n增加了系统的抽象性和理解难度\n\n与工厂方法的区别抽象工厂模式与工厂方法模式的主要区别：\n\n工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构\n工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类\n抽象工厂模式有更大的抽象程度，适合更复杂的产品族创建场景\n\n实际应用抽象工厂模式在Java开发中的应用：\n\nJava AWT和SWT中的GUI工具包\nSpring框架中的BeanFactory\nJDBC中的Connection接口的实现\n\n","slug":"设计模式-抽象工厂模式","date":"2025-04-29T13:40:04.000Z","categories_index":"编程,设计模式","tags_index":"Java,设计模式,抽象工厂模式","author_index":"Weiba"},{"id":"4bfc1f23a5ea4d5b4830c87f58680be5","title":"设计模式-工厂方法模式","content":"模式定义工厂方法模式(Factory Method Pattern)是一种创建型设计模式，它定义一个用于创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式把类实例化的过程推迟到子类。1\n应用场景工厂方法模式适用于以下场景：\n\n当一个类不知道它所需要的对象的类时\n当一个类希望由其子类来指定它所创建的对象时\n当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化时\n\n模式结构工厂方法模式包含以下角色：\n\nFactory（抽象工厂）：声明工厂方法，返回一个产品对象\nConcreteFactory（具体工厂）：实现工厂方法，创建具体产品\nProduct（抽象产品）：定义产品的接口\nConcreteProduct（具体产品）：实现产品接口 2\n\n代码实现以下是一个简单的工厂方法模式示例，通过不同的工厂创建不同品牌的手机：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 抽象产品interface Phone &#123;    void start();&#125;// 具体产品class OppoPhone implements Phone &#123;    @Override    public void start() &#123;        System.out.println(&quot;OPPO手机开机&quot;);    &#125;&#125;class VivoPhone implements Phone &#123;    @Override    public void start() &#123;        System.out.println(&quot;VIVO手机开机&quot;);    &#125;&#125;// 抽象工厂interface PhoneFactory &#123;    Phone createPhone();&#125;// 具体工厂class OppoFactory implements PhoneFactory &#123;    @Override    public Phone createPhone() &#123;        return new OppoPhone();    &#125;&#125;class VivoFactory implements PhoneFactory &#123;    @Override    public Phone createPhone() &#123;        return new VivoPhone();    &#125;&#125;// 客户端使用public class Client &#123;    public static void main(String[] args) &#123;        Phone oppoPhone = new OppoFactory().createPhone();        oppoPhone.start();        Phone vivoPhone = new VivoFactory().createPhone();        vivoPhone.start();    &#125;&#125;\n\n优缺点优点\n符合开闭原则，新增产品时只需添加具体工厂和产品类\n符合单一职责原则，每个具体工厂只负责创建对应的产品\n可以让代码更加灵活，避免创建对象和使用对象的代码耦合\n\n缺点\n需要创建多个工厂类，增加了系统的复杂度\n增加新产品时需要同时添加新的具体产品类和对应的具体工厂类\n\n与简单工厂的区别工厂方法模式与简单工厂模式的主要区别：\n\n简单工厂模式只有一个工厂类，工厂方法模式有多个工厂类\n简单工厂模式不满足开闭原则，而工厂方法模式符合开闭原则\n工厂方法模式更加灵活，但也更加复杂 3\n\n实际应用工厂方法模式在Java开发中应用广泛，例如：\n\nCollection接口的iterator()方法\nSpring框架中的BeanFactory\n日志框架中的LoggerFactory\n\n","slug":"设计模式-工厂方法模式","date":"2025-04-29T13:40:03.000Z","categories_index":"编程,设计模式","tags_index":"Java,设计模式,工厂方法模式","author_index":"Weiba"},{"id":"073020299d8408617f662c6184305f2a","title":"设计模式-单例模式","content":"模式定义单例模式（Singleton Pattern）是一种创建型设计模式，它保证一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。3\n应用场景单例模式适用于以下场景：\n\n需要频繁实例化然后销毁的对象\n创建对象时耗时过多或耗费资源过多，但又经常用到的对象\n有状态的工具类对象\n频繁访问数据库或文件的对象\n\n实现方式1. 饿汉式123456789public class SingletonEager &#123;    private static final SingletonEager instance = new SingletonEager();        private SingletonEager() &#123;&#125;        public static SingletonEager getInstance() &#123;        return instance;    &#125;&#125;\n\n2. 懒汉式（线程安全，双重检查）12345678910111213141516public class SingletonLazy &#123;    private static volatile SingletonLazy instance;        private SingletonLazy() &#123;&#125;        public static SingletonLazy getInstance() &#123;        if (instance == null) &#123;            synchronized (SingletonLazy.class) &#123;                if (instance == null) &#123;                    instance = new SingletonLazy();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;\n\n3. 静态内部类1234567891011public class SingletonStaticInner &#123;    private SingletonStaticInner() &#123;&#125;        private static class SingletonHolder &#123;        private static final SingletonStaticInner INSTANCE = new SingletonStaticInner();    &#125;        public static SingletonStaticInner getInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;&#125;\n\n实现要点\n构造函数私有化\n提供一个全局访问点\n确保线程安全\n防止反序列化创建新的实例\n\n4\n优缺点优点\n保证一个类只有一个实例\n提供了对唯一实例的全局访问点\n可以节省系统资源\n\n缺点\n单例模式一般没有接口，扩展困难\n单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则\n\n注意事项\n多线程环境下需要特别注意线程安全问题\n注意延迟加载带来的性能问题\n考虑反序列化可能破坏单例的情况\n\n","slug":"设计模式-单例模式","date":"2025-04-29T13:40:02.000Z","categories_index":"编程,设计模式","tags_index":"Java,设计模式,单例模式","author_index":"Weiba"},{"id":"2a65e05f182b95ab6109ed82fd948943","title":"设计模式-概述","content":"\n\n\n\n\n\n\n\n\nDesignPattern\n观察者模式主题 Subject\n维护订阅者\n内部维护一个订阅者列表 List&lt;Observer&gt; observers\nregisterObserver(Observer observer), 添加订阅者到列表中\nremoveObserver(Observer observer), 从列表中移除订阅者\n提供消息发布接口，notifyObservers(), 遍历列表，调用每个订阅者的更新接口\n\n订阅者 Observer\n提供消息更新接口，当主题发生变化时，主题会调用这个接口。\n\n策略模式在一个集所有商城的购物APP中购物，商品支付多种，不同支付方式则扣不同 如何实现？\n支付实现类，不同支付折扣不同\n京东支付\n淘宝支付\n微信支付\n支付宝支付\n\n折扣实现类\n微信支付 10%\n支付宝支付 20%\n支付宝支付 0%\n\n抽象策略类私有属性，支付接口，折扣策略接口，通过set设置接口实现，就可以提供不同的商品查询和支付方式策略。\n策略实现类策略1：微信支付，打折10%策略2：支付宝支付，打折20%策略3：拼多多商品，微信支付，不打折策略4：拼多多商品，支付宝支付，不打折\n商城客户端传入策略，调用支付接口。实现不同业务场景下使用不同的策略来完成支付打折。\n命令模式一个遥控器，有多个按钮，每个按钮对应一个命令，按下按钮，执行命令。\n命令执行接口\n执行命令接口，execute()\n\n命令实现类\n打开电视命令\n关闭电视命令\n打开空调命令\n关闭空调命令\n一个默认命令，什么都不做\n一个组合命令，包含多个命令，执行时，遍历列表，执行每个命令\n\n遥控器类\n内部维护一个命令列表 List&lt;Command&gt; commands，初始化时，添加默认命令到列表中\n注册命令，registerCommand(Command command), 添加命令到列表中\n每个按钮对应列表中的一个命令，按下按钮，执行命令。\n\n命令模式就是把命令封装成对象，然后将动作请求者与动作执行者完全解耦，上例中遥控器的按钮和电器什么关系都没有依然可以正常调用。\n装饰模式游戏装备，装备有攻击力，防御力，装备可以镶嵌宝石，宝石提升攻击力。\n装备接口\n攻击力\n描述\n\n装备实现类\n倚天剑\n屠龙刀\n\n宝石接口继承装备接口\n宝石实现类\n内部维护一个装备接口属性，通过构造函数传入\n实现攻击力接口，实现攻击力接口，返回装备实例的攻击力加上宝石的攻击力。\n实现描述接口，返回装备实例的描述加上宝石的描述。\n\n具体宝石实现类\n红宝石 攻击力提升10\n蓝宝石 攻击力提升20\n\n实际使用123456789101112// 一个镶嵌2颗红宝石，1颗蓝宝石的靴子System.out.println(&quot; 一个镶嵌2颗红宝石，1颗蓝宝石的靴子&quot;);IEquip equip = new RedGemDecorator(new RedGemDecorator(new BlueGemDecorator(new ShoeEquip())));System.out.println(&quot;攻击力  : &quot; + equip.caculateAttack());System.out.println(&quot;描述 :&quot; + equip.description());System.out.println(&quot;-------&quot;);// 一个镶嵌1颗红宝石，1颗蓝宝石的武器System.out.println(&quot; 一个镶嵌1颗红宝石，1颗蓝宝石,1颗黄宝石的武器&quot;);equip = new RedGemDecorator(new BlueGemDecorator(new YellowGemDecorator(new ArmEquip())));System.out.println(&quot;攻击力  : &quot; + equip.caculateAttack());System.out.println(&quot;描述 :&quot; + equip.description());System.out.println(&quot;-------&quot;);\n12345678一个镶嵌2颗红宝石，1颗蓝宝石的靴子攻击力  : 40描述 :圣战靴子+ 蓝宝石+ 红宝石+ 红宝石------- 一个镶嵌1颗红宝石，1颗蓝宝石,1颗黄宝石的武器攻击力  : 50描述 :屠龙刀+ 黄宝石+ 蓝宝石+ 红宝石-------\nJava 中的 IO 流就是装饰模式的应用。\n外观模式提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。其实就是为了方便客户的使用，把一群操作，封装成一个方法。\n我比较喜欢看电影，于是买了投影仪、电脑、音响、设计了房间的灯光、买了爆米花机，然后我想看电影的时候，我需要：1、打开爆米花机2、制作爆米花3、将灯光调暗4、打开投影仪5、放下投影仪投影区6、打开电脑7、打开播放器8、将播放器音调设为环绕立体声\n使用外观模式，定义两个方法，一个是打开电影，一个是关闭电影。\n\n打开电影1、打开爆米花机2、制作爆米花3、将灯光调暗4、打开投影仪5、放下投影仪投影区6、打开电脑7、打开播放器8、将播放器音调设为环绕立体声\n关闭电影1、关闭播放器2、关闭电脑3、放下投影仪投影区4、关闭投影仪5、将灯光调亮6、关闭爆米花机\n\n模板方法定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。比如定义一个上班族工作流程的抽象模板，提供接口：进入公司，打开电脑，上班情况，关闭电脑，离开公司。\n不同人实现的具体工作流程\n程序员，进入公司，打开电脑，写代码，关闭电脑，离开公司。\nPM，进入公司，打开电脑，开会，关闭电脑，离开公司。\nhr，进入公司，打开电脑，看简历-打电话-接电话，关闭电脑，离开公司。\n\n其中除了上班情况，其他都可以放到抽象模板中实现。\n状态模式定义：当对象的内部状态改变时，它的行为跟随状态的改变而改变了，看起来好像重新初始化了一个类似的。以自动售货机为例子。\n状态接口\n投币\n退币\n转动曲柄\n发放商品\n\n状态实现类每个实现类都需要传入自动售货机实例，当状态发生变化时，自动售货机的状态也会发生变化。\n\n没钱状态\n\n\n投币，改变状态为有投币状态\n退币，什么都不做\n转动曲柄，什么都不做\n发放商品，提示非法操作\n\n\n有投币\n投币，提示您已经投过币了，无需再投….\n退币，改变状态为没钱状态\n转动曲柄，改变状态为正在出货状态\n发放商品，什么都不做\n\n\n正在出货\n投币，什么都不做\n退币，什么都不做\n转动曲柄，什么都不做\n发放商品，调用自动售货机的发放商品方法，判断是否还有商品，有商品则改变状态为没钱状态，没有商品则改变状态为已售罄状态\n\n\n已售罄\n投币，什么都不做\n退币，什么都不做\n转动曲柄，什么都不做\n发放商品，提示商品已售罄\n\n\n\n自动售货机类它也需要实现State接口，并添加一个setState方法，用于设置当前状态。\n\n通过构造函数初始化对所有状态通过状态构造方法将this传入，完成初始化。\n提供setState方法，用于设置当前状态。\n默认设置为没钱状态。\n\n客户端创建自动售货机实例，调用投币接口，然后调用转动曲柄接口，然后调用退币接口，然后调用转动曲柄接口，然后调用转动曲柄接口。它会根据实际情况，调用不同的状态接口。\n可以看到，我们现在把每个状态对应于动作的行为局部化到了状态自己的类中实现，不仅增加了扩展性而且使代码的阅读性大幅度的提高。以后再添加状态，只需要针对新添加的状态的实现类，并在自动售货机中添加此状态即可。\n原型模式用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。\n这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。类似的还有内存缓存，当获取一个缓存对象时，我们可以直接返回它的克隆，而不是重新创建一个新的对象。同时避免元数据被修改的风险。\n享元模式主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。\n享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。\n同一个类型的对象使用同一个对象，减少内存占用。 在真正使用时只修改其属性执行享元接口;\n定义享元接口：创建一个享元接口，规定可以共享的状态。创建具体享元类：实现该接口的具体类，包含内部状态。使用享元工厂：创建一个工厂类，用于管理享元对象的创建和复用。\n","slug":"设计模式-概述","date":"2025-04-29T13:35:19.000Z","categories_index":"编程,设计模式","tags_index":"设计模式,软件架构","author_index":"Weiba"},{"id":"16e3b72ab86bdd03c61cdf559c2dc7de","title":"Js-Web转PDf框架的设计与实现","content":"\n设计开发了一个输出标准A3、A4等指定大小的PDF前端js框架，支持实时预览和字符级自适应分页，实时获取业务dom的精准坐标信息，所见即所得。后端使用Egg.js和Puppetteer构建Web转PDF文件服务，提供单机平均 200笔&#x2F;m PDF导出的稳定服务。完成Web端试卷、答题卡、批阅卡等业务的实时编辑、预览、排版与PDF导出，上线一个月稳定后成为标准的Web转PDF生成基础设施供其他开发组使用。\n\n前端使用Js实现一个框架，使用css ‘page-break-after: always;’ 实现换页。第一版：转为答题卡设计，一个a4大小的模板dom，然后通过js将固定的dom插入到指定位置，然后通过css ‘page-break-after: always;’ 实现换页。后端使用 java-wkhtmltopdf-wrapper 调用wkhtmltopdf命令行工具生成PDF文件, 我给他提交过pr。第一版在答题卡场景下是够用的，所有dom都是固定的。第二版: 由于业务需要，我们需要将线上试卷打印出来给线下答题，而题目大多数都是第三方导入的，dom结构是不确定的，并且要支持将dom拆分，一个题目内容像文章一样自动切分，经过我的调研，wk是不行的，因为它的wekit内核太老了，不支持es6语法，部分题目的样式它不支持，js直接生成pdf文件都是直接截图的，太大了，我们后期可能要将整本书都弄进来，位置也会产生变化，而且我们需要在后端生成pdf，最终确定使用Puppetteer调用chrome的打印功能来做。\n前端在原来的基础上，我们做了一个自适应分页的框架，设计理念就是页面所有内容都是一个block块，包含PageBlock, loyoutBlock, ContentBlock，三个类型，PageBlock和LayoutBlock生成通过配置文件定义，由框架自动生成，ContentBlock 由数据适配器根据业务数据生成, 每页初始化时，框架会先根据配置生成对应的PageBlock和LayoutBlock，然后将ContentBlock依次渲染到当前渲染中的容器中，block放不下就触发溢出处理，dom是没法通过文字计算高度的，通过二分法，将内容拆一半，然后再判断是否能放下，放不下就继续二分，直到能放下为止，然后再将剩余的内容生成新的block，后面按这样的将所有block生成完，我们可以轻松通过配置文件定义PDF页面的整体布局，比如竖版和横板。\n\n数据适配器 将业务数据转为框架需要的渲染的元数据，包含page,layout,block\n渲染处理器 将元数据渲染到容器中\n数据构建器 构建框架，将数据适配器和渲染处理器组合起来，生成一个完整的框架\nblock基类 工厂方法，生成block\nPageBlock基类 定义页大小这里面的坑，第一个图片，图片必须等待它完全加载后才能执行下一个，字体，必须使用自定义字体，否则linux和windows渲染可能有偏移导致不一致。\n\n后端 Puppetteer 官方支持nodejs, 我使用了egg.js创建了一个web服务，然后通过generic-pool创建了一个线程池，通过配置文件控制线程池中chrome的总实例和page的总实例。对外暴露一个接口来调用pdf生成，要生成的url经过base64转换，防止参数丢失。\n最大的坑，字体，Linux端和windows端字体渲染高度不一致，导致两边pdf不一样，自定字体解决，chrome内核版本，不同chrome内核渲染结果不一样，特别是老版本的，需要定期更新。由于框架内容是异步生成的，必须在页面设置钩子，来确保内容生成完毕后在生成pdf。\n\n使用Tensoflow训练手写分类模型，基于MNIST手写数据集训练英文与数字字符模型，收集自定义数据集完成批阅勾、叉、划线等字符的自定义分类模型，并设计数据收集方案，定期进行增量训练，性优化网络结构，提升识别能力，识别率从刚上线的85%到97%+。模型通过TF Java后端接入系统，并部署到小程序，平板端完成部分离线识别场景. cnn 卷积神经网络，图片转为单通道，归一化， 3*3 取 28 个特征，池化，全连接，要定义模型的输入名称，输出名称，不然java的后端模型载入时必须传入正确的名称否则无法初始化。难点：找数据，github上有一个手写数字和英文字符的数据集 extra_keras_datasets，我提交过pr，数据标注：我们的流程是批阅完成后，老师需要手动检查结果，有问题的需要老师手动修改，我们会对这个数据进行标注。然后每个月专们去看下标注结果，然后每个星期一，去看看这个识别错误的数据，重新标注，有定时任务在月底自动做增量训练。数据量不够，模型训练效果不够好，必须累积一下。\n1234567891011121314151617181920212223242526272829303132333435363738394041def model_build(self):    # 构建模型    model = Sequential([        # 接收单通道图        Input([28, 28, 1], name=&#x27;init_operation&#x27;),        # 归一化        Rescaling(1. / 255),        # 卷积核 大小(3*3) 提取28个特征,        # 默认使用&quot;same&quot;填充方式，确保输出特征图的大小与输入特征图一致。        # 输入形状为28x28的灰度图像。激活函数为ReLU。        Conv2D(28, 3, activation=&#x27;relu&#x27;),        # 添加了一个最大池化层，将图像的尺寸缩小一半。        # 对输入特征图进行空间降维。通过将2x2的池化窗口应用于输入特征图，每个窗口中的最大值被选择作为输出特征图的单个像素。        # 这样可以减小特征图的空间尺寸，从而提取出更具有代表性的特征。        MaxPooling2D((2, 2)),        #  降维后特征会比较明显，所以提取的特征点会增大        Conv2D(64, (3, 3), padding=&#x27;same&#x27;, activation=&#x27;relu&#x27;),        # 第一个MaxPooling2D操作将特征图的尺寸从28x28缩小到14x14，第二次MaxPooling2D操作将特征图的尺寸进一步缩小到7x7。        # 通过这种逐步减小特征图尺寸的方式，可以提取出更抽象、更高级的特征，使得模型更具有表征能力。        MaxPooling2D((2, 2)),        # 将输入的多维特征图转换为一维向量，以便将其作为输入传递给后续的全连接层        Flatten(),        # 全连接，一个具有512个神经元和ReLU激活函数的全连接层。        # 全连接层的目的是将前一层的特征转换为当前层的特征，并通过学习连接权重和非线性变换，实现模型的分类或回归任务。        # 通过连接前一层的所有神经元和当前层的所有神经元，将前一层的特征映射转换为当前层的特征映射。        # 每个神经元在全连接层中都与前一层的所有神经元相连接，这样可以保留并整合前一层的所有信息。        # 它通常是神经网络模型的最后一层，用于将前面的特征提取层（如卷积层或池化层）学到的特征进行分类或回归。        # 通过全连接层，模型可以将高级抽象的特征转换为最终的输出结果。        # 在全连接层中，神经元之间的连接权重可以通过反向传播算法进行学习和优化，以达到更准确的模型输出。        # 通常，在全连接层之后会使用激活函数对每个神经元的输出进行非线性变换，进一步增强模型的表达能力。        Dense(512, activation=&#x27;relu&#x27;),        # 在训练过程中随机丢弃10%的神经元，以防止过拟合        Dropout(0.1),        Dense(128, activation=&#x27;relu&#x27;),        Dropout(0.1),        # 输出层的单元数量，对应分类任务分类数        Dense(self.target_labels_len, activation=&#x27;softmax&#x27;, name=&#x27;end_operation&#x27;)    ])    return model\n交卷智能识别处理，通过PDF生成框架完成PDF文件与坐标数据的生成。打印后学生纸笔答题，通过拍照或扫描仪提交答卷图片，后端使用OpenCV通过锚点定位和透视变换等处理，通过坐标信息，识别选择题答案，非选择题截取后录入系统。\n\n智能纸笔批阅系统，依托PDF生成框架生成标准的A3、A4试卷、批阅卡，答题卡等业务的详细坐标信息，配合第三方PDF点阵铺码完成试卷、答题卡、批阅卡等物料的制作， 用户通过点阵笔上传批阅和答题等手写数据，使用识别模型完成自动化批阅，打通线下纸笔与线上数据难以互通的问题，补全数字化课堂最重要的一个业务场景。\n\n缓存工具设计，通过Caffeine本地与Redis实现双缓存机制，有效减少redis缓存延时带来的性能问题。只在热点接口上使用内存缓存。\n\n动态定时任务下发，通过api可动态创建在指定时间执行某个服务的的某个接口，完成预热等服务的实现，提前将热点数据缓存。解决期中、期末大型线上考试等热点接口的迅时流量问题。\n12通过定时任务在每天凌晨查询预热表中今天要考试的测验，将这些测验根据时间都加到缓存预热队列中。在测验修改和新增的接口使用aop，将他们加到缓存预热队列中，缓存预热队列有一个定时任务，每十分钟执行一次，查看这十分钟内是否有要考试的测验，有就执行对应的handel去解析需对应的任务数据，通过getBean获取实例，通过反射执行对应的方法。\n\n缓存系统数据不一致优化，原缓存系统存在Redis与Mysql数据不一致问题，如测验、资源包等关键业务更新时时常出现不一致问题，通过引入Canal对关键业务表监控，基本解决Redis与Mysql数据不一致性问题。\n\n\n\n其他组部署的Canal服务，通过订阅Mysql的binlog日志，将变更的数据同步到Redis。\n编写试卷表的监听器，继承EntryHandler接口，实现数据变更时的回调，将变更的数据同步到Redis。\n\n\n第三方服务对接，部分资源需要接入第三方服务，根据整体架构及商务需求，开发对接系统，所有第三方服务都通过云端对接其SDK，由客户端发起调用，云端作为代理，支持实时和异步处理，异步处理提供回调接口，实现华翰云网阅系统、学科网、极值网等各种第三方教学服务接入。\n\n内容爬取器，将第三方数据持久化并将其中的网络资源扫描并上传至本地文件服务。简单的直接逆袭接口，实现前面或登录。复杂一点无法逆向的，编写一个chrome插件，实现自动登录，然后开始爬数据，都不用加密解密接口，只要web能看到，就可以爬。\n\n通过第三方OCR接口将资源组截图录入资源识别并录入ES。\n\n源码中文翻译处理器：台湾项目不允许出现简体字，配合翻译API将源码中所有的中文注释都翻译为繁体。判断字符是否在[\\u4e00-\\u9fa5]这个范围内，如果是，则认为是中文。使用解释器模式，将源码中的中文注释提取出来，然后调用翻译API，将中文注释翻译为繁体。\n\n年会抽奖系统设计，通过Redis中Set的随机接口为核心，设计了一个抽奖系统。非常简单，通过Redis的Set数据结构，将所有的用户ID存入Redis中，然后通过Redis的随机接口 SPOP key [count] ，随机取出一个用户ID，即为中奖用户，安慰奖几个，三等奖几个，已中奖的用户不再参与后面的抽奖。\n\nRedis基础数据结构，String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）\n\n\n协助文件服务组接入阿里云OSS，解决云端文件下载带宽不足问题。\n\n开发支持Android端的业务处理Java Lib包。\n\n推动Vue开发部分业务及前后端分离架构，Angular重构前端业务。\n\n各种服务、依赖部署文档的编写及其它业务需求开发。\n\n\n","slug":"Js-Web转PDf框架的设计与实现","date":"2025-04-29T09:38:40.000Z","categories_index":"","tags_index":"Js，NodeJs,PDF,Js框架","author_index":"Weiba"},{"id":"6456b03f672a87198a79af9e60f25dff","title":"Java-基于Redis的高性能任务队列设计与实现","content":"我们早期2.0系统交卷是同步提交，交一笔写一笔，还要做各种逻辑处理，通知其他服务修改活动状态，在班级考试里还能用，只是慢，qps不超50, 后来需要支持年级考试，压测必挂。让我负责重构升级：首先想上mq，隔壁组在用rabbitmq，发现有丢数据的情况，但这个需求比较急，等不到它们解决完，所以我尝试自己建一个任务队列来实现。简单数据提交轻松上 1000+/s, 处理速度看实际业务复杂度，300+/s 交卷无问题。\n首先定义核心要解决的问题\n保证高并发，部分业务场景如期末考试，校级联考，会瞬间有大量提交。\n必须保证让用户感知到提交成功或失败，提交成功的数据不能丢失。\n数据必须批量提交，否则mysql写入qps上不去。\n数据处理速度要快，不能让用户等太久。\n\n实现经过三天调研和demo验证，最终数据入库使用请求合并将数据批量入库，数据处理使用 Redis的List做了一个任务处理队列，可实现多节点生产(瓶颈在Mysql写入，真要多节点还是上mq吧)和多节点消费。\n请求合并处理器\n包含一个无界的静态属性 LinkedBlockingQueue&lt;SubmitTaskRequestBO&gt; requestQueue = new LinkedBlockingQueue&lt;&gt;(); 用来存储待提交的任务数据。\n使用 ApplicationRunne扩展点 ，在服务启动时创建一个线程，使用自旋的方式读取 requestQueue , 默认阻塞。\n当请求线程提交数据时，将数据根据任务Type通过简单工厂封装成对应的待提交任务对象 taskItem，每个待提交任务对象中都封装了一个 CompletableFuture&lt;TaskRequestDataBO&gt; future = new CompletableFuture&lt;&gt;(); 属性，将 taskItem 提交到 requestQueue  队列后，执行 future.get()  阻塞提交线程。\n当有数据提交至requestQueue 队列中，之前的阻塞被释放，可以开始处理数据了。\n当requestQueue 队列中数据大于等于我们的要求的批量处理数据量时，直接提交。\n当requestQueue 队列中数据少于我们的要求的批量处理数据量时，等待指定时间再进行检测，当超过最大等待时间直接提交。\n\n\n数据提交：\n将数据批量提交到DB，并完成任务对象的 CompletableFuture, 此时请求线程被释放。\n将数据批量提交到 Redis任务队列中，redis 挂了也不影响数据持久化。\n\n\n\n基于Redis的List的任务队列依靠Redis List的 leftPushAll(左进)  rightPop(右出) api 实现先进先出队列，并且依靠Redis的单线程模型，我们获取List 数据操作都是原子性的，不会出现重复数据，且可以多端无锁消费。\nAbstractJedisListQueue 队列封装抽象通过 Jedis 封装 pull 和 push，实现 leftPushAll(左进)  rightPop(右出) ，通过自定义命名空间来区分不同的队列。\n特性：\n\npush(List&lt;T&gt; list)：直接调用 jedis.lpush(collectKey, collect.toArray(new String[collect.size()])); api\npoll(int size):  注意它无数据时是阻塞的。\n支持全速模式和非全速模式 fullSpeedMode, 默认 fullSpeedMode 为 false; 它是AbstractJedisListQueue 的成员属性。\n它是因为 jedis.brpop(collectKey, x, TimeUnit.MINUTES) api 阻塞时间过长会导致睡死过去才添加的特性。\n当 fullSpeedMode 为true时标识任务队列中存在数据，此时poll(int size)api将不会有任何阻塞\n\n\n检测是否存在任务数据\nfullSpeedMode 为false时使用阻塞api jedis.brpop(collectKey, 1, TimeUnit.MINUTES) 获取数据。\nfullSpeedMode 为true时使用非阻塞api jedis.rpop(collectKey) 检测是否存在数据。\n\n\n检测结果\n有数据时，将 fullSpeedMode 设置为true，根据size调用非阻塞api jedis.rpop(collectKey) \n当没有数据时\n记录没有值的次数 reEmptyPullCount，当 reEmptyPullCount 大于60次，将 fullSpeedMode 设置为 false\n等待1s后返回 null。\n\n\n\n\n\n\n\n实现类：\n\nPreprocessTaskDataQueue ：任务处理队列\nErrorTaskDataQueue：失败任务队列\n\nTaskDataMaintenanceProcessor 任务数据维护器它的主要作用是服务重启后，默认从DB将任务数据加载到 Redis 队列中，并为所有节点提供任务数据，将执行失败且未超过重试次数的任务重新加入到执行队列中。其他处理节点通过该处理器获取任务数据，该处理器只有主节点会执行。\n执行过程为使用 ApplicationRunner 扩展点：\n\n初始化任务处理队列： PreprocessTaskDataQueue + 失败任务队列：ErrorTaskDataQueue\n将DB中未处理的任务数据加载到 PreprocessTaskDataQueue 队列中.\n开启一个线程自旋开始处理失败任务数据，每次等待30s再将失败任务返回队列，防止是由于部分服务重启导致的暂时性失败。\n\nTaskHandler 任务处理器真正执行任务处理的实际逻辑。\nExecutionTask 实现 Callable 的任务执行器在线程池中代理执行 TaskHandler ，封装任务数据和TaskHandler ，并执行TaskHandler ，对 TaskHandler 执行状态的封装处理。\nTaskDataProcessorRunner 任务数据处理器它主要作用是处理 PreprocessTaskDataQueue 中的任务数据，通过taskTyp使用简单工厂获取并执行对应的 TaskHandler，封装成并将执行失败的任务加到 ErrorTaskDataQueue 队列中。\n执行过程为使用 ApplicationRunner 扩展点，开启一个线程自旋：\n\ntaskDataMaintenanceProcessor.poll(size)  获取数据, 主节点直接内部调用，跨节点 sdk rpc;\n遍历任务数据\n并根据任务类型获取对应执行的线程池\n根据线程池获取对应的任务集合，taskList\n通过任务数据，使用简单工厂构建 ExecutionTask，并提交到线程池中。\n将提交结果添加到taskList。\n\n\n提交完毕开始遍历所有线程池及其对应他taskList，获取执行结果\n将失败且未达到重试次数的数据放到ErrorTaskDataQueue (TaskDataMaintenanceProcessor 会自动将他放回到队列中)。\n\n\n\n该框架最终扩展为小型的任务队列框架，在不需要使用mq的业务如批量离线试卷的导出与导入、批量Word的生成、PDF导出等场景平稳落地使用至今。\n","slug":"Java-基于Redis的高性能任务队列设计与实现","date":"2025-04-29T09:19:39.000Z","categories_index":"","tags_index":"Java,请求合并,Redis阻塞队列,任务队列","author_index":"Weiba"},{"id":"74b4ce53d861aece862753ca4c35dd9e","title":"Java-高级-Day-5-JVM性能优化","content":"核心点\n所有优化都要根据实际服务的具体业务场景做优化配置，没有通用的配置。\nGC 优化目标：降低 full gc 产生的 STW ,让短期存活的对象尽量都留在 survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc。让长期存活的对象尽早进入老年代，不要占用年轻代空间。\n缓存类等需要大量对象长期存活的服务，老年代要够大。\n非缓存服务且压力比较大的服务，比如订单服务，年轻代一定要大一点，年轻代过小会导致下面的问题：\nSurvivor区空间不足：如果年轻代设置过小，Survivor区空间紧张，可能导致对象在未达到 MaxTenuringThreshold 之前就被迫晋升。\n垃圾回收频率过高：频繁的minor gc会导致对象年龄增长加快，可能在Survivor区中快速累积到触发条件。\n触发对象动态年龄判断：如果某一年龄的对象总大小超过了Survivor区的50%，那么所有大于等于该年龄的对象会被直接晋升到老年代。\n短生命周期对象过多：如果应用中有大量短时间内创建并消亡的对象，这些对象可能在Survivor区快速积累，超过50%的阈值，触发动态年龄判断，导致晋升。\n对象大小分布不均：如果某类对象的大小突然增加，或者同一批对象同时达到某个年龄，可能突然超过Survivor区的50%，引发晋升。\n\n\n\n\n让全局对象尽早进入老年代不要占用年轻代空间：减少默认的分代年龄配置，根据实际观察来配置，一般5左右, 可以设置：‐XX:MaxTenuringThreshold=5\n让大对象直接进入老年代，系统内的缓存对象或全局对象，一般都比较大，且需要长期存活，可以设置 ‐XX:PretenureSizeThreshold=1M\n注意要根据实际业务对象大小去设置。\n\n\n老年代空间分配担保机制: 老年代最大可用连续空间是否大于新生代所有对象总大小，如果大于，则Minor GC可以确保安全, 执行Minor GC.\n对延时敏感的服务可以使用CMS(并发-标记-清理)垃圾收集器\nCMS: 并发标记清理，也就是执行后内存是不连续的，需要进行碎片整理。\n\n\n\n工具Arthas\n\ndashboard: 整个进程的运行情况，线程、内存、GC、运行环境信息\nthread: 查看线程详细情况\nthread加上线程ID 可以查看线程堆栈\nthread -b 可以查看线程死锁\n\n\njad加类的全名 可以反编译，这样可以方便我们查看线上代码是否是正确的版本\nognl 可以查看线上系统变量的值，也可以修改变量的值\nwatch 类的完整限定名 方法 可以查看方法的入参和返回值\ntrace 类的完整限定名 方法 可以查看方法执行的\n\nGC 优化环境：4核3G，每秒300请求，每个请求平均纯业务实体数据15Kb，对其转为对象进行处理还有其他对象生成 5Kb和其他因素扩大10倍， 每秒生成对象：(15Kb+5Kb) * 10 * 300 个答案对象，60MB&#x2F;s\n未优化：\n\n年轻代1GB(eden:800MB s0:100MB s1:100MB)   老年代 2GB\n** 15s 左右撑满Eden区，注意s区只有100MB，对象动态年龄判断阈值在50MB**\n**压力很大的服务，资源是很紧缺的，接口的对象可能会堆积，那Eden满了在 Minor GC 时，有大几率进入s区的对象回超过50MB, 那么所有大于等于该年龄的对象会被直接晋升到老年代，会频繁触发 full gc **\n\n优化：\n\n年轻代2GB(eden:800MB s0:200MB s1:200MB)   老年代 1GB\n\n压力较大的业务系统，90% 应该都是临时对象，要确保他们在年轻代就被销毁。\n\n全局对象1GB如果不够，那就需要提高配置了。\n\n本例中一次minor gc要间隔二三十秒，大多数对象一般在几秒内就会变为垃圾，完全可以将默认的15岁改小一点，比如改为5，那么意味着对象要经过5次minor gc才会进入老年代，整个时间也有一两分钟了，如果对象这么长时间都没被回收，完全可以认为这些对象是会存活的比较长的对象，可以移动到老年代，而不是继续一直占用survivor区空间。\n\n对于多大的对象直接进入老年代(参数-XX:PretenureSizeThreshold)，这个一般可以结合你自己系统看下有没有什么大对象生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始化分配的缓存对象，比如大的缓存List，Map之类的对象\n\n对于JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)，如果内存较大(超过4个G，只是经验值)，系统对停顿时间比较敏感，我们可以使用ParNew+CMS(-XX:+UseParNewGC -XX:+UseConcMarkSweepGC)\n\n老年代CMS的参数如何设置？\n\n首先我们想下当前这个系统有哪些对象可能会长期存活躲过5次以上minor gc 最终进入老年代：Spring容器里的Bean，线程池对象，一些初始化缓存数据对象等，这些加起来充其量也就几十MB。\n\n如果突然某一秒瞬间要处理五六百请求，那么每秒生成的对象可能有一百多M，再加上整个系统可能压力剧增，一个请求要好几秒才能处理完，下一秒可能又有很多订单过来，那么就会直接进入老年代。我们可以估算下大概每隔五六分钟出现一次这样的情况，那么大概半小时到一小时之间就可能因为老年代满了触发一次 Full GC，Full GC的触发条件还有我们之前说过的老年代空间分配担保机制，历次的 minor gc 挪动到老年代的对象大小肯定是非常小的，所以几乎不会在 minor gc 触发之前由于老年代空间分配担保失败而产生 full gc，其实在半小时后发生 full gc，这时候已经过了交卷的最高峰期，后续可能几小时才做一次 FullGC。\n\n对于碎片整理，因为都是1小时或几小时才做一次 FullGC ，是可以每做完一次就开始碎片整理，或者两到三次之后再做一次也行。综上，只要年轻代参数设置合理，老年代CMS的参数设置基本都可以用默认值，如下所示：\n123‐Xms3072M ‐Xmx3072M ‐Xmn2048M ‐Xss1M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:SurvivorRatio=82 ‐XX:MaxTenuringThreshold=5 ‐XX:PretenureSizeThreshold=1M ‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC3 ‐XX:CMSInitiatingOccupancyFraction=92 ‐XX:+UseCMSCompactAtFullCollection ‐XX:CMSFullGCsBeforeCompaction=0\n\n\n\n\n\n详细解析\n\n","slug":"Java-高级-Day-5-JVM性能优化","date":"2025-04-27T08:23:22.000Z","categories_index":"","tags_index":"Java-Day,Java-高级-Day","author_index":"Weiba"},{"id":"55e262e45820c6fc0e5602715c3359d4","title":"Java-高级-Day-4-GC垃圾收集算法","content":"核心点分代收集理论\n新升代：复制算法，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法\n老年代：“标记-清除”或“标记-整理”算法，对象存活几率是比较高，而且没有额外的空间对它进行分配担保，必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n核心算法\n标记-复制算法(空间换时间)：将内存分为两块相同的的大小，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉，这样就使每次的内存回收都是对内存区间的一半进行回收。\n标记-清除算法：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：\n效率问题  (如果需要标记的对象太多，效率不高)\n空间问题（标记清除后会产生大量不连续的碎片）\n\n\n标记-整理算法(标记清除算法升级): 根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n垃圾收集器(理论的实现)\n\nSerial&#x2F;Serial Old: 单线程收集器，新生代使用复制算法，老年代使用标记-整理算法。没有线程交互开销，可以获得很高的单线程收集效率，缺点：在进行垃圾收集时，必须暂停其他所有的工作线程(STW-Stop The World)，直到它收集结束, 延时高。一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。\nParallel Scavenge&#x2F;Parallel Old(JDK8默认)：Serial 的多线程版本，默认的收集线程数跟cpu核数相同，新生代采用复制算法，老年代采用标记-整理算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑它；\nParNew：跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。新生代采用复制算法，它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作。\nCMS(Concurrent Mark Sweep 并发标记清除)：HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，以获取最短回收停顿时间为目标的收集器。优点：并发收集、低停顿。  它的执行过程分为以下四个步骤：  - 初始标记： STW，并记录下GC Roots直接能引用的对象,速度很快。      - 并发标记： 从GC Roots的直接关联对象开始遍历整个对象图,耗时较长但是不需要停顿用户线程。因为用户线程继续运行，可能会有导致已经标记过的对象状态发生改变。      - 重新标记： STW, 主要是处理漏标问题, 修正并发标记期间因用户程序运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法做重新标记。      - 并发清除： 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理。      - 并发重置：重置本次GC过程中的标记数据。\nCMS 缺点：\n对CPU资源敏感（会和服务抢资源）；\n无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；\n它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理\n执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，此时会进入stop the world，用serial old垃圾收集器来回收\n\n\n\n\nG1 JDK8且内存大于8GB及以上推荐，JDK8的实现效率不如CMS。\n\n三色标记三色标记算法是把Gc roots遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：\n\n白色：对象遍历时初始化状态，标识未被GC Rooots 引用。若在分析结束的阶段，仍然是白色的对象，即代表不可达，可清理。\n灰色(没扫描完，可能被引用)：没扫描完，这个对象上至少存在一个引用还没有被扫描到，不能删除。\n黑色：已扫描完，肯定有引用，必须存活。\n\n多标-浮动垃圾并发标记(还有并发清理)开始后，如果由于标记过程中对象间引用发生变化，则会导致本来应该清理的对象，没有得到及时的清理，这种情况就被称为浮动垃圾。通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。\n漏标-写屏障漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，解决方案(都使用写屏障实现)：    - 增量更新(Incremental Update): 黑色对象插入新的指向白色对象的引用关系时， 将这个新插入的引用记录，等并发扫描结束后，再将记录的引用关系中的黑色对象为根,重新扫描一次。    - 原始快照(Snapshot At The Beginning，SATB): 当灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用记录，等并发扫描结束之后，再将记录的引用关系中的灰色对象为根，重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)\nJava HotSpot VM 漏标时的处理实现\nCMS：写屏障 + 增量更新\nG1，Shenandoah：写屏障 + SATB\nZGC：读屏障\n\n为什么G1用SATB？CMS用增量更新？SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。\n记忆集与卡表在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。需要建立一个“记忆集”的数据结构(相当于一张表)，记录下老年代中所有指向新生代的指针。在做GC Roots可达性扫描的时候，就能通过这个记忆集避免扫描整个老年代。卡表就是记忆集的实现。    - 卡表    卡表使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。        - 卡页：一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0. GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。        - Hotspot使用写屏障维护卡表状态。\n详细解析\n垃圾收集算法分代收集理论当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。举例：\n\n新升代：复制算法，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法\n老年代：“标记-清除”或“标记-整理”算法，对象存活几率是比较高，而且没有额外的空间对它进行分配担保，必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。\n标记-复制算法为了解决效率问题，“复制” 收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\n\n\n标记-清除算法算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：\n\n效率问题  (如果需要标记的对象太多，效率不高)\n空间问题（标记清除后会产生大量不连续的碎片）\n\n\n\n标记-整理算法根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n\n垃圾收集器\n\n如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。\n没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的Java虚拟机就不会实现那么多不同的垃圾收集器了。\nSerial(串行)收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。\n新生代采用复制算法，老年代采用标记-整理算法。\n\n\n虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\n但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。\nSerial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。\nParallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。\nParallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。\n新生代采用复制算法，老年代采用标记-整理算法。\n\n\nParallel Old收集器是Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(JDK8默认的新生代和老年代收集器)。\nParNew收集器(-XX:+UseParNewGC)ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。\n新生代采用复制算法\n\n\n它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\nCMS收集器(-XX:+UseConcMarkSweepGC(old))CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\n从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n\n初始标记： 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。\n\n并发标记： 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。\n\n重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录(主要是处理漏标问题)，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的****增量更新算法(见下面详解)做重新标记。\n\n并发清理： 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。\n\n并发重置：重置本次GC过程中的标记数据。\n\n\n\n\n从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面几个明显的缺点：\n\n对CPU资源敏感（会和服务抢资源）；\n\n无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；\n\n它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理\n\n执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure“，此时会进入stop the world，用serial old垃圾收集器来回收\n\n\nCMS的相关核心参数\n-XX:+UseConcMarkSweepGC：启用cms \n\n-XX:ConcGCThreads：并发的GC线程数\n\n-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）\n\n-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次  \n\n-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）\n\n-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整\n\n\n-XX:+CMSScavengeBeforeRemark：用于在CMS垃圾收集器的重新标记阶段（Remark）之前，强制触发一次年轻代的垃圾回收。其目的是减少需要扫描的对象数量，从而缩短重新标记阶段的停顿时间。\n\n-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW\n\n-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;\n\n\n垃圾收集底层算法实现三色标记法(黑灰白)在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。漏标的问题主要引入了三色标记算法来解决。\n三色标记算法是把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：\n\n黑色： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。\n\n灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。\n\n白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。\n\n\n\n\n\n\n123456789101112131415161718192021222324252627282930/** * 垃圾收集算法细节之三色标记 * 为了简化例子，代码写法可能不规范，请忽略 */public class ThreeColorRemark &#123;     public static void main(String[] args) &#123;        A a = new A();        //开始做并发标记        D d = a.b.d;   // 1.读        a.b.d = null;  // 2.写        a.d = d;       // 3.写    &#125;&#125; class A &#123;    B b = new B();    D d = null;&#125; class B &#123;    C c = new C();    D d = new D();&#125; class C &#123;&#125; class D &#123;&#125;\n\n多标-浮动垃圾在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。\n另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。\n漏标-读写屏障漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： 增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。\n增量更新就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。\n原始快照就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)\n以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。 \n写屏障给某个对象的成员变量赋值时，其底层代码大概长这样：\n1234567/*** @param field 某对象的成员变量，如 a.b.d * @param new_value 新值，如 null*/void oop_field_store(oop* field, oop new_value) &#123;     *field = new_value; // 赋值操作&#125; \n\n所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）：\n12345void oop_field_store(oop* field, oop new_value) &#123;      pre_write_barrier(field);          // 写屏障-写前操作    *field = new_value;     post_write_barrier(field, value);  // 写屏障-写后操作&#125;\n\n写屏障实现SATB当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d &#x3D; null），我们可以利用写屏障，将B原来成员变量的引用对象D记录下来：\n1234void pre_write_barrier(oop* field) &#123;    oop old_value = *field;    // 获取旧值    remark_set.add(old_value); // 记录原来的引用对象&#125;\n\n写屏障实现增量更新当对象A的成员变量的引用发生变化时，比如新增引用（a.d &#x3D; d），我们可以利用写屏障，将A新的成员变量引用对象D记录下来：\n123void post_write_barrier(oop* field, oop new_value) &#123;      remark_set.add(new_value);  // 记录新引用的对象&#125;\n\n读屏障1234oop oop_field_load(oop* field) &#123;    pre_load_barrier(field); // 读屏障-读取前操作    return *field;&#125;\n\n读屏障是直接针对第一步：D d &#x3D; a.b.d，当读取成员变量时，一律记录下来：\n1234void pre_load_barrier(oop* field) &#123;      oop old_value = *field;    remark_set.add(old_value); // 记录读取到的对象&#125;\n\n现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色&#x2F;黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈&#x2F;队列&#x2F;缓存日志等方式进行实现、遍历方式可以是广度&#x2F;深度遍历等等。\n对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：\n\nCMS：写屏障 + 增量更新\n\nG1，Shenandoah：写屏障 + SATB\n\nZGC：读屏障\n\n\n工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代&#x2F;区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。\n为什么G1用SATB？CMS用增量更新？\n我的理解：SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。\n记忆集与卡表在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。\n为此，在新生代可以引入记录集（Remember Set）的数据结构（记录从非收集区到收集区的指针集合），避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。\n垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。\nhotspot使用一种叫做“卡表”(Cardtable)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。\n卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。\nhotSpot使用的卡页是2^9大小，即512字节\n\n\n一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.\nGC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。\n卡表的维护\n卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。\nHotspot使用写屏障维护卡表状态。\t\n","slug":"Java-高级-Day-4-GC垃圾收集算法","date":"2025-04-24T05:26:47.000Z","categories_index":"","tags_index":"Java-Day,Java-高级-Day","author_index":"Weiba"},{"id":"8034d4b46da16be185cdc304107292a3","title":"Java-高级-Day-3-GC垃圾回收","content":"核心点堆内存分配比\n老年代:新生代 2:1\n新生代 Eden区:Survivor0区:Survivor1区 占比 8:1:1\n\n分配策略\n对象在分配时使用CAS算法来保证并发时的内存分配效率\n大对象直接进入老年代，它需要大量连续内存空间的对象（比如：字符串、数组），当Eden区放不下这个对象时，会直接分配到老年代中，可以通过-XX:PretenureSizeThreshold参数来设置大对象的阈值, 默认为0，即不启用。\n长期存活的对象将进入老年代 分代年龄达到15岁的对象会进入老年代，可以通过-XX:MaxTenuringThreshold参数来设置分代年龄的阈值，默认为15，最大值15，最小值1。\n对象动态年龄判断: 如果某一年龄的对象总大小超过了Survivor区的50%，那么所有大于等于该年龄的对象会被直接晋升到老年代, 无需等到15岁。 可通过 -XX:TargetSurvivorRatio 参数来设置动态年龄的阈值, 默认为50，最大值99，最小值1。\n老年代空间分配担保机制: 在Minor GC发生前策略, 可通过-XX:HandlePromotionFailure=true配置，JDK6之后默认开启。\n首先检查老年代最大可用连续空间是否大于新生代所有对象总大小，如果大于，则Minor GC可以确保安全, 执行Minor GC；\n如果小于，则检查-XX:HandlePromotionFailure参数是否设置为true，如果是，则会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小\n如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；\n如果小于，则会进行一次Full GC。 \n\n\n\n垃圾回收机制Minor GCEden区满时触发,将Eden区和Survivor0区中的存活对象复制到Survivor1区中，然后清空Eden区和Survivor0区，下次Minor GC时，会将Eden区和Survivor1区中的存活对象复制到Survivor0区中，以此类推。\n\n新升代中分代年龄达到15，进入老年代，0&lt;分代年龄&lt;15;\neden区放不下的大对象直接进入老年代。\n\nFull GCFull GC 的回收目标\n新生代(Young Generation)\n\n**老年代(Old Generation)**：\n\n**元空间(Metaspace)**：\n\n替代永久代(PermGen)的内存区域\n当元空间使用量达到MaxMetaspaceSize阈值时，会触发Full GC进行垃圾回收”\n\n\n方法区：\n\n存储类信息、常量、静态变量等\n\n\n其他系统区域：\n\n包括JVM内部数据结构\n系统类加载器加载的类对象等\n\n\n\nFull GC是全局性垃圾回收，会扫描JVM管理的所有内存区域，而Minor GC只处理新生代区域。\nFull GC的触发条件\n老年代空间不足：当老年代空间不足以存放从年轻代晋升的对象时，会触发Full GC。\n\n永久代&#x2F;元空间不足（取决于JVM版本）：\n\nJava 8之前：永久代(PermGen)空间不足\nJava 8及之后：元空间(Metaspace)空间不足\n\n\nSystem.gc()调用：当代码中显式调用System.gc()时，可能会触发Full GC（取决于JVM参数-XX:+DisableExplicitGC的设置）。\n\nCMS GC失败：在使用CMS收集器时，如果并发模式失败（Concurrent Mode Failure），会触发Full GC。\n\n晋升失败：当年轻代对象需要晋升到老年代，但老年代没有足够空间时。\n\n分配担保失败：在Minor GC之前，如果老年代最大可用连续空间小于历次晋升到老年代对象的平均大小，会触发Full GC。\n\n堆内存分配失败：当JVM无法为新对象分配内存时。\n\n手动触发：通过JVM工具（如jcmd、jconsole）手动触发Full GC。\n\n\nGC Roots\n线程栈中的引用对象 ：\n当前执行方法中的局部变量和参数\n每个线程栈帧中引用的对象\n\n\n方法区中的静态属性引用 ：\n类的静态变量(static修饰)\n例如： public static Object obj &#x3D; new Object();\n\n\n方法区中的常量引用 ：\n字符串常量池中的引用\nfinal修饰的常量引用的对象\n\n\n本地方法栈中的JNI引用 ：\nNative方法引用的对象\nJNI调用的本地代码创建的对象\n\n\n活跃线程的引用 ：\n当前运行线程对象(Thread)\n线程栈中的局部变量引用\n\n\n同步锁持有的对象 ：\n被 synchronized 锁持有的对象\n同步代码块&#x2F;方法使用的锁对象\n\n\nJVM内部系统对象 ：\n系统类加载器加载的类对象\n基本数据类型对应的Class对象\n\n\n管理接口相关引用 ：\nJMXBean等管理接口引用的对象\nJVMTI等本地接口注册的回调\n\n\n\n如何判断对象是否死亡\n引用计数法:给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n\n优点: 实现简单\n缺点: 无法解决循环引用问题\n\n\n可达性分析算法(默认使用):通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。\n\n优点: 可以解决循环引用问题\n缺点: 实现复杂\n\n\n\nfinalize() 不推荐使用\n当对象被回收时，系统会自动调用该对象的finalize()方法，程序员可以覆盖该方法，在该方法中进行资源释放，例如关闭文件、套接字等。但是，finalize()方法并不推荐使用，因为它的执行时间是不确定的，并且它可能会导致对象复活。\n你可以在finalize中执行逻辑让被其他对象引用，从而让对象复活。\n一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。\n\n常见引用类型强引用：普通的变量引用 public static User user = new User();软引用：将对象用 SoftReference 软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。软引用可用来实现内存敏感的高速缓存。 public static SoftReference&lt;User&gt; user = new SoftReference&lt;User&gt;(new User());弱引用: 将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用\n详细解析\n当对象无法在栈上分配且无法通过TLAB分配时，会在堆上进行分配。堆的空间并不是无限的，并且实际运行中，很多对象都是用完即弃的，所以在堆上分配对象时，会使用垃圾回收机制来回收不再使用的对象，从而释放内存空间。\n堆内存布局堆默认分为两个区域：\n\n新生代 默认占比 1&#x2F;3， 新生代又分为Eden区和Survivor区\nEden区 默认占比 8&#x2F;10\nSurvivor0区 默认占比 1&#x2F;10\nSurvivor1区 默认占比 1&#x2F;10\n\n\n老年代 默认占比 2&#x2F;3\n\n垃圾回收机制新对象默认分配在Eden区，当Eden区满时，会触发Minor GC，Minor GC会将Eden区和Survivor0区中的存活对象复制到Survivor1区中，然后清空Eden区和Survivor0区，下次Minor GC时，会将Eden区和Survivor1区中的存活对象复制到Survivor0区中，以此类推。当Survivor区中的对象复制到另一个Survivor区中时，会将对象头中的分代年龄+1，如果对象的年龄超过了15岁，会将对象复制到老年代中。\n分配策略\n对象在分配时使用CAS算法来分配内存\n\n大对象直接进入老年代，它需要大量连续内存空间的对象（比如：字符串、数组），当Eden区放不下这个对象时，会直接分配到老年代中，可以通过-XX:PretenureSizeThreshold参数来设置大对象的阈值, 默认为0，即不启用。\n\n长期存活的对象将进入老年代 分代年龄达到15岁的对象会进入老年代，可以通过-XX:MaxTenuringThreshold参数来设置分代年龄的阈值，默认为15，最大值15，最小值1。\n\n对象动态年龄判断: 当某年龄的所有对象大小总和 &gt; Survivor区空间的50%时, JVM会将该年龄及以上的对象直接晋升到老年代, 无需等到15岁。 可通过 -XX:TargetSurvivorRatio 参数来设置动态年龄的阈值, 默认为50，最大值99，最小值1。\n\n使得Survivor区能保持足够的空闲空间\n避免频繁进行对象复制操作\n提高GC效率\n\n\n老年代空间分配担保机制: 在Minor GC发生前，JVM会检查老年代最大可用连续空间是否大于新生代所有对象总大小，如果大于，则Minor GC可以确保安全, 执行Minor GC；如果小于，则会检查-XX:HandlePromotionFailure参数是否设置为true，如果是，则会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于，则会进行一次Full GC。可通过-XX:HandlePromotionFailure=true配置，JDK6之后默认开启。\n\n避免在Minor GC之前进行一次Full GC\n在内存紧张时提供弹性空间\n提高GC效率\n\n\n\n如何判断对象是否死亡引用计数法给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n\n优点: 实现简单\n缺点: 无法解决循环引用问题\n\n可达性分析算法(默认使用)通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。\n\n优点: 可以解决循环引用问题\n缺点: 实现复杂\n\n\n\nGC Roots\n线程栈中的引用对象 ：\n当前执行方法中的局部变量和参数\n每个线程栈帧中引用的对象\n\n\n方法区中的静态属性引用 ：\n类的静态变量(static修饰)\n例如： public static Object obj &#x3D; new Object();\n\n\n方法区中的常量引用 ：\n字符串常量池中的引用\nfinal修饰的常量引用的对象\n\n\n本地方法栈中的JNI引用 ：\nNative方法引用的对象\nJNI调用的本地代码创建的对象\n\n\n活跃线程的引用 ：\n当前运行线程对象(Thread)\n线程栈中的局部变量引用\n\n\n同步锁持有的对象 ：\n被 synchronized 锁持有的对象\n同步代码块&#x2F;方法使用的锁对象\n\n\nJVM内部系统对象 ：\n系统类加载器加载的类对象\n基本数据类型对应的Class对象\n\n\n管理接口相关引用 ：\nJMXBean等管理接口引用的对象\nJVMTI等本地接口注册的回调\n\n\n\n常见引用类型java的引用类型一般分为四种：强引用、软引用、弱引用、虚引用\n强引用：普通的变量引用\n\npublic static User user = new User();\n\n软引用：将对象用 SoftReference 软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。软引用可用来实现内存敏感的高速缓存。\n\npublic static SoftReference&lt;User&gt; user = new SoftReference&lt;User&gt;(new User());\n软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。\n如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建\n如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出\n\n\n\n弱引用: 将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用\n\npublic static WeakReference&lt;User&gt; user = new WeakReference&lt;User&gt;(new User());\n\n虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用\nfinalize()方法最终判定对象是否存活即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。\n标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。\n\n第一次标记并进行一次筛选。\n筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize方法，对象将直接被回收。\n\n第二次标记\n如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。\n示例代码：\n1234567891011121314151617181920public class OOMTest &#123;    public static void main(String[] args) &#123;      List&lt;Object&gt; list = new ArrayList&lt;&gt;();      int i = 0;      int j = 0;      while (true) &#123;         list.add(new User(i++, UUID.randomUUID().toString()));         new User(j--, UUID.randomUUID().toString());      &#125;   &#125;&#125;  //User类需要重写finalize方法@Overrideprotected void finalize() throws Throwable &#123;    OOMTest.list.add(this);    System.out.println(&quot;关闭资源，userid=&quot; + id + &quot;即将被回收&quot;);&#125;\n\nfinalize()方法的运行代价高昂， 不确定性大， 无法保证各个对象的调用顺序， 如今已被官方明确声明为不推荐使用的语法。 有些资料描述它适合做“关闭外部资源”之类的清理性工作， 这完全是对finalize()方法用途的一种自我安慰。 finalize()能做的所有工作， 使用try-finally或者其他方式都可以做得更好、更及时， 所以建议大家完全可以忘掉Java语言里面的这个方法。\n\n\nFull GC 的回收目标\n**新生代(Young Generation)**：\n\n包括Eden区和两个Survivor区\n文档中提到：”堆默认分为两个区域：新生代(默认占比1&#x2F;3)…老年代(默认占比2&#x2F;3)”\n\n\n**老年代(Old Generation)**：\n\n存放长期存活的对象\n文档说明：”长期存活的对象将进入老年代”\n\n\n**元空间(Metaspace)**：\n\n替代永久代(PermGen)的内存区域\n文档明确指出：”当元空间使用量达到MaxMetaspaceSize阈值时，会触发Full GC进行垃圾回收”\n\n\n方法区：\n\n存储类信息、常量、静态变量等\n文档中提到方法区回收无用类的条件\n\n\n其他系统区域：\n\n包括JVM内部数据结构\n系统类加载器加载的类对象等\n\n\n\nFull GC是全局性垃圾回收，会扫描JVM管理的所有内存区域，而Minor GC只处理新生代区域。\nFull GC的触发条件\n老年代空间不足：当老年代空间不足以存放从年轻代晋升的对象时，会触发Full GC。\n\n永久代&#x2F;元空间不足（取决于JVM版本）：\n\nJava 8之前：永久代(PermGen)空间不足\nJava 8及之后：元空间(Metaspace)空间不足\n\n\nSystem.gc()调用：当代码中显式调用System.gc()时，可能会触发Full GC（取决于JVM参数-XX:+DisableExplicitGC的设置）。\n\nCMS GC失败：在使用CMS收集器时，如果并发模式失败（Concurrent Mode Failure），会触发Full GC。\n\n晋升失败：当年轻代对象需要晋升到老年代，但老年代没有足够空间时。\n\n分配担保失败：在Minor GC之前，如果老年代最大可用连续空间小于历次晋升到老年代对象的平均大小，会触发Full GC。\n\n堆内存分配失败：当JVM无法为新对象分配内存时。\n\n手动触发：通过JVM工具（如jcmd、jconsole）手动触发Full GC。\n\n\n如何判断一个类是无用的类当元空间使用量达到MaxMetaspaceSize阈值时，会触发Full GC进行垃圾回收。方法区主要回收的是无用的类，需满足下面的条件：\n\n该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n\n加载该类的 ClassLoader 已经被回收。\n\n该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n\n","slug":"Java-高级-Day-3-GC垃圾回收","date":"2025-04-24T01:33:20.000Z","categories_index":"","tags_index":"Java-Day,Java-高级-Day","author_index":"Weiba"},{"id":"8f3910e39f3a3511dc34dd9ac8d25e0b","title":"Java-高级-Day-2-JVM 内存分配","content":"核心点图示：颜色相同的都为一个类型\n\n\n线程\n程序计数器：记录当前线程正在执行的字节码指令的地址，是每个线程私有的，它的大小是4 个字节，固定的，不会随着操作系统的位数而改变，它的作用就是当重新获得cpu时间片时根据记录的字节码指令地址继续执行。\n线程栈：用来存放方法执行时的数据的，遵循先入后出的原则。\n本地方法栈：和栈一样，它是用来存放本地方法的执行时数据，遵循先入后出的原则，本地方法指在 Java 中调用非 Java 语言的方法，比如 C 语言，C++ 语言，C# 语言，Python 语言，Ruby 语言，JavaScript 语言，等等\n\n栈帧每个方法创建时都会创建一个对应的栈帧，\n\n局部变量表：它是一个数组，用来存放方法的参数和局部变量，局部变量表的大小是固定的，不会随着操作系统的位数而改变\n操作数栈：主要用于存储方法中字节码执行过程中的操作数和中间计算结果。\n动态链接：在字节码执行过程中，通过动态链接找到方法的地址，从而调用方法。\n方法出口：在方法字节码全部执行完毕后，通过方法出口找到方法的返回地址，从而返回方法的返回值。\n\n堆\n堆是用来存放对象的，它是线程共享的。\n堆分为年轻代和老年代\nCAS 分配\n堆内存划分：年轻代和老年代\n年轻代，三个区，默认比例 8:1:1，默认会自动调节\n伊甸区Eden：用来存放新创建的对象，eden区满了后会触发minor gc，回收eden和survivor区(非空)，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块 survivor 区。\n幸存者0区survivor0：用来存放伊甸区中经过垃圾回收后存活的对象。\n幸存者1区survivor1：用来存放伊甸区中经过垃圾回收后存活的对象。\n\n\n老年代：对象每minor gc移动一次对象分代年龄加1，当对象的分代年龄达到某个值（默认为15）时，就会晋升到老年代中，当老年代满了后会触发full gc，进行一次全局的垃圾回收。\n\n\n\n方法区\n常量，静态变量，类元信息，它是线程共享的。\n\n对象的内存分配\nTLAB 本地线程分配缓冲（Thread Local Allocation Buffer）, 为解决多线程分配内存时的资源竞争问题，在线程创建时就提前将堆中(Eden区)的一小块内存空间预留给这个线程，默认开启。\nCAS 一种无锁算法，包含三个操作数：内存位置(V)、预期原值(A)和新值(B)，只有当V的值等于A时，才会将V的值更新为B，优点：非阻塞算法，提高并发性能，避免线程切换开销。缺点：ABA问题(可通过版本号解决)，循环时间长时CPU开销大，只能保证一个共享变量的原子操作。\n\n\n分配原则\nJVM会先尝试栈上分配\n不满足条件则使用TLAB分配, TLAB(在线程创建时预先在Eden区分配一块内存, 解决并发时内存分配问题)\n都失败则使用CAS在堆分配\n\n\n栈上分配条件\njava8默认开启逃逸分析，默认开启标量替换\n对象不会逃逸出方法作用域，不会作为参数或返回值传递给其他方法（方法局部对象）\n对象不会被其他线程访问（线程封闭）\n对象大小不超过栈帧可用空间，大对象仍会分配到堆中\n\n\n标量替换\n标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。\n标量与聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。\n\n\n对象头\n32位对象头\n64位对象头\n分代年龄4字节，最大数15.\n指针压缩：在64位平台的HotSpot中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力\n对其填充：确保对象大小为8字节的整数倍，优化CPU缓存行访问，防止跨缓存行访问导致缓存行失效，提高CPU性能。\n\n\n\n详细解析Java 内存分布我们通过一个例子来完成讲解对象创建的整个生命周期，对Java 内存分布有一个大致的认识。\n1234567891011121314151617181920212223public class Math &#123;    public static void main(String[] args) &#123;        // 1. 加载 Person.class 文件到内存        // 2. 调用 Person 类的构造方法，创建 Person 对象        Person p = new Person();        // 3. 给 p 对象中的 name 成员变量赋值        p.name = &quot;张三&quot;;        // 4. 给 p 对象中的 age 成员变量赋值        p.age = 18;        // 5. 调用 p 对象中的 eat 方法        p.eat();    &#125;&#125;class Person &#123;    String name;    int age;    public void eat() &#123;        Integer foodCount = 1;        String food = &quot;面条&quot;;        System.out.println(&quot;吃&quot; + foodCount + &quot;碗&quot; + food);    &#125;&#125;\n1.初始化main线程JVM 虚拟机启动后，通过类转载子系统创建JVM主线程，并完成线程初始化，包括：\n程序计数器\n它是一个指针，指向当前线程正在执行的字节码指令的地址，是每个线程私有的\n它的作用就是记录当前程序执行的字节码指令的地址，当前CPU时间片用完后，就会切换到其他线程执行，当 CPU时间片 继续分配回来的时候，通过程序计数器，告诉 JVM 当前线程正在执行的字节码指令的地址，从而继续执行。\n它的大小是4 个字节，固定的，不会随着操作系统的位数而改变\n\n线程栈(虚拟机栈)也叫方法栈，它是用来存放方法执行时的数据的，\n\n每个方法创建时都会创建一个对应的栈帧，并将栈帧压入栈中，遵循先入后出的原则。\n\n栈帧类似方法运行时的环境，栈帧中包含：\n\n局部变量表：它是一个数组，用来存放方法的参数和局部变量，局部变量表的大小是固定的，不会随着操作系统的位数而改变\n操作数栈：主要用于存储方法中字节码执行过程中的操作数和中间计算结果。\n动态链接：在字节码执行过程中，通过动态链接找到方法的地址，从而调用方法。\n方法出口：在方法字节码全部执行完毕后，通过方法出口找到方法的返回地址，从而返回方法的返回值。\n\n\n\n本地方法栈：和线程栈一样，每个线程都有一个本地方法栈，用来存放本地方法的执行时数据，遵循先入后出的原则，本地方法指在 Java 中调用非 Java 语言的方法，比如 C 语言，C++ 语言，C# 语言，Python 语言，Ruby 语言，JavaScript 语言，等等\n2.主线程执行，并执行 main 方法根据 META-INF 目录下的 MANIFEST.MF 文件或手动指定主类，找到需要执行的主类包名称，通过类加载器将类加载到内存中，main 方法 是程序的入口，它是一个静态方法，它的执行是由 JVM 虚拟机完成的，\n1. 创建栈帧main 方法 执行时，会在 main线程中，创建栈帧, 并将栈帧压入main线程栈中.\n2. 执行过程中，创建对象当字节码执行到 Person p = new Person() 时，会加载 Person.class 文件，创建 Person 对象，并为 Person 对象分配内存\n\n\n\n类加载检查：虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n\nnew指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。\n\n\n分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。\n\n分配内存有几个问题：\n\n如何划分内存?\n“指针碰撞”（Bump the Pointer）(默认)：如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。\n“空闲列表”（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录\n\n\n在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况？\nCAS（compare and swap）虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。\nTLAB 本地线程分配缓冲（Thread Local Allocation Buffer）, 在线程创建时就提前将堆中(Eden区)的一小块内存空间预留给这个线程，通过 -XX:+/-UseTLAB 参数来设定虚拟机是否使用TLAB(JVM会默认开启 -XX:+UseTLAB)，-XX:TLABSize 指定TLAB大小。\n\n\n\n\n对象分配到哪里：\n\n\n分配原则\nJVM会先尝试栈上分配\n不满足条件则使用TLAB分配\n都失败则使用普通的堆分配\n\n\n对象栈上分配：我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过逃逸分析确定该对象不会被外部访问。如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。\n对象逃逸分析：分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数或返回值传递到其他方法中，称作对象逃逸。\n标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。\n标量与聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。\n栈上分配条件\n对象不会逃逸出方法作用域（方法局部对象）\n对象不会被其他线程访问（线程封闭）\n对象大小不超过栈帧可用空间，大对象仍会分配到堆中。\n\n\n\n\nTLAB 在线程创建时预先在Eden区分配一块内存, 解决并发时内存分配问题\n堆 \nCAS 分配\n堆内存划分：年轻代和老年代\n年轻代，三个区，默认比例 8:1:1，默认会自动调节\n伊甸区Eden：用来存放新创建的对象，eden区满了后会触发minor gc，回收eden和survivor区(非空)，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块 survivor 区。\n幸存者0区survivor0：用来存放伊甸区中经过垃圾回收后存活的对象。\n幸存者1区survivor1：用来存放伊甸区中经过垃圾回收后存活的对象。\n\n\n老年代：对象每minor gc移动一次对象分代年龄加1，当对象的分代年龄达到某个值（默认为15）时，就会晋升到老年代中，当老年代满了后会触发full gc，进行一次全局的垃圾回收。\n\n\n\n\n\n\n\n\n初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n\n设置对象头：初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\n\n\n32位对象头\n\n\n64位对象头\n\n\n指针压缩\n\n在64位平台的HotSpot中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力\n为了减少64位平台下内存的消耗，启用指针压缩功能\n在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的存入堆内存时压缩编码、取出到cpu寄存器后解码方式进行优化(对象指针在堆中是32位，在寄存器中是35位，2的35次方&#x3D;32G)，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)\n堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间\n堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好\n\n\n对齐填充\n\n作用：确保对象大小为8字节的整数倍\n原因：\n优化CPU缓存行访问（通常64字节），对齐可以避免”伪共享”问题\n满足硬件对齐要求\n提升原子操作性能\n\n\n示例：一个对象实际需要30字节，JVM会添加2字节填充，使其变为32字节\n\n\n\n\n执行方法：执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。\n\n","slug":"Java-高级-Day-2-JVM内存分配","date":"2025-04-23T03:13:38.000Z","categories_index":"","tags_index":"Java-Day,Java-高级-Day","author_index":"Weiba"},{"id":"13d951f30d32eed0580b85046fce3923","title":"Java-高级-Day-1-Java类加载机制","content":"核心点类加载器\n引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar 、charsets.jar 等\n\n扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的 ext 扩展目录中的JAR类包\n\n应用程序类加载器：负责加载 ClassPath 路径下的类包，主要就是加载你自己写的那些类\n\n自定义加载器：负责加载用户自定义路径下的类包\n\n\n类加载机制\n双亲委派机制：先找父类的类加载器加载，找不到再有自己加载。\n沙箱安全机制，自己写的 java.lang.String.class 类不会被加载，这样便可以防止核心API库被随意篡改。\n避免类的重复加载：当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次，保证被加载类的唯一性。\n\n\n全盘负责委托机制：当一个 ClassLoder 装载一个类时，除非显示的使用另外一个 ClassLoder ，该类所依赖及引用的类也由这个 ClassLoder 载入。\n自定义类加载器：只需要继承 java.lang.ClassLoader 类，该类有两个方法：\nloadClass(String, boolean) 默认实现了双亲委派，打破双亲委派就需要重写它。\nfindClass(String name) 默认空，可自定义它来实现网络加载或其他方式加载类。\n\n\n\nTomcat 类加载\n打破双亲委派机制，实现不同web容器的类库资源隔离。\ntomcat的几个主要类加载器：\ncommonLoader: Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问。\ncatalinaLoader: Tomcat容器私有的类加载器，加载路径中的class对于 Webapp 不可见。\nsharedLoader: 各个 Webapp 共享的类加载器，加载路径中的class对于所有 Webapp 可见，但是对于Tomcat容器不可见。\nWebappClassLoader: 各个 Webapp私有的类加载器，加载路径中的class只对当前 Webapp 可见，比如加载war包里相关的类，每个war包应用都有自己的 WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本，这样实现就能加载各自的spring版本。\nTomcat 7 以后合并了 commonLoader catalinaLoader sharedLoader 这三个类加载器，实际这三个类加载器都是同一个实例。\n\n\nJSP 加载原理：后台启动线程监听 JSP文件 变化，如果变化了找到该 JSP文件 对应的 servlet类的加载器引用(gcroot)，重新生成新的 JasperLoader 加载器赋值给引用，然后加载新的JSP文件对应的servlet类，之前的那个加载器因为没有 gcroot 引用了，下一次 gc 的时候会被销毁。\n\n类加载核心\n加载：在调用类的方法，new对象时，通过类加载器，在磁盘或其他方式读取 class 字节码内容，并在内存中生成一个这个类对应的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。\n验证：校验字节码文件的正确性。\n准备：给类的静态变量分配内存，并赋予默认值，注意是对应类型的默认值，如 boolean 默认 false, 数值类型为 0, char 为空字符 \\u0000，不是代码中硬编码的值。\n解析：分为静态链接和动态链接两个部分，加载时只执行静态链接。\n静态链接，将符号引用如 main() 方法，替换为指向数据所存内存的指针或句柄等(直接引用)，将符号引用替换为直接引用, 这个转换过程称为静态链接，在类加载期间完成。\n符号引用：一种与虚拟机内存布局无关的引用形式，可以是任何形式的字面量，只要能无歧义地定位到目标即可，在编译阶段生成，保存在class文件的常量池中。具体来说，符号引用可以包括\n类和接口的全限定名（Fully Qualified Name）\n字段的名称和描述符\n方法的名称和描述符\n\n\n直接引用具体包括：\n直接指向目标的指针\n相对偏移量\n能间接定位到目标的句柄\n\n\n\n\n动态链接，它在运行时解析，核心特点：\n运行时解析 ：在程序运行期间（而非类加载期间）将符号引用替换为直接引用\n支持多态 ：是实现Java多态特性的基础机制\n延迟绑定 ：方法调用的具体实现直到运行时才确定\n动态链接的具体表现：\n虚方法调用 ：当调用一个可能被子类重写的方法时，JVM会在运行时确定实际要调用的方法实现\n接口方法调用 ：接口方法的实现也是在运行时动态确定的\n反射调用 ：通过反射API调用的方法都是动态解析的\n\n\n动态链接的实现原理：\n每个类的方法区中维护一个 虚方法表（vtable）\n虚方法调用时，JVM会：\n查找对象的实际类型\n通过虚方法表找到正确的方法实现\n将符号引用替换为直接引用\n\n\n\n\n动态链接的优势：\n支持面向对象的多态特性\n提高代码的扩展性和灵活性\n允许热替换等高级特性\n\n\n动态链接的代价:\n比静态链接有更高的运行时开销\n需要维护额外的元数据（如虚方法表）\n可能影响JIT优化的效果\n\n\n\n\n\n\n初始化：对类的静态变量初始化为硬编码的值，执行静态代码块。\n\n类被加载到方法区中后主要包含\n运行时常量池\n类型信息\n字段信息\n方法信息\n类加载器的引用：这个类到类加载器实例的引用\n对应class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的 java.lang.Class 类型的对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。\n\n详细解析类加载运行全过程当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到JVM。\n通过Java命令执行代码的大体流程如下：\n\n\n其中loadClass的类加载过程有如下几步：\n加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt; 使用 &gt;&gt; 卸载\n\n加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口\n\n验证：校验字节码文件的正确性\n\n准备：给类的静态变量分配内存，并赋予默认值\n\n解析：将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用\n\n初始化：对类的静态变量初始化为指定的值，执行静态代码块\n\n\n\n\n类被加载到方法区中后主要包含 运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用等信息。\n类加载器的引用：这个类到类加载器实例的引用\n对应class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。\n注意，主类在运行过程中如果使用到其它类，会逐步加载这些类。\njar包或war包里的类不是一次性全部加载的，是使用到时才加载。\n1234567891011121314151617181920212223242526272829303132333435363738public class TestDynamicLoad &#123;     static &#123;        System.out.println(&quot;*************load TestDynamicLoad************&quot;);    &#125;     public static void main(String[] args) &#123;        new A();        System.out.println(&quot;*************load test************&quot;);        B b = null;  //B不会加载，除非这里执行 new B()    &#125;&#125; class A &#123;    static &#123;        System.out.println(&quot;*************load A************&quot;);    &#125;     public A() &#123;        System.out.println(&quot;*************initial A************&quot;);    &#125;&#125; class B &#123;    static &#123;        System.out.println(&quot;*************load B************&quot;);    &#125;     public B() &#123;        System.out.println(&quot;*************initial B************&quot;);    &#125;&#125; 运行结果：*************load TestDynamicLoad*************************load A*************************initial A*************************load test************\n\n类加载器和双亲委派机制上面的类加载过程主要是通过类加载器来实现的，看一个类加载器示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TestJDKClassLoader &#123;     public static void main(String[] args) &#123;        System.out.println(String.class.getClassLoader());        System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());        System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().getName());         System.out.println();        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();        ClassLoader extClassloader = appClassLoader.getParent();        ClassLoader bootstrapLoader = extClassloader.getParent();        System.out.println(&quot;the bootstrapLoader : &quot; + bootstrapLoader);        System.out.println(&quot;the extClassloader : &quot; + extClassloader);        System.out.println(&quot;the appClassLoader : &quot; + appClassLoader);         System.out.println();        System.out.println(&quot;bootstrapLoader加载以下文件：&quot;);        URL[] urls = Launcher.getBootstrapClassPath().getURLs();        for (int i = 0; i &lt; urls.length; i++) &#123;            System.out.println(urls[i]);        &#125;         System.out.println();        System.out.println(&quot;extClassloader加载以下文件：&quot;);        System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));         System.out.println();        System.out.println(&quot;appClassLoader加载以下文件：&quot;);        System.out.println(System.getProperty(&quot;java.class.path&quot;));     &#125;&#125; 运行结果：nullsun.misc.Launcher$ExtClassLoadersun.misc.Launcher$AppClassLoader the bootstrapLoader : nullthe extClassloader : sun.misc.Launcher$ExtClassLoader@3764951dthe appClassLoader : sun.misc.Launcher$AppClassLoader@14dad5dc bootstrapLoader加载以下文件：file:/D:/dev/Java/jdk1.8.0_45/jre/lib/resources.jarfile:/D:/dev/Java/jdk1.8.0_45/jre/lib/rt.jarfile:/D:/dev/Java/jdk1.8.0_45/jre/lib/sunrsasign.jarfile:/D:/dev/Java/jdk1.8.0_45/jre/lib/jsse.jarfile:/D:/dev/Java/jdk1.8.0_45/jre/lib/jce.jarfile:/D:/dev/Java/jdk1.8.0_45/jre/lib/charsets.jarfile:/D:/dev/Java/jdk1.8.0_45/jre/lib/jfr.jarfile:/D:/dev/Java/jdk1.8.0_45/jre/classes extClassloader加载以下文件：D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext;C:\\Windows\\Sun\\Java\\lib\\ext appClassLoader加载以下文件：D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\charsets.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\deploy.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\access-bridge-64.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\cldrdata.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\dnsns.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\jaccess.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\jfxrt.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\localedata.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\nashorn.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\sunec.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\sunjce_provider.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\sunmscapi.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\sunpkcs11.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\ext\\zipfs.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\javaws.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\jce.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\jfr.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\jfxswt.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\jsse.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\management-agent.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\plugin.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\resources.jar;D:\\dev\\Java\\jdk1.8.0_45\\jre\\lib\\rt.jar;D:\\ideaProjects\\project-all\\target\\classes;C:\\Users\\zhuge\\.m2\\repository\\org\\apache\\zookeeper\\zookeeper\\3.4.12\\zookeeper-3.4.12.jar;C:\\Users\\zhuge\\.m2\\repository\\org\\slf4j\\slf4j-api\\1.7.25\\slf4j-api-1.7.25.jar;C:\\Users\\zhuge\\.m2\\repository\\org\\slf4j\\slf4j-log4j12\\1.7.25\\slf4j-log4j12-1.7.25.jar;C:\\Users\\zhuge\\.m2\\repository\\log4j\\log4j\\1.2.17\\log4j-1.2.17.jar;C:\\Users\\zhuge\\.m2\\repository\\jline\\jline\\0.9.94\\jline-0.9.94.jar;C:\\Users\\zhuge\\.m2\\repository\\org\\apache\\yetus\\audience-annotations\\0.5.0\\audience-annotations-0.5.0.jar;C:\\Users\\zhuge\\.m2\\repository\\io\\netty\\netty\\3.10.6.Final\\netty-3.10.6.Final.jar;C:\\Users\\zhuge\\.m2\\repository\\com\\google\\guava\\guava\\22.0\\guava-22.0.jar;C:\\Users\\zhuge\\.m2\\repository\\com\\google\\code\\findbugs\\jsr305\\1.3.9\\jsr305-1.3.9.jar;C:\\Users\\zhuge\\.m2\\repository\\com\\google\\errorprone\\error_prone_annotations\\2.0.18\\error_prone_annotations-2.0.18.jar;C:\\Users\\zhuge\\.m2\\repository\\com\\google\\j2objc\\j2objc-annotations\\1.1\\j2objc-annotations-1.1.jar;C:\\Users\\zhuge\\.m2\\repository\\org\\codehaus\\mojo\\animal-sniffer-annotations\\1.14\\animal-sniffer-annotations-1.14.jar;D:\\dev\\IntelliJ IDEA 2018.3.2\\lib\\idea_rt.jar\n\n类加载器初始化过程参见类运行加载全过程图可知其中会创建JVM启动器实例 sun.misc.Launcher。\n在Launcher构造方法内部，其创建了两个类加载器，分别是 sun.misc.Launcher.ExtClassLoader (扩展类加载器)和 sun.misc.Launcher.AppClassLoader (应用类加载器)。\nJVM默认使用Launcher的 getClassLoader() 方法返回的类加载器 AppClassLoader 的实例加载我们的应用程序。\n1234567891011121314151617181920212223//Launcher的构造方法public Launcher() &#123;    Launcher.ExtClassLoader var1;    try &#123;        //构造扩展类加载器，在构造的过程中将其父加载器设置为null        var1 = Launcher.ExtClassLoader.getExtClassLoader();    &#125; catch (IOException var10) &#123;        throw new InternalError(&quot;Could not create extension class loader&quot;, var10);    &#125;     try &#123;        //构造应用类加载器，在构造的过程中将其父加载器设置为ExtClassLoader，        //Launcher的loader属性值是AppClassLoader，我们一般都是用这个类加载器来加载我们自己写的应用程序        this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);    &#125; catch (IOException var9) &#123;        throw new InternalError(&quot;Could not create application class loader&quot;, var9);    &#125;     Thread.currentThread().setContextClassLoader(this.loader);    String var2 = System.getProperty(&quot;java.security.manager&quot;);    。。。 。。。 //省略一些不需关注代码 &#125;\n\n双亲委派机制\n\n机制逻辑: 先找父类的类加载器加载，找不到再有自己加载\n为什么要有双亲委派?\n\n沙箱安全机制：自定义的 java.lang.String.class 类不会被加载，防止核心类库被修改。\n避免类的重复加载：当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次，保证被加载类的唯一性。\n\n全盘委托机制\n当一个 ClassLoder 装载一个类时，除非显示的使用另外一个 ClassLoder，该类所依赖及引用的类也由这个 ClassLoder载入。\n自定义类加载器示例\n继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是 loadClass(String, boolean)，实现了双亲委派机制，还有一个方法是 findClass，默认实现是空方法，所以我们自定义类加载器主要是 重写findClass方法。\n打破双亲委派机制\n**重写 loadClass(String, boolean) ** 即可\nTomcat 类加载机制\n\n\n打破了双亲委派机制，因为他的不同war包需要在同一个 JVM 中实现隔离。\n同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个。\nJasperLoader 热加载原理： 后台启动线程监听jsp文件变化，如果变化了找到该jsp对应的servlet类的加载器引用(gcroot)，重新生成新的JasperLoader加载器赋值给引用，然后加载新的jsp对应的servlet类，之前的那个加载器因为没有gcroot引用了，下一次gc的时候会被销毁。\n\nHotspot源码JVM启动执行main方法流程","slug":"Java-高级-Day-1-Java类加载机制","date":"2025-04-14T03:14:36.000Z","categories_index":"","tags_index":"Java-Day,Java-高级-Day","author_index":"Weiba"},{"id":"b90ec19b312a987f799746f7eb908d56","title":"RocketMQ找不到Broker节点","content":"RocketMQ找不到Broker节点1234567vim /app/rocketmq/4.9.1/conf/broker.conf# 添加ip信息namesrvAddr = 192.168.186.61:9876brokerIP1 = 192.168.186.61# 启动时脚本指定配置文件nohup /app/rocketmq/4.9.1/bin/mqbroker -c /app/rocketmq/4.9.1/conf/broker.conf &gt; /app/rocketmq/4.9.1/logs/broker.log 2&gt;&amp;1 &amp;\n\n","slug":"RocketMQ找不到Broker节点","date":"2023-05-12T16:32:35.000Z","categories_index":"RocketMQ","tags_index":"RocketMQ","author_index":"Weiba"},{"id":"2e7be242cc84fa54c7118f5a7aeacc49","title":"Redis Cluster 修复","content":"Redis Cluster 修复节点fair，没有可用槽位123456789redis-cli -a xxx -c -h 192.168.186.xx -p xxx# 查看节点状态cluster info# 查看节点信息cluster nodes# 手动添加节点cluster meet 192.168.186.xx xxxx# 修复槽位redis-cli -a xxx --cluster fix 192.168.186.xx:xxxx\n\n","slug":"Redis Cluster修复","date":"2023-05-12T16:32:15.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"Weiba"},{"id":"03b0b502502bb68757a4ab4dec18ea0c","title":"Mysql 8.0 开启外网访问","content":"Mysql 8.0 开启外网访问配置修改1234# vim /etc/mysql/mysql.conf.d/mysqld.cnf# 注释掉这两行#bind-address           = 127.0.0.1#mysqlx-bind-address    = 127.0.0.1\n\n权限设置mysql 8.0 更换了默认认证插件\n12345mysql -urootUSE mysql;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;passw&#x27;;grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;flush privileges;\n\n参数优化123456vim /etc/mysql/mysql.conf.d/mysqld.cnf# 总内存的50%到75%innodb_buffer_pool_size = 4G# 1G 1个innodb_buffer_pool_instances = 4\n\n","slug":"Mysql8.0开启外网访问","date":"2023-01-01T02:27:17.000Z","categories_index":"Mysql","tags_index":"配置,Mysql","author_index":"Weiba"},{"id":"347757ce9e70573368e0803b807e225c","title":"JVM-垃圾收集算法解析","content":"垃圾收集算法\n\n分代收集理论当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是通过对象存活周期的不同将内存分为几块。一般将JAVA堆分为新生代和老年代 ，这样我们就可以根据各个年代的特点选择合适的垃圾手机算法。\n比如在新生代，每次手机都会有99%的对象死去，所有我们可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存货几率是比较高的，而且没有额外的空间对它进行担保，所以我们必须选择标记-清除算法或者标记-整理算法进行垃圾收集。\n注意：标记-清除算法 或 标记-整理算法 会比 复制算法 慢10倍以上！\n复制算法为了解决效率问题，复制收集算法出现了。它会将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完毕后，就将还存活的对象复制到另一块中，然后再把使用的空间一次性清理掉。这样就是每次的内存回收都是堆内存区域的一般进行回收。\n\n\n标记-清除算法算法分为标记和清除阶段，一般分为两种模式：\n\n标记所有存活的对象，统一回收所有未标记的对象（一般选择这种）。\n标记所有需要回收的对象，统一回收所有标记的对象。\n\n它是最基础的收集算法，但会带来两个问题：\n\n效率不高，可能出现需要标记的对象过多。\n空间问题，清理后出现大量的内存碎片。\n\n\n\n标记-整理算法根据老年代的特点设计出的一种标记算法，标记过程与标记-清楚算法一样，但后续不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界外的内存。\n\n\n垃圾收集器各GC收集器应用范围及搭配使用图，颜色相同的表示推荐组合。\n\n\n如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器是就是内存回收的具体实现。\n虽然我们对各个收集器进行比较，但并非为了选择出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据不同的场景选择合适的垃圾收集器。\nSerial收集器（年轻代，串行）开启方法：-XX:+UseSerialGC -XX:+UseSerialOldGC\nSerial收集器是最基本、历史最悠久的垃圾收集器。它是一个单线程收集器，它的单线程不仅仅意味着使用一个线程进行垃圾回收，更重要的是他在进行垃圾回收时必须暂停其他所有的工作线程（Stop The World），直到它收集结束。\n\n新生代使用复制算法。\n老年代使用标记-整理算法。\n\n\n\n优点：与其它手机的单线程相比它简单高效，因为它没有线程交互的开销，自然可以获得很高的垃圾收集效率。\nSerial Old 收集器（老年代，串行）Serial Old是Serial的老年代版本，它主要有两大用途:\n\n在JDK1.5及以前的版本中与Parallel Scavenge收集器搭配使用。\n作为CMS收集器的备选方案。\n\nParallel Scavenge（年轻代，并行，JDK8默认）Parallel和ParallelOld是JDK8默认的垃圾收集器。\n开启方法：-XX:+UseParallelGC, -XX:+UseParallelOldGC\nParallel是Serial的多线程版本，除了使用多线程进行垃圾回收外，其余行为（控制参数、收集算法、回收策略）和Serial类似。\n默认的线程数和CPU核数相同，也可以用参数：-XX:ParallelGCThreads=N指定收集线程数，但一般不推荐修改。\nParallel收集器关注的重点是吞吐量，高效的使用CPU，CMS等垃圾收集器关注点更多的是工作线程的停顿时间。\n","slug":"JVM-垃圾收集算法解析","date":"2022-12-30T02:27:17.000Z","categories_index":"GC","tags_index":"JVM,GC,CMS,ParNew,三色标记,内存屏障","author_index":"Weiba"},{"id":"696f58cc973f75c60837976660da7ceb","title":"JVM类加载机制","content":"类加载全过程当我们使用Java命令启动一个类的main()方法时，首先需要通过类加载器将主类加载到JVM中。\n12345678910111213141516171819package com.weiba.jvm;public class Math &#123;    public static final int initData = 666;    public static User user = new User();    public int compute() &#123;  //一个方法对应一块栈帧内存区域        int a = 1;        int b = 2;        int c = (a + b) * 10;        return c;    &#125;    public static void main(String[] args) &#123;        Math math = new Math();        math.compute();    &#125;&#125;\n\n通过Java命令执行代码的大体流程\n\nloadClass 加载过程加载在硬盘上查找并通过IO读取字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等。在加载阶段会在宿主机内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。\n验证效验字节码文件的的正确性，如class文件内容依次应该为：CAFEBABE(魔数)，副版本号，主版本号，常量池计数器，常量池区域，类信息等等。\n\n\nClass文件结构参照表\n\n准备给类的静态变量分配内存，并赋予默认值。\n静态变量：基础类型如int为0，boolean为false，对象为null。\n静态常量：用字面量进行显示赋值，字面量（保存在常量池中） 可以认为是有确定值的基本数据类型，还有具有确定值的string。\n解析将符号引用（静态方法如main()）替换为直接引用（内存地址），该阶段会把一些静态方法替换为指向数据所存内存的指针或句柄。这就是所谓的静态链接（类加载期间完成）过程，动态链接是程序在运行期间将符号引用替换为直接引用。\n初始化\n对类的静态变量初始化为指定的值。\n执行静态代码块。\n\n\n\n方法区类被加载至方法区后主要包含：运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应Class实例的引用等信息。\n类加载器的引用这个类加载时使用的类加载器。\n对应Class实例的引用类加载器在加载类信息放到方法区后，会创建一个对应的Class类型的对象实例放到堆中，作为开发人员访问方法区中类定义的入口和切入点。\n类加载器注意：同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个。\n引导类加载器（BootStrapClassLoader）负责加载JRE下lib目录的核心类库。\n扩展类加载器器（ExtClassLoader）负责加载JRE下lib目录中ext扩展文件夹中的类库。\n应用类加载器（APPClassLoader）负责加载classPath路径下的类库，主要是加载我们直接写的和导入的依赖包。\n自定义类加载器自己定义的类加载器，自己管理，如Tomcat打破双亲委派的自定义类加载器，实现各个路径下的class隔离。\n自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是loadClass(String, boolean)，实现了双亲委派机制，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是重写findClass方法。\n全盘负责委托机制全盘负责委托机制是指当一个ClassLoader装载一个类时，除非显式的使用另一个ClassLoader，该类所有依赖的及引用的类都使用这个ClassLoader载入。\n双亲委派机制原理\n\n一个类在加载时，会先找这个类加载器的父类，看是否为空，不为空继续它类加载器的父类，直到没有父类。在找到后会先判断有没有加载过这个，找到直接返回，没有找到返回子类加载器查找，直到返回到自己的类加载器，开始真正的加载。\n为什么要设计双亲委派机制？\n沙箱安全机制：自定义的java.lang.String.class类不会被加载，这样可以防止核心类库被篡改。\n防止类的重复加载：当父类已经加载了该类，子类就没有必要再加载一次了，保证被加载类的唯一性。\n\nJVM级别类加载全过程","slug":"JVM类加载机制","date":"2022-12-29T05:17:00.000Z","categories_index":"JVM","tags_index":"原理","author_index":"Weiba"},{"id":"b6c44ddff928c2bc54e5fe634d621a85","title":"注册中心服务真实IP获取脚本","content":"由于部分同事在测试环境启服务时常常不改服务名称且ip直接配置成localhost，导致很多服务调用时会连接异常，但又找不到人，为此我写了一个脚本来定位服务的真实ip。\n123456789101112131415161718192021222324252627282930#!/bin/bash# export PATH=$PATH:/bin:/sbin:/usr/sbinif [ ! -n &quot;$1&quot; -o ! -n &quot;$2&quot; ]; then    echo &quot;请在脚本后输入参数：注册中心端口号 目标服务端口号&quot;    exit 1fiPID=$(netstat -tunlp | grep $1 | grep java | awk &#x27;&#123;print $7&#125;&#x27; | awk -F &#x27;/&#x27; &#x27;&#123;print $1&#125;&#x27;)echo &quot;端口$1所属进程PID为：$&#123;PID&#125;&quot;ips=$(lsof -p $&#123;PID&#125;  -nP | grep TCP | awk &#x27;&#123;print $9&#125;&#x27; | awk -F &#x27;-&gt;&#x27; &#x27;&#123;print $2&#125;&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; | grep -v &#x27;^$&#x27; | sort | uniq)for i in $&#123;ips&#125;; do nc -z -w 2 $&#123;i&#125; $2 &gt;&gt; /dev/null 2&gt;&amp;1 result=$? if [ $&#123;result&#125; != 0 ]; then        echo -e &quot;$&#123;i&#125;:$2 \\t 端口关闭&quot; else           swagger=&quot;http://$&#123;i&#125;:$2/swagger-ui.html&quot;        cr=$(curl -I -m 10 -o /dev/null -s -w %&#123;http_code&#125; $&#123;swagger&#125;)        if [ $&#123;cr&#125; != 200 ]; then           desUrl=&quot;manager - http://$&#123;i&#125;:$2/&quot;        else            desUrl=&quot;microservice - $&#123;swagger&#125;&quot;        fi        echo -e &quot;$&#123;i&#125;:$2 \\t 端口开放 &lt;-- $&#123;desUrl&#125;&quot; fidone\n\n","slug":"注册中心服务真实IP获取脚本","date":"2022-12-26T05:58:09.000Z","categories_index":"Shell","tags_index":"Shell","author_index":"Weiba"},{"id":"0cc92406a47f2ec432fad59606c76747","title":"Docker-创建Hexo环境","content":"\n\n\n\n\n\n\n\n\nGitHub 访问速度不佳, 在Nas上部署一套Hexo\n编写DockerFile本来是打算看看有没有合适的镜像的, 不是太大, 就是配置太麻烦, 干脆自己自定义一个算了\n12345678910111213141516171819202122FROM node:16.0.0-alpine# 设置代理, 后边装依赖要用ENV http_proxy http://192.168.186.210:7890ENV https_proxy http://192.168.186.210:7890WORKDIR /usr/local# alpine中什么都没有, 需要单独安装RUN apk update &amp;&amp; apk add bash &amp;&amp; apk add gitSHELL [&quot;/bin/bash&quot;, &quot;-o&quot;, &quot;pipefail&quot;, &quot;-c&quot;]RUN unset http_proxy &amp;&amp; unset https_proxy# hexo端口EXPOSE 4000# 这个脚本后面可以自己替换COPY start.sh /usr/local/start.shRUN chmod +x /usr/local/start.shCMD [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;./start.sh&quot;]\n\nstart.sh\n123456#!/bin/bashif [ ! -d &quot;/usr/local/xweiba.github.io&quot; ]; then  git clone -b source https://github.com/xweiba/xweiba.github.io.git&amp;&amp;npm config set registry https://registry.npmmirror.com&amp;&amp;npm install hexo-cli -gficd /usr/local/xweiba.github.iogit pull --force&amp;&amp;npm install&amp;&amp;hexo clean&amp;&amp;hexo s\n\n构建镜像并启动构建镜像:\n1docker build -t wb-hexo:v1 .\n\n\n\n启动, 第一次会比较慢, 后面就好了\n12docker run -itd --name hexo -p 4000:4000 --restart always wb-hexo:v1docker container logs -f hexo\n添加Nginx配置1234567891011121314151617181920server &#123;  server_name blog.weiba.ml;  listen 32880 ssl http2;  ssl_certificate /root/.acme.sh/weiba.ml/weiba.ml.pem;  ssl_certificate_key /root/.acme.sh/weiba.ml/weiba.ml.key;  ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;  error_page 497 = https://$host:32880$request_uri;  location / &#123;    proxy_pass http://192.168.1.1:4000;    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Host $http_host;    proxy_set_header X-Forwarded-Port $server_port;    proxy_set_header X-Forwarded-Proto $scheme;    proxy_http_version 1.1;    proxy_set_header Upgrade $http_upgrade;    proxy_set_header Connection &quot;upgrade&quot;;  &#125;&#125;\n\n定时拉取更新alpine 镜像的 cron 功能应该是废的, 直接在宿主机上执行, 半小时执行一次.\n12# crontab -e*/30 * * * * docker exec -it hexo bash -c &quot;cd /usr/local/xweiba.github.io&amp;&amp;git pull --force&quot;\n","slug":"Docker-创建Hexo环境","date":"2022-12-23T15:14:30.000Z","categories_index":"Docker","tags_index":"Docker,Hexo,nodejs","author_index":"Weiba"},{"id":"c50e1df99d9d47827851c22dac23fe21","title":"Puppeteer 配置记录","content":"Puppeteer项目配置注意事项：\n\nCentOS 7 以下不支持 Puppeteer\nPuppeteer 服务需能够访问被打印的页面\n请先确保字体安装成功，否则会导致PDF渲染异常\n\n字体安装安装 fontconfig mkfontscale ：\n1yum -y install fontconfig mkfontscale\n\n将源码目录fonts文件夹下字体文件夹复制至服务器的 /usr/share/fonts 目录下, 然后执行以下命令重建字体缓存，并查看字体是否已安装，出现 /usr/share/fonts/puppeteer 目录即为正常。\n1234mkfontscalemkfontdirfc-cachefc-list :lang=zh\n\n依赖安装安装 chrome puppeteer 所需依赖：\n1yum -y install atk at-spi2-atk libxkbcommon-x11-devel libXcomposite gtk3 alsa-lib-devel\n\n部署源码文件1234# 上传源码unzip puppeteer-microservice.zipnpm install npm run start # 启动测试\nWindows 与 Linux 渲染结果不一致Github issues: 2410\n\n请确认渲染字体一致。\n请确认Puppeteer服务端配置中包含以下配置：  12345678puppeteer args:&#x27;--disable-font-subpixel-positioning&#x27;, // 必须添加，解决空格问题&#x27;--font-render-hinting=none&#x27; // 可选添加，当前业务加不加效果都一样css: // 可选添加，当前业务加不加效果都一样* &#123;      text-rendering: geometricprecision !important;  &#125;\n\n配置文件说明：args 参数说明文档\n1234567891011121314151617181920212223242526272829303132333435module.exports = &#123;    port: 9572,    puppeteer: &#123;        headless: true, // 是否启用无头模式页面        //executablePath: &#x27;/usr/lib64/chromium-browser/headless_shell&#x27;,        args: [            &#x27;–-disable-gpu&#x27;,            &#x27;-–disable-dev-shm-usage&#x27;,            &#x27;-–disable-setuid-sandbox&#x27;,            &#x27;-–no-first-run&#x27;,            &#x27;--no-sandbox&#x27;,            &#x27;-–no-zygote&#x27;,            &#x27;-–single-process&#x27;,         &#x27;--disable-font-subpixel-positioning&#x27;, // 必须添加，解决windows和linux下渲染结果不一致问题         &#x27;--font-render-hinting=none&#x27;// 必须添加，解决windows和linux下渲染结果不一致问题        ],        ignoreHTTPSErrors: true,        timeout: 0    &#125;,    browserPool: &#123;        min: 1, // 池中最小实例数        max: 5, // 池中最大实例数        idleTimeoutMillis: 1000 * 60 * 60 * 24, // 实例存活时间，超时将重新创建新的实例，防止内存泄漏，浏览器实例默认24小时        evictionRunIntervalMillis: 1000 * 60 * 60 // 实例存活检测时间    &#125;,    pagePool: &#123;        min: 5,        max: 10,        cacheDisabled: true, // 是否禁用页面缓存        idleTimeoutMillis: 1000 * 60 * 60, // 页面实例默认一小时重新创建一次        evictionRunIntervalMillis: 1000 * 60    &#125;,    tempRootDir: &#x27;/home/icampus3.0/pkgs/puppeteer-microservice/temp&#x27;,    contextPath: &#x27;/microservice/puppeteerservice&#x27;&#125;\n\n服务脚本stop.sh\n123456789101112131415161718192021222324#!/bin/bash######################## created by code on 2021/10/25#######################function stop()&#123;       serviceName=puppeteer-microservice       local pid=$(ps aux|grep &quot;puppeteer-microservice&quot;|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; 2&gt;&gt;/dev/null)       if [[ -n $pid ]]; then            kill -9 $pid 2&gt;&gt;/dev/null            if [[ $? -ne 0 ]]; then                 echo -e &quot;  Failed to stop service of $&#123;serviceNam&#125;&quot;                 return 1            else                 echo -e &quot;  Successful to stop service of $&#123;serviceNam&#125;&quot;                 return 0            fi       fi&#125;stop\n\nstart.sh\n12345678910111213141516171819202122232425262728293031323334353637#!/bin/bash######################## created by code on 2021/10/25#######################function setVars()&#123;       serviceName=puppeteer-microservice       basepath=/home/icampus3.0       jdkHome=$&#123;basepath&#125;/jdk8       servHome=$&#123;basepath&#125;/pkgs/$&#123;serviceName&#125;       start=$&#123;servHome&#125;/start.sh       log=$&#123;basepath&#125;/logs/$&#123;serviceName&#125;.log       npm=/usr/local/n/versions/node/14.18.1/bin/npm       option=&quot;run start&quot;&#125;function start()&#123;       cd $servHome       sh stop.sh       echo -e &quot;  Start to start up $&#123;serviceName&#125; : &quot;       echo -e &quot;$&#123;npm&#125; $&#123;option&#125;&quot;       $&#123;npm&#125; $&#123;option&#125; &gt; $log 2&gt;&amp;1 &amp;       echo $! &gt; pid       if [[ -z $(cat pid) ]]; then           echo -e &quot;  Failed to start up $&#123;serviceName&#125;&quot;           return 1       else           echo -e &quot;  Successful to start up $&#123;serviceName&#125;&quot;           return 0       fi&#125;setVarsstart\n\n可选安装chrome不同内核版本，css有兼容性问题，一律使用最新版本。  兼容性问题已修复\n网上说这个版本的Chrome性能比较好：无头浏览器性能对比与Puppeteer的优化文档, 实际测试下来差不多。\n12yum install chromium-headless/usr/lib64/chromium-browser/headless_shell 调用路径\n\n安装依赖时执行下面的命令跳过Chrome的下载\n1npm install puppeteer --ignore-scripts\n\nNginx配置123456789101112upstream puppeteer-microservice &#123;   server xxxx:xxxx;&#125;location ^~ /microservice/puppeteerservice &#123;    proxy_set_header Host $http_host;    proxy_redirect off;    proxy_pass http://puppeteer-microservice/microservice/puppeteerservice;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size 1000m;&#125;\n\nPuppeteer服务接口Web转PDF服务[GET] /microservice/puppeteerservice/pdf  \n参数：\n\n\n\nparams\nDescription\n\n\n\nhtmlUrl\nbase64后的待生成PDF的页面地址\n\n\nhtmlUrl参数：\n\n\n\nhtmlUrl\nDescription\n\n\n\nformat\nA3 或 A4, 默认 A4\n\n\nprintBackground\n是否打印背景图, 默认false\n\n\n","slug":"Puppeteer配置记录","date":"2022-12-23T07:02:52.000Z","categories_index":"Puppeteer","tags_index":"配置,Puppeteer","author_index":"Weiba"},{"id":"8ab3f21ba7a602db5d827c424cd46168","title":"Docker数据迁移","content":"Docker 数据迁移\n\n\n\n\n\n\n\n\n主机是lxc的，只分配了10G，安装 office 镜像空间不够，将 Docker 数据迁移到硬盘上。\n\n停止 Docker 12systemctl stop docker.socketsystemctl stop docker\n拷贝数据 123cp -a /var/lib/docker /mnt/nas/application/dockermv /var/lib/docker /var/lib/docker-oldln -s /mnt/nas/application/docker /var/lib/\n启动测试, 删除原数据 123systemctl start dockersystemctl status dockerrm -rf /var/lib/docker-old\n\n","slug":"Docker数据迁移","date":"2022-12-23T06:52:19.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"Weiba"},{"id":"13f9d2767e677dbdfef0514958857ae1","title":"Docker 安装记录","content":"可道云\n\n\n\n\n\n\n\n\n使用内置nginx，代理相关服务\n1234567891011docker run -d \\--name cloudfile \\--dns 192.168.186.210  \\-p 12880:12880 \\-e PUID=1000 -e PGID=1000 \\-v /mnt:/mnt \\-v /root/.acme.sh:/root/.acme.sh \\-v /mnt/nas/application/nginx/etc/nginx/sites-enabled:/etc/nginx/sites-enabled \\-v /mnt/nas/application/nginx/etc/nginx/password:/etc/nginx/password \\-v /mnt/nas/application/kodcloud/kodbox/data:/var/www/html \\--restart always kodcloud/kodbox:latest\n\nnginxwebui\n\n\n\n\n\n\n\n\nng配置编辑服务\n12345678docker run -itd  \\--name ngweb \\-e BOOT_OPTIONS=&quot;--server.port=12881&quot; \\-p 12881:12881 \\-e PUID=1000 -e PGID=1000 \\-v /mnt/nas/application/nginx/etc/nginx/:/etc/nginx/ \\-v /root/.acme.sh:/root/.acme.sh \\--restart always cym1102/nginxwebui:latest\n配置\nhttp请求跳转https12345server &#123;    ...    error_page 497 = https://$host:12880$request_uri;    ...&#125;\n配置文件修改后执行：cat reNginx.sh123#!/bin/bashrm -rf /mnt/nas/application/nginx/etc/nginx/sites-enabled/* &amp;&amp; cp /mnt/nas/application/nginx/etc/nginx/conf.d/* /mnt/nas/application/nginx/etc/nginx/sites-enabled/ &amp;&amp; docker container restart cloudfile\n\nmariadb-mysql12345678docker run -d \\--name mysql \\-p 3306:3306 \\-e PUID=1000 -e PGID=1000 \\-e MYSQL_ROOT_PASSWORD=password \\--user 1000:1000 \\-v /mnt/nas/application/mariadb/data:/var/lib/mysql \\--restart always mariadb:latest\n\nRedis1234567docker run -itd \\--name redis \\-p 6379:6379 \\-v /mnt/nas/application/redis/data:/data \\-e PUID=1000 -e PGID=1000 \\--user 1000:1000 \\--restart always redis:latest\n\nnyanmisaka&#x2F;jellyfin\n\n\n\n\n\n\n\n\njellyfin 中国优化版\n123456789101112docker run -d \\--name jf \\-e PUID=$(id -u) -e PGID=$(id -g) \\-e TZ=Asia/Shanghai \\-p 8099:8096 \\-e HTTP_PROXY=http://192.168.186.210:7890 \\-e HTTPS_PROXY=http://192.168.186.210:7890 \\-v /mnt/nas/application/jellyfin:/config \\-v /mnt/nas/data:/data \\-v /mnt:/mnt \\--device /dev/dri:/dev/dri \\--restart always nyanmisaka/jellyfin:latest\n\n宿主机安装：\n12apt install intel-gpu-toolsapt-get -y install vainfo\n\n更改硬解配置后必须重启\n迅雷群晖版\n\n\n\n\n\n\n\n\n必须用root权限运行, 非会员每天只能下载几个资源\n12345678docker run -d \\--name=xunlei \\--hostname=MyNas \\--net=host \\-e XL_WEB_PORT=2345 \\-v /mnt/nas/application/xunlei/data:/xunlei/data \\-v /mnt/nas/data:/xunlei/downloads \\--restart always --privileged cnk3x/xunlei:latest\n\naria21234567891011121314151617docker run -d \\    --name aria2 \\    --restart always  \\    --log-opt max-size=1m \\    -e PUID=1000 \\    -e PGID=1000 \\    -e UMASK_SET=022 \\    -e RPC_SECRET=656CjCKQ0iQUB78eXgd2VpYmExMDI4 \\    -e RPC_PORT=6800 \\    -p 6800:6800 \\    -e LISTEN_PORT=6888 \\    -p 6888:6888 \\    -p 6888:6888/udp \\    -v /mnt/nas/application/aria2/config:/config \\    -v /mnt/nas/data/downloads:/downloads \\    -v /mnt:/mnt \\    p3terx/aria2-pro\nqBittorrent\n\n\n\n\n\n\n\n\nDocker qBittorrent 中国优化版: https://github.com/SuperNG6/docker-qbittorrent默认用户名:admin;默认密码:adminadmin\n1234567891011121314docker run -d  \\    --name=qb  \\    -e WEBUIPORT=8080  \\    -e PUID=1000 \\    -e PGID=1000 \\    -e TZ=Asia/Shanghai \\    -p 16881:16881  \\    -p 16881:16881/udp  \\    -p 16080:8080  \\    -v /mnt/nas/application/qBittorrent:/config  \\    -v /mnt/nas/data/downloads:/downloads  \\    -v /mnt:/mnt \\    --restart always  \\    superng6/qbittorrent:latest\n启动有点慢。\n问题记录\nqBittorrent添加Trackers后显示未联系-docker已修复在qBittorrent.conf文件中的Preferences下添加如下内容，重启qBittorrent即可1Advanced\\AnnounceToAllTrackers=true\n\ntransmissionic\n\n\n\n\n\n\n\n\n太耗CPU了，直接用qb吧\n1234567891011121314151617docker run -d \\  --name tran \\  -e PUID=1000 \\  -e PGID=1000\\  -e TZ=Asia/Shanghai \\  -e TRANSMISSION_WEB_HOME=/transmissionic/ `#optional` \\  -e USER=userName \\  -e PASS=password  \\  -p 9091:9091 \\  -p 51413:51413 \\  -p 51413:51413/udp \\  -v /mnt:/mnt \\  -v /mnt/nas/application/transmission/config:/config \\  -v /mnt/nas/data/downloads:/downloads \\  -v /mnt/nas/application/transmission/watch:/watch \\  --restart always \\  lscr.io/linuxserver/transmission:latest\n\nphotoprism耗资源，不用了\n12345678910111213141516171819docker run -d \\  --name photo \\  -e PUID=1000 \\  -e PGID=1000 \\-p 2342:2342 \\-v /mnt/nas/data/相册:/photoprism/originals \\-v /mnt/nas/data/backups/userName/相册:/photoprism/originals/userName-v /mnt/nas/application/photoprism/storage:/photoprism/storage \\-v /mnt/nas/application/photoprism/import:/photoprism/import \\-v /mnt:/mnt \\-e PHOTOPRISM_DATABASE_DRIVER=mysql \\-e PHOTOPRISM_ADMIN_PASSWORD=password \\-e PHOTOPRISM_DATABASE_SERVER=192.168.186.230:3306 \\-e PHOTOPRISM_DATABASE_NAME=photoprism \\-e PHOTOPRISM_DATABASE_USER=root \\-e PHOTOPRISM_DATABASE_PASSWORD=password \\-e Allow_uploads_that_MAY_be_offensive=true \\--device /dev/dri:/dev/dri \\--restart always thielepaul/photoprism:db-api\n\n\nclouddrive先执行  mount –make-shared &#x2F;mnt&#x2F;nas, 添加到开机脚本，初始化时应用启动后再设置对应网盘的挂载点，把&#x2F;mnt放进去，要在docker加载之前执行，我就写在 vim &#x2F;etc&#x2F;init.d&#x2F;docker 开头了\n123456789docker run -d \\--name clouddrive \\-p 9798:9798 \\--privileged \\--device /dev/fuse:/dev/fuse \\-v /mnt/nas/application/clouddrive:/Config \\-v /mnt/nas:/media:shared \\--restart always \\cloudnas/clouddrive:latest\n\npiwigo\n\n\n\n\n\n\n\n\n难用, 照片多了以后无法导入\n123456789101112131415161718docker run -d \\  --name=photo \\  --dns 192.168.186.210 \\  -e PUID=1000 \\  -e PGID=1000 \\  -e TZ=Asia/Shanghai \\--env HTTP_PROXY=&quot;http://192.168.186.210:7890&quot; \\--env HTTPS_PROXY=&quot;http://192.168.186.210:7890&quot; \\--env http_proxy=&quot;http://192.168.186.210:7890&quot; \\--env https_proxy=&quot;http://192.168.186.210:7890&quot; \\  -p 2342:80 \\  -v /mnt/nas/application/piwigo/config:/config \\  -v /mnt/nas/application/piwigo/gallery:/gallery \\  -v /mnt/nas/data/相册:/gallery/galleries/userName \\  -v /mnt/nas/data/backups/userName/相册/:/gallery/galleries/userName/backups \\  -v /mnt/nas/application/kodcloud/kodbox/data/data/files:/gallery/galleries/可道云 \\  --restart always \\  lscr.io/linuxserver/piwigo:latest\n\n配置支持中文\n12unless-stopped$conf[&#x27;sync_chars_regex&#x27;] = &#x27;/^[\\x&#123;0800&#125;-\\x&#123;9fa5&#125;a-zA-Z0-9-_.\\(\\)\\[\\]\\ 【】（）, ·^×&#123;&#125;=★☆@#\\s+]+$/u&#x27;;*/\n\nOnlyOffice12345678910docker run -itd \\--name onlyoffice \\--dns 192.168.186.210 \\-e PUID=1000 \\-e PGID=1000 \\--restart always \\-p 8081:80 \\-v /app/onlyoffice/DocumentServer/logs:/mnt/nas/application/onlyoffice/logs \\-v /app/onlyoffice/DocumentServer/data:/mnt/nas/application/onlyoffice/data \\onlyoffice/documentserver\n\ndrawio123456789docker run -itd \\--name=&quot;draw-io&quot; \\--restart=always \\--dns 192.168.186.210 \\-e PUID=1000 \\-e PGID=1000 \\-p 8082:8080 \\-v /mnt:/mnt \\fjudith/draw.io\n","slug":"Docker安装记录","date":"2022-12-23T06:48:39.000Z","categories_index":"Docker","tags_index":"Docker,安装记录","author_index":"Weiba"},{"id":"3ebd4f663314a792fe95f50d1c26f762","title":"万由 NAS 201P 风扇控制脚本","content":"1234567891011121314151617181920#!/bin/bashmodprobe i2c-devtcpu=20thdd=20tcpu=$(sensors | tail -n +7 | head -n +1 | cut -b 17,18)thdd=$(hddtemp /dev/sda | cut -b 36,37)sum=$(( $tcpu + $thdd  - 10 ))      echo &quot;$sum is fan speed&quot; &gt; /root/fan.txtecho &quot;$tcpu is CPU temp &quot; &gt;&gt; /root/fan.txtecho &quot;$thdd is HDD temp &quot; &gt;&gt; /root/fan.txtdate &gt;&gt; /root/fan.txti2cset -y 0 0x54 0xf0 $sum\n\n","slug":"万由 NAS 201P 风扇控制脚本","date":"2022-12-23T06:46:50.000Z","categories_index":"NAS","tags_index":"Shell,NAS,201P","author_index":"Weiba"},{"id":"dc1c644c622f4be60aa728bcd1bd8760","title":"docker transmission 制作种子","content":"docker transmission 制作种子123docker exec -it tran bashcd /user/bintransmission-create -p -o /mnt/nas/data/资料/种子/Cold.Detective.2022.WEB-DL.2160p.X264.torrent -t https://www.pttime.org/announce.php  -s 2048 /mnt/nas/data/资料/种子/Cold.Detective.2022.WEB-DL.2160p.X264/","slug":"docker transmission 制作种子","date":"2022-12-23T06:45:19.000Z","categories_index":"docker","tags_index":"transmission,制作种子","author_index":"Weiba"},{"id":"6b3e720923b0ba26fd3bbe6579affa3f","title":"AliYun Webdav 守护进程配置","content":"\nwget 下载 webdav-aliyundriver jar 包，获取 yourefreshtoken 文档也在说明页，其他参数可以自己加载脚本后面\n安装 jre 环境 apt install default-jre\n创建启动和停止脚本，文件目录用自己的\n\nvi stop.sh\n1234567#!/bin/bashecho &quot;webdav-aliyundriver will be stoped.....&quot;pid=$(ps aux|grep -v grep|grep webdav-aliyundriver*.jar|awk &#x27;&#123;print $2&#125;&#x27;);if [[ $pid -gt 1 ]]; then    kill -9 $pidfi\n\nvi start.sh\n123456#!/bin/bash/mnt/nas/data/dev_tools/webdav/aliyun/stop.shecho &quot;webdav-aliyundriver will be start.....&quot;java -jar /mnt/nas/data/dev_tools/webdav/aliyun/webdav-aliyundriver-2.4.2.jar --aliyundrive.refresh-token=&quot;yourefreshtoken&quot; &gt; /dev/null &amp;\n\n加权限 chmod +x start.sh stop.sh\n\n创建守护线程服务vi &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;webdav-ali.service123456789101112131415161718[Unit]Description=Webdav Aliyun# 在什么服务启动之后再执行本程序After=network.target[Service]Type=forking# 程序执行的目录WorkingDirectory=/mnt/nas/data/dev_tools/webdav/aliyun/# 启动的脚本命令ExecStart=/mnt/nas/data/dev_tools/webdav/aliyun/start.shExecReload=/mnt/nas/data/dev_tools/webdav/aliyun/start.shExecStop=/mnt/nas/data/dev_tools/webdav/aliyun/stop.sh# 重启条件Restart=always# 几秒后重启RestartSec=5[Install]WantedBy=multi-user.target\n\n开启服务\n\n重载 systemctl daemon-reload\n开机自启 systemctl enable webdav-ali\n启动 systemctl start webdav-ali\n查看状态 systemctl start webdav-ali\n\n","slug":"AliYun Webdav 守护进程配置","date":"2022-12-23T06:44:10.000Z","categories_index":"Webdav","tags_index":"Webdav,Aliyun","author_index":"Weiba"},{"id":"cbe323e32f8b37c93337862c65bef9d6","title":"DDNS和证书配置","content":"DDNS\n\n\n\n\n\n\n\n\n项目地址：https://github.com/rehiy/dnspod-shell\n一、编辑配置文件vim ddnspod.sh\n123456789. /root/dnspod-shell/ardnspodarToken=&quot;xx,xx&quot;# IPv4:arDdnsCheck &quot;xx.cf&quot; &quot;@&quot;arDdnsCheck &quot;xx.cf&quot; &quot;*&quot;：arDdnsCheck &quot;xx.ml&quot; &quot;@&quot;arDdnsCheck &quot;xx.ml&quot; &quot;*&quot;\n二 添加定时任务，每小时1次crontab -e\n10 * * * * /root/dnspod-shell/ddnspod.sh &gt; /root/dnspod-shell/ddnspod.log\n\nacme\n\n\n\n\n\n\n\n\n项目地址：https://github.com/acmesh-official/acme.sh\n一、安装并重载环境变量1234curl https://get.acme.sh | sh -s email=xxx@qq.comsource ~/.bashrc# 自动更新acme.sh --upgrade --auto-upgrade\n二、设置DNS KEY12export DP_Id=&quot;xxx&quot;export DP_Key=&quot;xxx&quot;\n\n三、生成域名与泛域名证书12acme.sh --issue --dns dns_dp -d xx.cf -d *.xx.cfacme.sh --issue --dns dns_dp -d xx.ml -d *.xx.ml\n\n合成带 fullchain 的cer文件1cat xxx.cf.cer fullchain.cer &gt;&gt; xxx.cf.pem","slug":"DDNS和证书配置","date":"2022-12-23T06:42:26.000Z","categories_index":"DDNS","tags_index":"DDNS,HTTPS","author_index":"Weiba"},{"id":"a06638b83fc487413a350d2959840084","title":"PVE LXC 常用配置","content":"LXC配置1.Ubuntu开启硬件直通\n123456789101112131415161718192021222324arch: amd64cores: 4features: nesting=1hostname: Ububtu-20.04memory: 7680mp1: /mnt/nas,mp=/mnt/nasmp2: /mnt/aliyun,mp=/mnt/aliyunonboot: 0ostype: ubunturootfs: local:101/vm-101-disk-0.raw,size=10Gswap: 0lxc.net.0.type: physlxc.net.0.link: enp3s0lxc.net.0.ipv4.address: 192.168.186.230/24lxc.net.0.ipv4.gateway: 192.168.186.1lxc.net.0.flags: uplxc.apparmor.profile: unconfinedlxc.cgroup.devices.allow: alxc.cap.drop: lxc.cgroup2.devices.allow: c 226:0 rwmlxc.cgroup2.devices.allow: c 226:128 rwmlxc.mount.entry: /dev/dri/card0 dev/dri/card0 none bind,optional,create=filelxc.mount.entry: /dev/dri/renderD128 dev/dri/renderD128 none bind,optional,create=filelxc.mount.entry: /dev/fuse dev/fuse none bind,create=file\n\n2.OpenWrt Clash\n12345678910arch: amd64cores: 2hookscript: local:snippets/hookscript.plhostname: Lede-OpenWRTmemory: 512net0: name=eth0,bridge=vmbr0,hwaddr=D6:DC:B4:4F:77:EF,type=vethonboot: 1ostype: unmanagedrootfs: local:100/vm-100-disk-0.raw,size=204Mswap: 0\n\n3.openwrt.common.conf\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# Default console settingslxc.tty.dir = lxclxc.tty.max = 4lxc.pty.max = 1024# Default capabilitieslxc.cap.drop = mac_adminlxc.cap.drop = mac_overridelxc.cap.drop = sys_adminlxc.cap.drop = sys_modulelxc.cap.drop = sys_nicelxc.cap.drop = sys_pacct#lxc.cap.drop = sys_ptracelxc.cap.drop = sys_rawio#lxc.cap.drop = sys_resourcelxc.cap.drop = sys_timelxc.cap.drop = sys_tty_configlxc.cap.drop = sysloglxc.cap.drop = wake_alarm# Default cgroups - all denied except those whitelistedlxc.cgroup.devices.deny = a## /dev/null and zerolxc.cgroup.devices.allow = c 1:3 rwmlxc.cgroup.devices.allow = c 1:5 rwm## consoleslxc.cgroup.devices.allow = c 5:0 rwmlxc.cgroup.devices.allow = c 5:1 rwm## /dev/&#123;,u&#125;randomlxc.cgroup.devices.allow = c 1:8 rwmlxc.cgroup.devices.allow = c 1:9 rwm## /dev/pts/*lxc.cgroup.devices.allow = c 5:2 rwmlxc.cgroup.devices.allow = c 136:* rwm## rtclxc.cgroup.devices.allow = c 254:0 rm## tunlxc.cgroup.devices.allow = c 10:200 rwm## dev/tty0lxc.cgroup.devices.allow = c 4:0 rwm## dev/tty1lxc.cgroup.devices.allow = c 4:1 rwm## To use loop devices, copy the following line to the container&#x27;s## configuration file (uncommented).#lxc.cgroup.devices.allow = b 7:* rwm# Blacklist some syscalls which are not safe in privileged# containerslxc.seccomp.profile = /usr/share/lxc/config/common.seccomp\n\n","slug":"PVE LXC 常用配置","date":"2022-12-23T06:39:40.000Z","categories_index":"PVE","tags_index":"PVE,LXC","author_index":"Weiba"},{"id":"85b8693a512d03bf427ab4982831b7cd","title":"常用正则表达式","content":"提取字符串中的图片地址\n123456789101112String url = &quot;&lt;div&gt;&lt;img width=\\&quot;864px\\&quot; height=\\&quot;148px\\&quot; src=\\&quot;http://r30.enable-ets.com/storage/attachment/2019/4/23/cca1a4629f2a42be9e929b3f80de1c51.JPG\\&quot; alt=\\&quot;\\&quot; title=\\&quot;image\\&quot; style=\\&quot;width: 37.57em; height: 6.43em; vertical-align: middle;\\&quot;&gt;&lt;/img&gt;&lt;br&gt;&lt;img width=\\&quot;863px\\&quot; height=\\&quot;755px\\&quot; src=\\&quot;http://r30.enable-ets.com/storage/attachment/2019/4/23/d660a24657c6499fa31b3d3bbe9140cb.jpg\\&quot; alt=\\&quot;\\&quot; title=\\&quot;image\\&quot; style=\\&quot;width: 37.52em; height: 32.83em; vertical-align: middle;\\&quot;&gt;&lt;/img&gt;&lt;br&gt;&lt;img width=\\&quot;866px\\&quot; height=\\&quot;133px\\&quot; src=\\&quot;http://r30.enable-ets.com/storage/attachment/2019/4/23/3cce9cfbedba4976921adaceafd4d98d.jpg\\&quot; alt=\\&quot;\\&quot; title=\\&quot;image\\&quot; style=\\&quot;width: 37.65em; height: 5.78em; vertical-align: middle;\\&quot;&gt;&lt;/img&gt;&lt;br&gt;　&lt;/div&gt;&quot;;// 提取非json格式的http地址, json格式会带&quot;// Pattern pattern = Pattern.compile(&quot;http://[\\\\S\\\\.]+[:\\\\d]?[/\\\\S]&quot;);Pattern pattern = Pattern.compile(&quot;http://[\\\\S\\\\.]+[:\\\\d]?[.jpg|.jpeg|.png|.gif|.bmp]&quot;, Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(url);StringBuffer buffer = new StringBuffer();while(matcher.find())&#123;    buffer.append(matcher.group());    buffer.append(&quot;\\r\\n&quot;);&#125;System.out.println(buffer.toString());\n\njs 取出标签中的所有值\n123456789101112131415161718192021222324252627getAnalysisFileList : function(analysisString) &#123;        // 转换answer信息, 取出所有标签值        // analysisString = &quot;&lt;p&gt;&lt;img src=\\&quot;http://192.168.116.190/storage/attachment/2020/1/2/f583bb1a6e22429fa558aa00b4e9abf2.png\\&quot; title=\\&quot;1.png\\&quot; alt=\\&quot;1.png\\&quot;&gt;&lt;img src=\\&quot;http://192.168.116.190/storage/attachment/2020/1/2/a3ae44211b2946e08e023a2f2ed34960.jpg\\&quot; title=\\&quot;1-543872364186734592-B.jpg\\&quot; alt=\\&quot;1-543872364186734592-B.jpg\\&quot;&gt;&lt;/p&gt;&quot;;        // 取出连接和文件名        var reg= /=\\&quot;(.*?)\\&quot;/g;        var i = 1;        var analysisFileList = [];        while (r=reg.exec(analysisString))&#123;            // 每个图片有一个地址, 一个title, 一个alt, 一个size, 四个切换一组            let index = Math.floor((i-1)/4);            let analysisFileTemp = analysisFileList[index];            if (CommUtils.isEmpty(analysisFileTemp)) &#123;                analysisFileTemp = &#123;                    url: r[1],                    fileName: &quot;&quot;,                    size: Math.floor(Math.random(Math.random()) * 10000)                &#125;                analysisFileList[index] = analysisFileTemp;            &#125; else if (i%4 == 2) &#123;                analysisFileTemp.fileName = r[1];            &#125; else if (i%4 == 0 &amp;&amp; i !== 0) &#123;                analysisFileTemp.size =  r[1];            &#125;            i++;        &#125;        return analysisFileList;    &#125;,","slug":"常用正则表达式","date":"2022-12-23T06:37:54.000Z","categories_index":"正则表达式","tags_index":"常用命令,正则表达式","author_index":"Weiba"},{"id":"5a54787070bd542db188133e8da5c4f2","title":"ffmpeg常用命令","content":"合并视频和声音\nffmpeg -hwaccel qsv -i test.mp4 -i test.mp3 -c:v h264_qsv -c:v copy -c:a aac -strict experimental -map 0:v:0 -map 1:a:0 hecheng.mp4使用qsv硬件解码\n1ffmpeg -i test.mp4 -i test.mp3 -c:v copy -c:a aac -strict experimental -map 0:v:0 -map 1:a:0 hecheng.mp4\n\n\n合并视频或声音\n1ffmpeg -i &quot;concat:123.mp3|124.mp3&quot; -acodec copy output.mp3\n\n使用qsv硬件解码\n1ffmpeg -hwaccel qsv -i &quot;concat:123.mp3|124.mp3&quot; -c:v h264_qsv -acodec copy output.mp3","slug":"ffmpeg常用命令","date":"2022-12-23T06:35:29.000Z","categories_index":"ffmpeg","tags_index":"常用命令,ffmpeg","author_index":"Weiba"},{"id":"de7c4fb9583e9a4d0dcb141dc613fb16","title":"豆瓣API接口","content":"豆瓣API接口搜索接口\n[GET] https://m.douban.com/j/search/?q=%E5%96%9C%E6%AC%A2%E4%BD%A0&amp;t=1002&amp;p=1\n\n\n\n\n参数\n说明\n\n\n\nt\n类型id\n\n\np\n分页\n\n\n\n\n\nt id\n说明\n\n\n\n1001\n书籍\n\n\n1002\n电影\n\n\n1003\n音乐\n\n\n1019\n小组\n\n\n原图下载wget --referer=&quot;https://img2.doubanio.com&quot; https://img2.doubanio.com/view/photo/raw/public/p2455926001.jpg或wget --referer=&quot;https://m.douban.com&quot; https://img2.doubanio.com/view/photo/raw/public/p2455926001.jpg\n","slug":"豆瓣API接口","date":"2022-12-23T06:32:27.000Z","categories_index":"公共API","tags_index":"API,豆瓣","author_index":"Weiba"},{"id":"09e148cac22e494cb9e5253096017f87","title":"Explain详解与索引最佳实践","content":"索引使用总结：\n\nlike KK%相当于&#x3D;常量，%KK和%KK% 相当于范围\nExplain详解与索引最佳实践Mysql安装文档参考：https://blog.csdn.net/yougoule/article/details/56680952\nExplain工具介绍使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈  \n在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL\n注意：如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中\nExplain分析示例参考官方文档：https://dev.mysql.com/doc/refman/5.7/en/explain-output.html\n示例表： \n1234567891011121314151617181920212223242526272829303132示例表：DROP TABLE IF EXISTS `actor`; CREATE TABLE `actor` (  `id` int(11) NOT NULL,  `name` varchar(45) DEFAULT NULL,  `update_time` datetime DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `actor` (`id`, `name`, `update_time`) VALUES (1,&#x27;a&#x27;,&#x27;2017-12-22 15:27:18&#x27;), (2,&#x27;b&#x27;,&#x27;2017-12-22 15:27:18&#x27;), (3,&#x27;c&#x27;,&#x27;2017-12-22 15:27:18&#x27;);DROP TABLE IF EXISTS `film`;CREATE TABLE `film` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(10) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `idx_name` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `film` (`id`, `name`) VALUES (3,&#x27;film0&#x27;),(1,&#x27;film1&#x27;),(2,&#x27;film2&#x27;);DROP TABLE IF EXISTS `film_actor`;CREATE TABLE `film_actor` (  `id` int(11) NOT NULL,  `film_id` int(11) NOT NULL,  `actor_id` int(11) NOT NULL,  `remark` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `idx_film_actor_id` (`film_id`,`actor_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `film_actor` (`id`, `film_id`, `actor_id`) VALUES (1,1,1),(2,1,2),(3,2,1);\n\n 1mysql&gt; explain select * from actor;\n\n\n\n​    \n在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行\nexplain 两个变种1）explain extended：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered&#x2F;100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。\n1mysql&gt; explain extended select * from film where id = 1;\n\n\n\n1mysql&gt; show warnings;\n\n\n\n\n\nexplain中的列接下来我们将展示 explain 中每个列的信息。\n1. id列\nid列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。\nid列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。\n2. select_type列\nselect_type 表示对应行是简单还是复杂的查询。\n1）simple：简单查询。查询不包含子查询和union\n1mysql&gt; explain select * from film where id = 2;\n\n\n\n2）primary：复杂查询中最外层的 select\n3）subquery：包含在 select 中的子查询（不在 from 子句中）\n4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）\n用这个例子来了解 primary、subquery 和 derived 类型\n12mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;;   #关闭mysql5.7新特性对衍生表的合并优化mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;\n\n\n\n1mysql&gt; set session optimizer_switch=&#x27;derived_merge=on&#x27;;\t#还原默认配置\n\n5）union：在 union 中的第二个和随后的 select\n1mysql&gt; explain select 1 union all select 1;\n\n\n\n3. table列\n这一列表示 explain 的一行正在访问哪个表。\n当 from 子句中有子查询时，table列是 格式，表示当前查询依赖 id&#x3D;N 的查询，于是先执行 id&#x3D;N 的查询。\n当有 union 时，UNION RESULT 的 table 列的值为，1和2表示参与 union 的 select 行id。\n4. type列\n这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。\n依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL\n一般来说，得保证查询达到range级别，最好达到ref\nNULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表\n1mysql&gt; explain select min(id) from film;\n\n\n\nconst, system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为system\n1mysql&gt; explain extended select * from (select * from film where id = 1) tmp;\n\n\n\n1mysql&gt; show warnings;\n\n\n\neq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。\n1mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;\n\n\n\nref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n1.简单 select 查询，name是普通索引（非唯一索引）\n1mysql&gt; explain select * from film where name = &#x27;film1&#x27;;\n\n\n\n2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。\n1mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;\n\n\n\nrange：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。\n1mysql&gt; explain select * from actor where id &gt; 1;\n\n\n\nindex：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。\n1mysql&gt; explain select * from film;\n\n\n\nALL：即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。\n1mysql&gt; explain select * from actor;\n\n\n\n5. possible_keys列\n这一列显示查询可能使用哪些索引来查找。 \nexplain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 \n如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。\n6. key列\n这一列显示mysql实际采用哪个索引来优化对该表的访问。\n如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。\n7. key_len列\n这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 \n举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len&#x3D;4可推断出查询使用了第一个列：film_id列来执行索引查找。\n1mysql&gt; explain select * from film_actor where film_id = 2;\n\n\n\nkey_len计算规则如下：\n\n字符串，char(n)和varchar(n)，5.0.3以后版本中，n均代表字符数，而不是字节数，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节\n\n\nchar(n)：如果存汉字长度就是 3n 字节\nvarchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为varchar是变长字符串\n\n\n数值类型\n\n\ntinyint：1字节\nsmallint：2字节\nint：4字节\nbigint：8字节\n\n　　\n\n时间类型　\n\n\ndate：3字节\ntimestamp：4字节\ndatetime：8字节\n\n\n如果字段允许为 NULL，需要1字节记录是否为 NULL\n\n\n索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。\n8. ref列\n这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）\n9. rows列\n这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。\n10. Extra列\n这一列展示的是额外信息。常见的重要值如下： \n1）Using index：使用覆盖索引\n覆盖索引定义：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值\n1mysql&gt; explain select film_id from film_actor where film_id = 1;\n\n\n\n2）Using where：使用 where 语句来处理结果，并且查询的列未被索引覆盖\n1mysql&gt; explain select * from actor where name = &#x27;a&#x27;;\n\n\n\n3）Using index condition：查询的列不完全被索引覆盖，where条件中是一个前导列的范围；\n1mysql&gt; explain select * from film_actor where film_id &gt; 1;\n\n\n\n4）Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。\n1.actor.name没有索引，此时创建了张临时表来distinct\n1mysql&gt; explain select distinct name from actor;\n\n2.film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表\n1mysql&gt; explain select distinct name from film;\n\n5）Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。\n1.actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录\n1mysql&gt; explain select * from actor order by name;\n\n\n\n2.film.name建立了idx_name索引,此时查询时extra是using index\n1mysql&gt; explain select * from film order by name;\n\n\n\n6）Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是\n1mysql&gt; explain select min(id) from film;\n\n\n\n\n\n索引最佳实践1234567891011121314示例表：CREATE TABLE `employees` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(24) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;,  `age` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,  `position` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;职位&#x27;,  `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;入职时间&#x27;,  PRIMARY KEY (`id`),  KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=&#x27;员工记录表&#x27;;INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;LiLei&#x27;,22,&#x27;manager&#x27;,NOW());INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;HanMeimei&#x27;, 23,&#x27;dev&#x27;,NOW());INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;Lucy&#x27;,23,&#x27;dev&#x27;,NOW());\n\n1.全值匹配1EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27;;\n\n\n\n1EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22;\n\n\n\n1EXPLAIN SELECT * FROM employees WHERE  name= &#x27;LiLei&#x27; AND  age = 22 AND position =&#x27;manager&#x27;;\n\n\n\n2.最左前缀法则 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。\n123EXPLAIN SELECT * FROM employees WHERE name = &#x27;Bill&#x27; and age = 31;EXPLAIN SELECT * FROM employees WHERE age = 30 AND position = &#x27;dev&#x27;;EXPLAIN SELECT * FROM employees WHERE position = &#x27;manager&#x27;;\n\n\n\n3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描12EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27;;EXPLAIN SELECT * FROM employees WHERE left(name,3) = &#x27;LiLei&#x27;;\n\n\n\n给hire_time增加一个普通索引：\n1ALTER TABLE `employees` ADD INDEX `idx_hire_time` (`hire_time`) USING BTREE ;\n\n1EXPLAIN  select * from employees where date(hire_time) =&#x27;2018-09-30&#x27;;\n\n\n\n转化为日期范围查询，有可能会走索引：\n1EXPLAIN  select * from employees where hire_time &gt;=&#x27;2018-09-30 00:00:00&#x27;  and  hire_time &lt;=&#x27;2018-09-30 23:59:59&#x27;;\n\n\n\n还原最初索引状态\n1ALTER TABLE `employees` DROP INDEX `idx_hire_time`;\n\n4.存储引擎不能使用索引中范围条件右边的列12EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manager&#x27;;EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age &gt; 22 AND position =&#x27;manager&#x27;;\n\n\n\n5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句1EXPLAIN SELECT name,age FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;\n\n\n\n1EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;\n\n\n\n6.mysql在使用不等于（！&#x3D;或者&lt;&gt;），****not in ，not exists 的时候无法使用索引会导致全表扫描&lt; 小于、 &gt; 大于、 &lt;&#x3D;、&gt;&#x3D; 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引\n1EXPLAIN SELECT * FROM employees WHERE name != &#x27;LiLei&#x27;;\n\n\n\n7.is null,is not null 一般情况下也无法使用索引1EXPLAIN SELECT * FROM employees WHERE name is null\n\n\n\n8.like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作1EXPLAIN SELECT * FROM employees WHERE name like &#x27;%Lei&#x27;\n\n\n\n1EXPLAIN SELECT * FROM employees WHERE name like &#x27;Lei%&#x27;\n\n\n\n问题：解决like’%字符串%’索引不被使用的方法？\na）使用覆盖索引，查询字段必须是建立覆盖索引字段\n1EXPLAIN SELECT name,age,position FROM employees WHERE name like &#x27;%Lei%&#x27;;\n\n\n\nb）如果不能使用覆盖索引则可能需要借助搜索引擎\n9.字符串不加单引号索引失效12EXPLAIN SELECT * FROM employees WHERE name = &#x27;1000&#x27;;EXPLAIN SELECT * FROM employees WHERE name = 1000;\n\n\n\n10.少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化1EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27; or name = &#x27;HanMeimei&#x27;;\n\n\n\n11.范围查询优化给年龄添加单值索引\n1ALTER TABLE `employees` ADD INDEX `idx_age` (`age`) USING BTREE ;\n\n1explain select * from employees where age &gt;=1 and age &lt;=2000;\n\n\n\n没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引\n优化方法：可以将大的范围拆分成多个小范围\n12explain select * from employees where age &gt;=1 and age &lt;=1000;explain select * from employees where age &gt;=1001 and age &lt;=2000;\n\n\n\n还原最初索引状态\n1ALTER TABLE `employees` DROP INDEX `idx_age`;\n\n\n\n12-- mysql5.7关闭ONLY_FULL_GROUP_BY报错select version(), @@sql_mode;SET sql_mode=(SELECT REPLACE(@@sql_mode,&#x27;ONLY_FULL_GROUP_BY&#x27;,&#x27;&#x27;));\n\n","slug":"Explain详解与索引最佳实践","date":"2022-12-23T06:11:54.000Z","categories_index":"Mysql","tags_index":"Explain,Mysql,索引,Mysql优化","author_index":"Weiba"},{"id":"15601dddd5cc4a20478d4adb8f79cdea","title":"Windows Mysql 安装","content":"mysql 安装基础配置\n官网下载: Download MySQL Community Server, 选好版本点击 download, 新页面点击No thanks, just start my download., 不注册直接下载\n下载完成后解压, 进入 mysql 根目录创建配置文件: my.ini, 现在都没有默认的配置文件 123456789101112131415[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[mysqld]#设置3306端口port=3306# 设置mysql的安装目录basedir=C:\\\\Users\\\\xiaow\\\\Documents\\\\mysql-5.7.27-winx64datadir=C:\\\\Users\\\\xiaow\\\\Documents\\\\mysql-5.7.27-winx64\\\\data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB\n配置环境变量  \n在用户环境变量中新建, 变量名为MYSQL, 变量值为C:\\Users\\xiaow\\Documents\\mysql-5.7.27-winx64\\ (mysql目录)\n在用户变量的PATH中添加 %MySQL%\\bin\n\n\n\n安装配置服务\n管理员模式运行 cmd, 进入 mysql 目录下的 bin 目录, 依次执行\nC:\\Users\\xiaow\\Documents\\mysql-5.7.27-winx64\\bin\\\n安装服务: mysqld -install | 卸载服务: mysqld -remove\n初始化 mysql : mysqld --initialize , 注意不要手动创建 data \n启动: net start mysql | 关闭: net stop mysql\n\n\n设置密码\n停止 mysql: net stop mysql\n启动无密码模式 mysql : mysqld --skip-grant-tables, 注意执行完毕会无法输入任何字符\n开一个新的 cmd 窗口, 无密码登陆: mysql -u root\n刷新权限: flush privileges;\n设置密码: grant all privileges on *.* to &#39;root&#39;@&#39;localhost&#39; identified by &#39;password&#39; with grant option;\n刷新权限更新 root 密码: flush privileges;\n退出: exit\n返回上一个 cmd, ctrl+c 停止无密码模式, 正常启动即可\n登陆 mysql : mysql -u root -h 127.0.0.1 -ppassword\n\n\n\n","slug":"Windows Mysql 安装","date":"2022-12-23T06:11:01.000Z","categories_index":"Windows","tags_index":"Mysql,Windows","author_index":"Weiba"},{"id":"d3578d047ef4a994d94617bf58a5ddea","title":"cmd 命令","content":"\n查看文件效验码\n123certutil -hashfile filename MD5certutil -hashfile filename SHA1certutil -hashfile filename SHA256\n\n查看占用端口进程\n1netstat -ano | findstr &quot;9559&quot;\n\n杀进程\n1taskkill /f /pid 28492\n\n批量杀进程\n1taskkill /F /im frontpg.exe\n\n生成目录接口样式1.tree 默认显示文件夹\n\n\n2.tree &#x2F;f 显示文件\n\n\n3.tree &#x2F;a 显示目录状态 有文件的为+\n","slug":"Cmd 命令","date":"2022-12-23T06:10:02.000Z","categories_index":"cmd","tags_index":"常用命令,cmd","author_index":"Weiba"},{"id":"461f09e8a9ebcf7e8b3c5503ee4a2495","title":"Python 错误记录","content":"\n编码错误, 头部添加:\n  1# -*- coding: utf-8 -*\nNo module named ‘xxx’, 找不到模块, 安装即可\n  1pip install matplotlib\n\npip install -U scikit-image\n\n\n","slug":"Python 错误记录","date":"2022-12-23T06:09:15.000Z","categories_index":"Python","tags_index":"Python,错误记录","author_index":"Weiba"},{"id":"839853fd0791fa00d2de2eab05708e12","title":"Angular中使用ngx-translate国际化","content":"12.Angular中使用ngx-translate国际化1. 下载依赖12345npm install @ngx-translate/core --save-- 如果需要指定翻译文件,则还需下载npm install @ngx-translate/http-loader --save\n\n2. 导入TranslateModule模块1234567891011121314151617181920212223import &#123; TranslateLoader, TranslateModule &#125; from &#x27;@ngx-translate/core&#x27;;import &#123; TranslateHttpLoader &#125; from &#x27;@ngx-translate/http-loader&#x27;;@NgModule(&#123;  declarations: [    AppComponent  ],  imports: [    ...    TranslateModule.forRoot(&#123;      loader: &#123;        provide: TranslateLoader,        useFactory:  (http: HttpClient) =&gt; new TranslateHttpLoader(http, &#x27;./assets/i18n/&#x27;, &#x27;.json&#x27;), //指定加载的配置文件        deps: [HttpClient]      &#125;,      defaultLanguage: &#x27;tw&#x27; //指定默认语系    &#125;)  ],  providers: [    &#123; provide: MAT_DIALOG_DATA, useValue: &#123;&#125; &#125;  ],  bootstrap: [AppComponent]&#125;)\n\n\n\n3. 使用1234567891011121314在html中使用,可以通过指定或者管道&lt;span (click)=&quot;editChannel()&quot;&gt;&#123;&#123;&#x27;edit&#x27;|translate&#125;&#125;&lt;/span&gt;//translate:params,params是参数,key与的翻译文件中的一致&lt;span [innerHTML]=&quot;&#x27;liveChannel.pageTips&#x27;|translate:&#123;&#x27;0&#x27;:totalCount&#125;&quot;&gt;&lt;/span&gt;在ts中使用,需要引入TranslateServiceimport &#123; TranslateService &#125; from &#x27;@ngx-translate/core&#x27;;constructor(public translate: TranslateService) &#123;&#125;//翻译多语言this.translate.instant(&#x27;liveChannel.selectOneTip&#x27;)\n\n\n\n\n\n\n\n\n\n\n官网地址\n4. ts中使用translate.instant未初始化在AppModule中添加:\n123456789101112131415161718192021222324providers: [&#123;    provide: APP_INITIALIZER,    useFactory: appInitializerFactory,    deps: [TranslateService, Injector],    multi: true  &#125;]export function appInitializerFactory(translate: TranslateService, injector: Injector) &#123;  return () =&gt; new Promise&lt;any&gt;((resolve: any) =&gt; &#123;    // console.log(&#x27;appInitializerFactory--&#x27;);    const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve(null));    locationInitialized.then(() =&gt; &#123;      const langToSet = environment.locale;      translate.setDefaultLang(environment.locale);      translate.use(langToSet).subscribe(() =&gt; &#123;        // console.info(`Successfully initialized &#x27;$&#123;langToSet&#125;&#x27; language.&#x27;`);      &#125;, err =&gt; &#123;        // console.error(`Problem with &#x27;$&#123;langToSet&#125;&#x27; language initialization.&#x27;`);      &#125;, () =&gt; &#123;        resolve(null);      &#125;);    &#125;);  &#125;);&#125;\n\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@NgModule(&#123;  declarations: [    AppComponent  ],  imports: [    BrowserModule,    AppRoutingModule,    BrowserAnimationsModule,    FormsModule,    ReactiveFormsModule,    HttpClientModule,    TranslateModule.forRoot(&#123;      loader: &#123;        provide: TranslateLoader,        useFactory: (http: HttpClient) =&gt; new TranslateHttpLoader(http, &#x27;./assets/i18n/&#x27;, &#x27;.json&#x27;),        deps: [HttpClient]      &#125;,      defaultLanguage: environment.locale    &#125;),  ],  providers: [&#123;    provide: APP_INITIALIZER,    useFactory: appInitializerFactory,    deps: [TranslateService, Injector],    multi: true  &#125;],  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;export function appInitializerFactory(translate: TranslateService, injector: Injector) &#123;  return () =&gt; new Promise&lt;any&gt;((resolve: any) =&gt; &#123;    // console.log(&#x27;appInitializerFactory--&#x27;);    const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve(null));    locationInitialized.then(() =&gt; &#123;      const langToSet = environment.locale;      translate.setDefaultLang(environment.locale);      translate.use(langToSet).subscribe(() =&gt; &#123;        // console.info(`Successfully initialized &#x27;$&#123;langToSet&#125;&#x27; language.&#x27;`);      &#125;, err =&gt; &#123;        // console.error(`Problem with &#x27;$&#123;langToSet&#125;&#x27; language initialization.&#x27;`);      &#125;, () =&gt; &#123;        resolve(null);      &#125;);    &#125;);  &#125;);&#125;  ","slug":"Angular中使用ngx-translate国际化","date":"2022-12-23T06:01:52.000Z","categories_index":"Angular","tags_index":"Angular,ngx-translate","author_index":"Weiba"},{"id":"4a2146c891a4987dfd157bfd8404c794","title":"Angular中的异步请求","content":"6.Angular中的异步请求1. RxJs介绍\n\n\n\n\n\n\n\n\n Angular中集成了RxJs来操作异步.\n1234567891011121314151617181920212223242526272829303132333435363738394041常见的异步编程的几种方法:    1. 回调函数    2. 事件监听/发布订阅    3. Promise(来自ES6)    4. RxJs    1.Promise使用demo:    - Promise中resolve代表成功回调,reject代表失败回调    funtion getPromiseData()&#123;        return new Promise((resolve,reject)=&gt;&#123;            //通过resolve(data),传递结果            setTimeout(()=&gt;&#123;                var name = &#x27;张三&#x27;;                resolve(name);            &#125;,1000);           &#125;);    &#125;        - 外部获取Promise数据    var promiseData = getPromiseData().then((data)-&gt;&#123;        console.log(data);    &#125;)    2.使用rxJs获取异步数据    - 首先需要引入Observable    import &#123;Observable&#125; from &#x27;rxjs&#x27;;        - 通过observer.next(data),传递结果,observer.error(data)来处理异常    function getRxJsData()&#123;        return new Observable((observer)-&gt;&#123;            setTimeout(()=&gt;&#123;                var name = &#x27;张三&#x27;;                observer.next(name);            &#125;,1000);        &#125;);    &#125;                 - 外部获取RxJs数据    var rxJsData = getRxJsData().subscribe((data)-&gt;&#123;        console.log(data);    &#125;);\n\n2. RxJs与Promise的区别1234567891011121314151617181920RxJs比Promise功能更加强大1. RxJs可以通过unsubscribe(),来中止异步操作,而Promise不行2. RxJs执行的异步方法可以多次执行(如果异步方法是个定时循环的),而Promise不行3. RxJs还提供了很多便利的工具类(map,filter,类似java8)    import &#123;map,filter&#125; from &#x27;rxjs/operators&#x27;;        var stream = this.getRxJsData().pipe(        filter((value)=&gt;&#123;            if(value%2 ==0)&#123;                return true;            &#125;          &#125;),        map((value)=&gt;&#123;            return value * value;        &#125;)    ).subscribe((data)=&gt;&#123;        console.log(data);    &#125;);    \n\n3. Angular中数据交互12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591. 引入httpClientModule模块    import &#123;HttpClientModule&#125; from &#x27;@angular/common/http&#x27;;    2. 依赖注入,在app.module.ts中注入模块    @ngModule(&#123;        ...        imports:[            BrowserModule,            HttpClientModule        ]        ...    &#125;)    3. 组件内引入httpClient(作为一个服务引入,因此需要在构造方法内注入)    import &#123;HttpClient&#125; from &#x27;@angular/common/http&#x27;;        export class xxx implements OnInit&#123;        constructor(public http:HttpClient)&#123;            ...        &#125;    &#125;    4. 请求数据    - get请求:         this.http.get(apiUrl).subscribe((response)=&gt;&#123;            ...            &#125;)        - post请求:         需要设置请求头,因此需要额外引入HttpHeaders        import &#123;HttpClient,HttpHeaders&#125; from &#x27;@angular/common/http&#x27;;                设置请求头        const httpOptions = &#123;headers: new HttpHeader(&#123;&#x27;content-Type&#x27;:&#x27;application/json&#x27;&#125;)&#125;;                请求数据        this.post(apiUrl,data,httpOptions).subscribe((response)=&gt;&#123;            ...            &#125;)        5. 对jsonp的支持    - 首先需要在app.module.ts中引入jsonp模块 HttpClientJsonpModule,并注入        import &#123;HttpClientModule,HttpClientJsonpModule&#125; from &#x27;@angular/common/http&#x27;;                @ngModule(&#123;        ...        imports:[            BrowserModule,            HttpClientModule,            HttpClientJsonpModule        ]        ...    &#125;)        - 使用jsonp(必须得后台支持)        this.http.jsonp(api,&#x27;callback&#x27;).subscribe((response)=&gt;&#123;            ...        &#125;)        ","slug":"Angular中的异步请求","date":"2022-12-23T05:59:29.000Z","categories_index":"Angular","tags_index":"Angular,异步请求","author_index":"Weiba"},{"id":"136241e32e8e84355f6f361b29867966","title":"Web-CSS收藏","content":"水平居中参考自: css的div垂直居中的方法，百分比div垂直居中\nHTML:\n123&lt;div class=&quot;father&quot;&gt;\t&lt;div class=&quot;son&quot;&gt;未查询到模板信息, 请先添加模板!&lt;/div&gt;&lt;/div&gt;\n\nCSS:\n1234567891011121314151617.father &#123;\tposition: fixed;\twidth: 100%;\theight: 100%;\ttop: 0;\tleft: 0;&#125;.son &#123;\tposition: absolute;\tleft: 0;\tbottom: 0;\tright: 0;\theight: 50%;\ttext-align: center;\tcolor: red;&#125;\n\n隐藏滚动条Chrome 和 Safari :\n1.element::-webkit-scrollbar &#123; width: 0 !important &#125;\nIE 10+ :\n1.element &#123; -ms-overflow-style: none; &#125;\nFirefox :\n1.element &#123; overflow: -moz-scrollbars-none; &#125;","slug":"Web-CSS 收藏","date":"2022-12-23T05:46:48.000Z","categories_index":"CSS","tags_index":"Web,CSS","author_index":"Weiba"},{"id":"98b4802958cdc7471116dc66deea6244","title":"使用 jsonp 读取本地文件并解决跨域问题","content":"12345&lt;script type=&quot;text/javascript&quot;&gt;     var knowledgeData = &#x27;&#x27;;    //JS代码就一个方法 function train(result) &#123; knowledgeData = result; &#125; &lt;/script&gt; &lt;script src=&quot;local.json?callback=train&quot;&gt;&lt;/script&gt;\n\n","slug":"Web-使用 jsonp 读取本地文件并解决跨域问题","date":"2022-12-23T05:41:50.000Z","categories_index":"Web","tags_index":"jsonp,跨域","author_index":"Weiba"},{"id":"7727f159ff7d60df4e6ab3417172c87a","title":"Android adb shell 命令","content":"pm (Package Manager)adb shell pm list packages\nkeyevent of keyCodeadb shell input keyevent 182\n\n\n\nkeycode\n含义\n\n\n\n3\nHOME 键\n\n\n4\n返回键\n\n\n5\n打开拨号应用\n\n\n6\n挂断电话\n\n\n24\n增加音量\n\n\n25\n降低音量\n\n\n26\n电源键\n\n\n27\n拍照（需要在相机应用里）\n\n\n64\n打开浏览器\n\n\n82\n菜单键\n\n\n85\n播放&#x2F;暂停\n\n\n86\n停止播放\n\n\n87\n播放下一首\n\n\n88\n播放上一首\n\n\n122\n移动光标到行首或列表顶部\n\n\n123\n移动光标到行末或列表底部\n\n\n126\n恢复播放\n\n\n127\n暂停播放\n\n\n164\n静音\n\n\n176\n打开系统设置\n\n\n187\n多任务\n\n\n207\n打开联系人\n\n\n208\n打开日历\n\n\n209\n打开音乐\n\n\n210\n打开计算器\n\n\n220\n降低屏幕亮度\n\n\n221\n提高屏幕亮度\n\n\n223\n系统休眠\n\n\n224\n点亮屏幕\n\n\n231\n打开语音助手\n\n\n276\n如果没有 wakelock 则让系统休眠\n\n\n","slug":"Android adb shell 命令","date":"2022-12-23T05:40:57.000Z","categories_index":"Android","tags_index":"adb,Android,Shell","author_index":"Weiba"},{"id":"2d77fc843e6a4b44f155d2170280baf0","title":"ES 随机查询","content":"根据官方文档使用随机评分查询, 随机因子设置为当前时间, 即可实现指定条件的随机数据查询.\n参考文档:\n\n\n\n\n\n\n\n\n\nELK第七篇:spring-boot-starter-data-elasticsearch使用es官方文档-随机评分\nes 随机查询查询语句:\n12345678910111213141516171819202122232425262728293031323334&#123;  &quot;query&quot;: &#123;    &quot;function_score&quot;: &#123;      &quot;query&quot;: &#123;        &quot;bool&quot;: &#123;          &quot;must&quot;: [            &#123;              &quot;term&quot;: &#123;                &quot;typeCode&quot;: &quot;01&quot;              &#125;            &#125;,            &#123;              &quot;term&quot;: &#123;                &quot;gradeCode&quot;: &quot;3101&quot;              &#125;            &#125;          ],          &quot;must_not&quot;: [],          &quot;should&quot;: []        &#125;      &#125;,      &quot;functions&quot;: [        &#123;          &quot;random_score&quot;: &#123;            &quot;seed&quot;: &quot;15:38:48&quot;          &#125;        &#125;      ],      &quot;score_mode&quot;: &quot;sum&quot;    &#125;  &#125;,  &quot;size&quot;: 1,  &quot;from&quot;: 0&#125;\n\nJava 实现maven 依赖:\n123456789101112&lt;dependency&gt;\t  &lt;groupId&gt;io.searchbox&lt;/groupId&gt;\t  &lt;artifactId&gt;jest&lt;/artifactId&gt;\t  &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;\t\tspring-boot-starter-data-elasticsearch\t&lt;/artifactId&gt;&lt;/dependency&gt;\n\nspring boot 配置:\n1234567891011spring:  elasticsearch:    jest:      uris: http://xxxx:9200      username: xxx      password: xxx      read-timeout: 20000      connection-timeout: 20000    content:      index: xxx    enable: true\n\ntest code:\n123456789101112131415161718192021222324252627282930@Autowiredpublic JestClient jestClient;\tpublic List&lt;EsInfoPO&gt; recommendationQuestion(Integer count) &#123;\tList&lt;EsInfoPO&gt; retList = new ArrayList&lt;EsInfoPO&gt;();\tFunctionScoreQueryBuilder functionScoreQueryBuilder =\t\t\tQueryBuilders.functionScoreQuery(\t\t\t\t\tboolQuery().must(QueryBuilders.matchQuery(&quot;typeCode&quot;, &quot;01&quot;)), ScoreFunctionBuilders.randomFunction(System.currentTimeMillis()));\tSearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\tsearchSourceBuilder.query(functionScoreQueryBuilder).size(count);\tSearch search = new Search.Builder(searchSourceBuilder.toString()).addIndex(getIndexName()).addType(getTypeName()).build();\tSearchResult execute = null;\ttry &#123;\t\texecute = jestClient.execute(search);\t\tif (execute.isSucceeded()) &#123;\t\t\tList&lt;SearchResult.Hit&lt;EsInfoPO, Void&gt;&gt; hits = execute.getHits(getClazz());\t\t\tfor (Hit&lt;EsInfoPO, Void&gt; hit : hits) &#123;\t\t\t\tretList.add(hit.source);\t\t\t&#125;\t\t&#125;\t&#125; catch (Exception e) &#123;\t\te.printStackTrace();\t&#125;\treturn retList;&#125;","slug":"ES 随机查询","date":"2022-12-23T04:50:04.000Z","categories_index":"ES","tags_index":"ES,随机查询","author_index":"Weiba"},{"id":"e76e3ec505bc6c5905c40e8de4c802ac","title":"Arthas 常用命令","content":"Arthas 常用命令官方文档：Arthas 命令列表\n启动 Arthas12345wget https://alibaba.github.io/arthas/arthas-demo.jarjava -jar arthas-demo.jarcurl -O https://alibaba.github.io/arthas/arthas-boot.jarjava -jar arthas-boot.jar\n注意退出的时候要 stop, 用 quit 不会退出.\n开启日志默认情况下，该功能是关闭的，如果需要开启，请执行以下命令：\n12345$ options save-result true NAME         BEFORE-VALUE  AFTER-VALUE----------------------------------------save-result  false         trueAffect(row-cnt:1) cost in 3 ms.\n看到上面的输出，即表示成功开启该功能；\n日志文件路径: 结果会异步保存在：{user.home}&#x2F;logs&#x2F;arthas-cache&#x2F;result.log，请定期进行清理，以免占据磁盘空间\n输出指定数据: watch com.enableets.edu.assessment.framework.reportV2.factory.AbstractReportFactory dataSliceQuery &#39;&#123;params,returnObj&#125;&#39; -x 6 &gt; dataSliceQuery.txt\n文件会存储至 jar 包目录\nwatch\nwatch 依次参数：接口地址 方法名称 ognl表达式 观察模式(可不需要)\n\n打印方法第一个入参：\n  1watch com.test.xxx query &#x27;params[0]&#x27;\n\n打印入参和返回值\n  1watch com.xxx.Service xxxFunction &#x27;&#123;params,returnObj&#125;&#x27; -x 6\n\n如果入参是对象，打印的是对象地址，可通过参数名params[0].name或调用JSON转换成字符串，也可以使用-x 3(遍历属性深度层次数)\n  1watch com.test.xxx query &#x27;@com.alibaba.fastjson.JSON@toJSON(&#123;params[0]&#125;)[0]&#x27;\n  \n  1watch com.test.xxx query &#x27;&#123;params[0]&#125;&#x27; -b -x 3\n  \n\nSC\n查找 classLoaderHash   12# 随便找一个实例即可获取 classLoaderHashsc -d com.test.xxx.util.BeanUtils | grep classLoaderHash\n\nognl可通过 ognl 表达式执行某个静态方法\n\n修改某个对象的 debug 级别  1ognl -c 5b2133b1 &#x27;@com.test.xxx.service.CommCacheDataService@LOGGER.setLevel(@ch.qos.logback.classic.Level@INFO)&#x27;\n修改全局的 debug 级别  1ognl -c 5b2133b1 &#x27;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@INFO)&#x27;\n\n","slug":"Arthas 常用命令","date":"2022-12-23T04:17:53.000Z","categories_index":"Arthas","tags_index":"常用命令,Arthas","author_index":"Weiba"},{"id":"444a9230e1bb32e21e783ab2e50b70d6","title":"Android 环境安装","content":"Android SDK 安装新建SDK文件夹并加入环境变量\nSDK主目录：C:\\Users\\wb\\Documents\\Android\\Android-SDK\n命令行工具：C:\\Users\\wb\\Documents\\Android\\Android-SDK\\cmdline-tools\nSDK 工具文件目录：C:\\Users\\wb\\Documents\\Android\\Android-SDK\\platform-tools\n模拟器工具文件目录：C:\\Users\\wb\\Documents\\Android\\Android-SDK\\emulator\nSDK 工具文件目录：C:\\Users\\wb\\Documents\\Android\\Android-SDK\\tools\nSDK 工具文件目录：C:\\Users\\wb\\Documents\\Android\\Android-SDK\\tools\\bin\n\n系统环境变量新增：1.变量名：ANDROID_SDK_ROOT，值：C:\\Users\\wb\\Documents\\Android\\Android-SDK2.变量名：REPO_OS_OVERRIDE，值：windows\n系统环境变量PATH添加1.%ANDROID_SDK_ROOT%\\cmdline-tools\\bin2.%ANDROID_SDK_ROOT%\\platform-tools\nAndroid 命令行工具安装打开 https://developer.android.google.cn/studio?hl=zh-cn#downloads, 找到 Command-line tools only 下载并解压到 %ANDROID_SDK_ROOT%\\cmdline-tools 目录\n通过cmdline-tools安装SDK及调试工具包\n\n\n\n\n\n\n\n\nsdkmanager命令行使用说明：https://developer.android.google.cn/studio/command-line/sdkmanager?hl=zh-cn确定安卓api等级：https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element?hl=zh-cn\nsdkmanager\nsdkmanager --list: 查看SDK列表, Flutter 支持API 16 (Android 4.1) 及更高的版本\nsdkmanager &quot;platforms&quot; &quot;platforms;android-23&quot; build-tools;30.0.3：安装SDK及调试包\nsdkmanager &quot;system-images;android-27;google_apis_playstore;x86&quot; 安装模拟器系统包\nsdkmanager &quot;extras;intel;Hardware_Accelerated_Execution_Manager&quot; 安装模拟器依赖，打开sdk目录的extras\\intel\\Hardware_Accelerated_Execution_Manager\\haxm-7.6.5-setup.exe\nemulator.exe -list-avds 查看已创建模拟器\nemulator  -help-virtual-device 模拟器创建帮助\nandroid create avd -n &lt;name&gt; -t 1 创建模拟器，没有删除命令，删除直接删除C:\\Users\\wb\\.android\\avd下的文件。\n\n对应版本12345678910111213141516171819202122232425262728293031323334353637Android 13\t33\tTIRAMISU\t平台亮点Android 12\t32\tS_V2\t平台亮点            31\tS\t平台亮点Android 11\t30\tR\t平台亮点Android 10\t29\tQ\t平台亮点Android 9\t28\tP\t平台亮点Android 8.1\t27\tO_MR1\t平台亮点Android 8.0\t26\tO\t平台亮点Android 7.1.1Android 7.1\t25\tN_MR1\t平台亮点Android 7.0\t24\tN\t平台亮点Android 6.0\t23\tM\t平台亮点Android 5.1\t22\tLOLLIPOP_MR1\t平台亮点Android 5.0\t21\tLOLLIPOPAndroid 4.4W\t20\tKITKAT_WATCH\t仅限 KitKat for WearablesAndroid 4.4\t19\tKITKAT\t平台亮点Android 4.3\t18\tJELLY_BEAN_MR2\t平台亮点Android 4.2、4.2.2\t17\tJELLY_BEAN_MR1\t平台亮点Android 4.1、4.1.1\t16\tJELLY_BEAN\t平台亮点Android 4.0.3、4.0.4\t15\tICE_CREAM_SANDWICH_MR1\t平台亮点Android 4.0、4.0.1、4.0.2\t14\tICE_CREAM_SANDWICHAndroid 3.2\t13\tHONEYCOMB_MR2\tAndroid 3.1.x\t12\tHONEYCOMB_MR1\t平台亮点Android 3.0.x\t11\tHONEYCOMB\t平台亮点Android 2.3.4Android 2.3.3\t10\tGINGERBREAD_MR1\t平台亮点Android 2.3.2Android 2.3.1Android 2.3\t9\tGINGERBREADAndroid 2.2.x\t8\tFROYO\t平台亮点Android 2.1.x\t7\tECLAIR_MR1\t平台亮点Android 2.0.1\t6\tECLAIR_0_1Android 2.0\t5\tECLAIRAndroid 1.6\t4\tDONUT\t平台亮点Android 1.5\t3\tCUPCAKE\t平台亮点Android 1.1\t2\tBASE_1_1\tAndroid 1.0\t1\tBASE\t","slug":"Android 环境安装","date":"2022-12-23T03:41:02.000Z","categories_index":"Android","tags_index":"Android,环境","author_index":"Weiba"},{"id":"3af632062b68344c21d68ab605e964ba","title":"GetX入门","content":"GetX常用APIGetBuild, GetX, Obx 使用场景GetBuild: 性能为主使用这个，他的刷新由我们自己通过updata方法更新。GetX: 项目中只有一个地方使用了Controller时使用，量比较少的时候，因为他的更新时基于流的，每次更新都会刷新所有引用的地方。Obx: 如果项目中单个的东西比较多，使用Obx，但是Obx是每秒都在执行的，相当于有监听器。\nGet-CliGet 脚手架工具\n安装1flutter pub global activate get_cli\n添加环境变量: %FLUTTER_SDK_ROOT%\\.pub-cache\\bin\n常用命令\nget create project:my_getx_demo1\nGetX Pattern:代码风格，MVC结构，客户端模式\nCLEAN:代码风格，后端服务模式\n\n\nget create page:home\nGet.find()\n\nBindingBinding是用来引入依赖的，默认都是懒加载。可以在dependencies方法中引入其他控制器。\n","slug":"GetX入门","date":"2022-12-23T03:40:19.000Z","categories_index":"Flutter","tags_index":"Flutter,GetX","author_index":"Weiba"},{"id":"e3a8b83de93f0270e310ae88e6f2c6ef","title":"Flutter 错误记录","content":"错误记录Android sdkmanager not found其实就是cmdline-tools没装好。使用sdkmanager --install &quot;cmdline-tools;latest&quot;安装一下就行了。\nRunning Gradle task ‘assembleDebug’ 卡住先停止运行，然后在项目中根目录运行 flutter run -v 即可看到卡在哪里了。\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/houor/article/details/115371120 Gradle 更换国内镜像\nYou need Java 11 or higher to build your app with this version of Gradle.使用指定JDK，在项目的android/gradle.properties添加org.gradle.java.home=D:/resource/JAVA/JDK/jdk-11.0.2属性。\n模板位置：D:\\resource\\Flutter\\Flutter-SDK\\packages\\flutter_tools\\templates\\module\\android\\gradle\\gradle.properties.tmpl\n‘pub’ 不是内部或外部命令，也不是可运行的程序pub独立在2.10后已弃用，使用dart pub or flutter pub 代替。\nget create project:my_project_1 卡住get-cli 1.7.1 版本bug, ctrl+z跳过\nEXCEPTION CAUGHT BY SVG 无法加载SVG图片\n\n\n\n\n\n\n\n\n来源：https://stackoverflow.com/questions/61202925/svgpicture-image-rendering-error-in-flutter\nsvg文件格式有问题，可使用这个网站https://jakearchibald.github.io/svgomg/导入后再导出。\nA RenderFlex overflowed by 19 pixels on the bottom. 键盘弹出时报错元素被键盘顶起导致内容区溢出，使用SingleChildScrollView包裹即可，不需要滚动的设置属性：physics: const NeverScrollableScrollPhysics(),\nfluttertoast 无法在windows端使用windows端适配比较麻烦，更换为overlay_support库\nConnectivity().checkConnectivity() 无法在windows端使用connectivity更换为connectivity_plus库\ncanLaunchUrl(uriTemp) 在Android端大于API 30时 一直返回false在Android端大于API 30时对权限做了限制，必须在Android中添加以下配置：\n123456789101112131415&lt;!-- Provide required visibility configuration for API level 30 and above --&gt;&lt;manifest&gt;&lt;queries&gt;  &lt;!-- If your app checks for SMS support --&gt;  &lt;intent&gt;    &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;    &lt;data android:scheme=&quot;sms&quot; /&gt;  &lt;/intent&gt;  &lt;!-- If your app checks for call support --&gt;  &lt;intent&gt;    &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;    &lt;data android:scheme=&quot;tel&quot; /&gt;  &lt;/intent&gt;&lt;/queries&gt;&lt;/manifest&gt;\n\n HandshakeException: Connection terminated during handshake","slug":"Flutter 错误记录","date":"2022-12-23T03:39:12.000Z","categories_index":"Flutter","tags_index":"经验,Flutter,异常记录","author_index":"Weiba"},{"id":"def8fa0ed0d9f0546b5cae7e4fdfe4f3","title":"Flutter 环境安装","content":"Android SDK 及环境配置按照Android环境安装文档来就行。\n环境变量FLUTTER_SDK_ROOT:D:\\resource\\Flutter\\Flutter-SDKPath:%FLUTTER_SDK_ROOT%\\bin;%FLUTTER_SDK_ROOT%\\bin\\cache\\dart-sdk\\bin;%FLUTTER_SDK_ROOT%\\.pub-cache\\bin\n环境检测flutter doctor -v 查看环境详情\n","slug":"Flutter 环境安装","date":"2022-12-23T03:38:23.000Z","categories_index":"Flutter","tags_index":"环境,Flutter","author_index":"Weiba"},{"id":"d4fe6d958a1faa6764824e752c175fad","title":"xx视频APP API破解","content":"\n\n\n\n\n\n\n\n\nxx视频是一个在线观看视频的APP, 速度非常快, 清晰度也够看, 就是有点瑟瑟的广告, 今天闲着没事我瞅瞅他的api, 看能不能白嫖一波.\nAndroid HttpCanary 抓包.配置好 HttpCanary 后直接抓xx视频的包, 可以获取到 API 的请求情况, 但是他的 response 是经过加密的. \n\n\n\n\n\n\n那接下来只能通过反编译 APP 来看看能不能找到解析方法.\n反编译APK直接丢进 jadx-gui, 很幸运, 这个 APP 好像只做了混淆处理, 直接就成功了.\n\n\n定位请求全局搜索 get_info, 直接定位到 BrowserApiService 类, 通过这个类可以获取到所有的接口了.\n\n\n\n\n\n\n右键查找用例, \n\n\n\n\n好像看不出什么, 不过我看了下, 所有的接口返回的数据都是加密的, 所以估计是哪里统一做了处理. \n看下请求接口上有一个 @FormUrlEncoded 注解, 咱们来搜索一下看看是什么类库的即可进一步追踪. \n\n\n然后搜索 retrofit 解密\n\n\n\n\n\n\n大概可以知道这个类库解密一般是通过添加 Interceptor 完成的. 接下来我们只需要找到这个 Interceptor  就可以了. \n定位 Interceptor全局搜索 .addInterceptor , 这个是 retrofit 添加 Interceptor 的接口.\n\n\n第一个就有收获了. \n\n\n1234OkHttpClient.Builder addInterceptor = RetrofitUrlManager.getInstance().with(new OkHttpClient.Builder()).cookieJar(new CookieJarImpl(new PersistentCookieStore(f4030d))).addInterceptor(new CacheInterceptor(f4030d)).addInterceptor(new BaseInterceptor(map)).sslSocketFactory(b()).hostnameVerifier(new c(null)).addInterceptor(new a(this)).addInterceptor(new LoggingInterceptor.Builder().loggable(false).setLevel(Level.BASIC).log(4).request(&quot;Request&quot;).response(&quot;Response&quot;).addHeader(&quot;log-header&quot;, &quot;I am the log request header.&quot;).build());        TimeUnit timeUnit = TimeUnit.SECONDS;        f4031e = addInterceptor.connectTimeout(10L, timeUnit).writeTimeout(10L, timeUnit).proxy(Proxy.NO_PROXY).connectionPool(new ConnectionPool(8, 15L, timeUnit)).build();        f4032f = new Retrofit.Builder().client(f4031e).addConverterFactory(GsonConverterFactory.create()).addCallAdapterFactory(RxJava2CallAdapterFactory.create()).baseUrl(str).build();\n查看解码实现response 的处理一般看最后一个 Interceptor, 直接进去看实现, 找到 chain.proceed(request) 类似获取 response 的处理:\n\n\n看上去这个 c2 就是我们需要的解码结果, 点进去看看.\n\n\n\n\n\n\nJava 复现测试还好没有像智能公交那样使用 lib 库,  直接java copy 一下 ok 啦 ~~ \n\n\n \n\n咱们PP-Utils 又添加一个新能力了, 嘿嘿 \n接下来就是复刻他的请求了~~~\n后续这个APP关键的视频部分通过lib加壳了, 什么时候有时间再搞搞脱壳 哈哈\n","slug":"XX视频API破解","date":"2022-12-22T10:51:51.000Z","categories_index":"反编译","tags_index":"Android,破解,API,视频","author_index":"Weiba"},{"id":"e25e60e08cca60aa35b3d88aee490c5b","title":"手写代码模拟Spring底层原理","content":"通过 Spring 核心原理解析已经大致了解了 Bean 的创建过程, 今天来尝试手写实现一下.\n实现目标\n可以通过注解注入 Bean\n实现通过容器的 getBean 方法获取 Bean 实例\n单例和多例 bean 的实现\nCGLIB动态代理Bean 的实现\n\n创建基本的类和注解\n在 com.spring 包下分别创建 WbAnnotationConfigApplicationContent, @ComponentSacn,  @Component, @Autowired 注解\n123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.spring;/** * @author wb **/public class WbAnnotationSpringApplication &#123;    public WbAnnotationSpringApplication(Class clazz) &#123;    &#125;    public Object getBean(String beanName) &#123;        return null;    &#125;&#125;package com.spring;/** * @author wb **/public @interface ComponentScan &#123;    String value() default &quot;&quot;;&#125;package com.spring;public @interface Component &#123;    String value() default &quot;&quot;;&#125;package com.spring;public @interface Autowired &#123;    String value() default &quot;&quot;;&#125;\n\n在 con.wb 下创建我们自己代码 AppConfig ,UserInfoService , OrderInfoService, WbTest\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.wb;import com.spring.WbAnnotationSpringApplication;/** * @author wb **/public class WbTest &#123;    public static void main(String[] args) &#123;        WbAnnotationSpringApplication context = new WbAnnotationSpringApplication(AppConfig.class);        UserInfoService userInfoService = (UserInfoService) context.getBean(&quot;userInfoService&quot;);        userInfoService.test();    &#125;&#125;package com.wb.service;@Componentpublic class UserInfoService &#123;    @Autowired    private OrderInfoService orderInfoService;    public void test()&#123;        System.out.println(orderInfoService);    &#125;&#125;package com.wb.service;public class OrderInfoService &#123;&#125;package com.wb;/** * @author wb **/@ComponentScanpublic class AppConfig &#123;&#125;\n\n项目初始化完毕.\n分析 Spring 中的 AnnotationSpringApplication 做了什么?\n通过 AppConfig 类上的 @ComponentScan 注解扫描其 value 值中的包.\n将扫描包中包含 @Component 注解的类通过一定的方法注入到 Spring 容器中.\n\n… 待更新\n","slug":"Spring-手写代码模拟Spring底层原理","date":"2022-12-08T07:06:03.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"Weiba"},{"id":"d1e43acd29f91190a292b5c07c6764f5","title":"Flutter 开发技巧.md","content":"文档\nFlutter Getx Doc\nAPI Doc\n开源项目:flutter_bolg_manage\n《Flutter实战·第二版》\n\n沉浸式状态栏在main方法中添加：\n123456SystemChrome.setSystemUIOverlayStyle(    const SystemUiOverlayStyle(      statusBarColor: Colors.transparent,      statusBarBrightness: Brightness.light,    ),);\n\n内容居中先使用Center使x轴居中，再使用Column的mainAxisAlignment: MainAxisAlignment.center属性实现y轴居中。\n12345678910111213Scaffold(      appBar: AppBar(        title: const Text(&quot;New Page&quot;),        centerTitle: true,      ),      body: Center(          child: Column(        mainAxisAlignment: MainAxisAlignment.center,        children: [          Obx((() =&gt; Text(&quot;Get find Controller count: $&#123;controller.count&#125;&quot;))),        ],      )),    )","slug":"Flutter 开发技巧","date":"2022-11-24T03:37:28.000Z","categories_index":"Flutter","tags_index":"经验,Flutter","author_index":"Weiba"},{"id":"ef19428c70405b7c43ba604703e9e8a3","title":"Ubuntu 20.x 修改DNS配置","content":"\n\n\n\n\n\n\n\n\n家里部署了一台 Ubuntu, 发现 raw.githubusercontent.com 域名 DNS 竟然被污染了… 记录下一下, 20 的配置文件和以前不一样\n1. Ubuntu 18.04 LTS 及以上版本配置文件变更为：/etc/netplan/*.yaml。例如：\n12345678910# This is the network config written by &#x27;subiquity&#x27;network:  ethernets:    ens33:      dhcp4: true      nameservers:        addresses:          - 114.114.114.114          - 223.5.5.5  version: 2\n\n2. Ubuntu 18.04 LTS 以下版本主要修改两个文件。\n2.1 更新 resolv.conf首先修改文件：/etc/resolvconf/resolv.conf.d/base 文件，内容如下：\n12nameserver 114.114.114.114nameserver 223.5.5.5\n\n2.2 network&#x2F;interfaces然后修改文件：/etc/network/interfaces 文件，删除其中的 dns-nameservers 配置项：\n1234567891011121314151617# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto ens33#iface ens33 inet dhcpiface ens33 inet staticaddress 192.168.2.231netmask 255.255.255.0gateway 192.168.2.1#dns-nameservers 202.102.134.68 202.102.128.68\n\n然后重启 network 服务：/etc/init.d/networking restart ，这样就可以了。\n实际修改中，大部分服务器修改第一个就可以起效了，只有个别的需要修改两个。为了防止歧义，推荐两个都修改。\n","slug":"Ubuntu 20.x 修改DNS配置","date":"2022-04-23T05:31:07.000Z","categories_index":"Ubuntu","tags_index":"配置,Ubuntu","author_index":"Weiba"},{"id":"84c6604e94d88eec227a0b74aad54f6e","title":"Spring MVC","content":"Spring MVC 流程图\n","slug":"Spring-MVC","date":"2022-04-21T08:32:36.000Z","categories_index":"","tags_index":"Spring,MVC","author_index":"Weiba"},{"id":"e9adcbc8532fce70420313e9114122dd","title":"Java 排序","content":"通过指定 id 集排序在 select * from table_name where id in () 的时候，MySQL 会自动按主键自增排序，要是按IN中给定的顺序来取，必须按 Order by field() 来实现：\n1SELECT * from `models` where `id` in (111,222,333) order by field(id,111,222,333);\n\n但该排序效率较低，可直接在代码中使用 BeanComparator 和 FixedOrderComparator 来实现对指定 id 集排序\n12345public List&lt;XXX&gt; getXxxByIds(List&lt;String&gt; ids) &#123;    List&lt;XXX&gt; xXXs = xxxInfoDAO.selectByIds(ids);    xXXs.sort(new BeanComparator(&quot;id&quot;, new FixedOrderComparator(ids)));    return XXXs;&#125;\n","slug":"Java-排序","date":"2022-04-08T08:09:09.000Z","categories_index":"Java","tags_index":"排序","author_index":"Weiba"},{"id":"f4f28e159c970d8abf25ca9ece83bb73","title":"Spring AOP及事务原理","content":"相关笔记@EnableAspectJAutoProxy(exposeProxy=true) 开启动态代理的暴露，因为在 JDK 动态代理模式下，在方法中调用本类方法是无法再次走代理的，试用该注解可以将动态代理暴露到当前线程当中，在方法内需要再次走代理时通过 (XXXService)AopContext.currentProxy() 即可取出当前线程的动态代理对象，通过它调用本类方法即可再次走代理做增强操作\n","slug":"Spring-AOP及事务原理","date":"2022-04-07T02:59:57.000Z","categories_index":"Java","tags_index":"事务,AOP","author_index":"Weiba"},{"id":"cd2cde879fd4a7417d862451e6d3f44d","title":"Git 多用户配置","content":"\n\n\n\n\n\n\n\n\n公司部署了私有 GitLab, 在公司更新个人的 GitHub 项目的时候非常麻烦，好在 Git 是支持多用户的，记录一下。\n参考：\n\nGit 多用户配置 - 苍青浪\n在git-bash启动时启用SSH Agent | 工程师\n\n配置各环境秘钥对钥对的保存位置默认在 ~&#x2F;.ssh 目录下，使用一下命令生成\n123456ssh-keygen -t rsa -C “xxxx@gmail.com” # github邮箱# 按下 ENTER 键后，会有如下提示：# Generatingpublic/privatersa key pair.Enter fileinwhich to save the key (/Users/xxx/.ssh/id_rsa):# 为了和 GitLab 区分，这里重命名为 id_rsa_githubssh-keygen -t rsa -C “xxxx@xxx.com” # 公司邮箱# 重命名为 id_rsa_gitlab\n\n将生成的 _pub 后缀的公钥文件内容复制至 GitHub 和 GitLab 的  SSH Keys 中。\n添加到 SSH-Agent 中在上一步中，我们已经将公钥添加到了 GitHub  或者 GitLab  服务器上，我们还需要将私钥添加到本地中，不然无法使用。\n在终端执行: \n123eval &#x27;ssh-agent&#x27;ssh-add ~/.ssh/id_rsa_githubssh-add ~/.ssh/id_rsa_gitlab\n\n管理秘钥通过以上步骤，公钥、密钥分别被添加到 git 服务器和本地了。下面我们需要在本地创建一个密钥配置文件，通过该文件，实现根据仓库的 remote 链接地址自动选择合适的私钥。\n编辑 ~/.ssh 目录下的 config 文件, vim ~/.ssh/config\n123456789101112Host github.com    HostName github.com    User xxxx    IdentityFile ~/.ssh/id_rsa_github    HostkeyAlgorithms +ssh-rsa    PubkeyAcceptedKeyTypes +ssh-rsaHost gitlab-xxx.com    HostName gitlab-xxx.com    User xxxxxx    IdentityFile ~/.ssh/id_rsa_gitlab    HostkeyAlgorithms +ssh-rsa    PubkeyAcceptedKeyTypes +ssh-rsa\n\n测试：\n1234ssh -T git@github.comHi xxxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.ssh -T git@gitlab-xxx.comWelcome to GitLab, xxxxxx!\n\n仓库配置完成以上配置后，其实你已经基本完成了所有配置。分别进入附属于 GitHub 和 GitLab 的仓库，此时都可以进行 git 操作了。但是别急，如果你此时提交仓库修改后，你会发现提交的用户名变成了你的系统主机名。\n这是因为 git 的配置分为三级别，System —&gt; Global —&gt;Local。System 即系统级别，Global 为配置的全局，Local 为仓库级别，优先级是 Local &gt; Global &gt; System。\n因为我们并没有给仓库配置用户名，又在一开始清除了全局的用户名，因此此时你提交的话，就会使用 System 级别的用户名，也就是你的系统主机名了。\n因此我们需要为每个仓库单独配置用户名信息，假设我们要配置 Github 的某个仓库，进入该仓库后，执行：\n12git config --local user.name &quot;xxx&quot;git config --local user.email &quot;xx@gmail.com&quot;\n\n执行完毕后，通过以下命令查看本仓库的所有配置信息：\ngit config --local --list\n至此你已经配置好了 Local 级别的配置了，此时提交该仓库的代码，提交用户名就是你设置的 Local 级别的用户名了。\n添加 Git-Bash 启动脚本由于 ssh-agent 是存放在高速缓存中的，重启后添加的 ssh-add 就会失效，这里直接在 git-bash 的 bash_profile 中添加：\n123# windows默认会生成该文件test -f ~/.profile &amp;&amp; . ~/.profiletest -f ~/.bashrc &amp;&amp; . ~/.bashrc\n\n在 .bashrc 中添加：\n123eval `ssh-agent` &gt; /dev/nullssh-add ~/.ssh/id_rsa_github &gt; /dev/nullssh-add ~/.ssh/id_rsa_xc &gt; /dev/null\n\n每次启动 git-bash 都会自动启动并添加。\n不同目录配置不同的提交账号和邮箱先复制 C:\\Users\\xx 目录下的 git 默认配置.gitconfig 配置, 需要几个环境就复制几个, 重命名为: .gitconfig-wb, .gitconfig-xc.\n编辑: .gitconfig文件:\n12345[includeIf &quot;gitdir:code/xc/&quot;]   path = ./.gitconfig-xc[includeIf &quot;gitdir:code/weiba/&quot;]   path = ./.gitconfig-wb\n\n编辑: .gitconfig-xx文件:\n123[user]\tname = xx\temail = xxx@xx.com\n\n编辑: .gitconfig-wb文件:\n123[user]\tname = weiba\temail = xxxx@gmail.com\n","slug":"Git-多用户配置","date":"2022-04-06T03:01:39.000Z","categories_index":"Git","tags_index":"Git","author_index":"Weiba"},{"id":"78adcbdfdd6a623cd781ded6a00aa205","title":"Samba 服务","content":"问题记录无法直接打开 exe 文件在 /etc/samba/smb.conf 的 global 节点中添加 acl allow execute always = Yes后重启服务即可。\n","slug":"Samba 服务","date":"2022-04-03T05:06:49.000Z","categories_index":"Samba","tags_index":"Samba","author_index":"Weiba"},{"id":"02595caed2c9ad700f77441184d5f61b","title":"Windows Git 和 CMD 终端代理设置","content":"\n\n\n\n\n\n\n\n\n国内现在访问 git 速度太慢了，记录下配置的代理，来自 Windows git和cmd代理设置\n配置代理代理类型是 http 值为: http://127.0.0.1:7777, 为 SOCKS5 时值为: socks5://127.0.0.1:7777\nGit 代理临时代理:\n12export http_proxy=http://127.0.0.1:7777export https_proxy=http://127.0.0.1:7777\n\n永久代理:\n\n命令方式：\n12git config --global http.proxy http://127.0.0.1:7777git config --global https.proxy http://127.0.0.1:7777\n\n修改配置文件方式, 进入用户名根路径，找到 .gitconfig 文件，修改为：\n1234[http]proxy = http://127.0.0.1:7777[https]proxy = http://127.0.0.1:7777\n\n查看代理状态:\n12git config --get --global http.proxygit config --get --global https.proxy\n\n单独查看 socks5 代理模式情况:\n12git config --get --global http.proxy socks5git config --get --global https.proxy socks5\n\n取消代理:\n12git config --global --unset http.proxygit config --global --unset https.proxy\n\nCMD 代理临时代理：\n12set http_proxy=http://127.0.0.1:7777set https_proxy=http://127.0.0.1:7777\n\n永久代理：\n1netsh winhttp import proxy source=ie\n\n针对性代理，绕过本地请求：\n1netsh winhttp set proxy proxy-server=&quot;http=192.168.17.100:50015&quot; bypass-list=&quot;localhost&quot;\n\n查看代理状态：\n1netsh winhttp show proxy\n\n取消代理：\n1netsh winhttp reset proxy\n\n","slug":"Windows-Git和CMD-的命令行代理设置","date":"2022-02-28T02:10:42.000Z","categories_index":"代理","tags_index":"cmd,Git,windows,proxy,SOCKS","author_index":"Weiba"},{"id":"ad9e949c878a65f54af3e2722178fa5b","title":"hexo自动构建部署从Travis CI迁移至GitHub Actions","content":"\n\n\n\n\n\n\n\n\n很久没更新博客了，今天想更新一下发现构建失败，看了下是因为 Travis CI 开始商业化了，我的免费额度早就用完了，正好现在都在玩 GitHub Actions, 切换过来了.  使用的 Workflow 是基于 使用 GitHub Actions 自动部署 Hexo 博客 的, 感谢大大.\n仓库和 Travis CI 时一样，master 为部署分支，source 分支为博客构建分支，blog 都在这里面。\nHexo 添加 Git 部署依赖自动部署需要用到 hexo-deployer-git 依赖: npm install -save hexo-deployer-git.\n编辑 hexo 配置:\n123456deploy:   type: git  repo: git@github.com:xweiba/xweiba.github.io.git  branch: master # 部署到的分支  name: xweiba  email: xiaoweiba1028@gmail.com\n\n配置部署密钥终端执行 ssh-keygen -t rsa -C &quot;xiaoweiba1028@gmail.com&quot; -f D:\\github\\xweiba\\hexo-deploy-key, 即可生成 id_rsa 和 id_rsa.pub 文件。\n将公钥 hexo-deploy-key.pub 设置为仓库的部署密钥 Settings &gt; Deploy keys:\n\n\n然后在仓库的 Settings &gt; Actions 中新增一个 secret，命名为 DEPLOY_KEY，把私钥 hexo-deploy-key 的内容复制进去，供后续使用。\n\n\n编写 WorkflowWorkflow 就是 GitHub Actions 的配置文件，类似于 .travis.yml。\n在 source 分支新建文件：\n12mkdir -p .github/workflowstouch .github/workflows/deploy.yml\n\n编辑 deploy.yml：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162name: Hexo Deploy# 只监听 source 分支的改动on:  push:    branches:      - source# 自定义环境变量env:  POST_ASSET_IMAGE_CDN: truejobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:      # 获取博客源码和主题      - name: Checkout        uses: actions/checkout@v2      # 这里用的是 Node.js 14.x      - name: Set up Node.js        uses: actions/setup-node@v1        with:          node-version: &#x27;14&#x27;      # 设置 yarn 缓存，npm 的话可以看 actions/cache@v2 的文档示例      - name: Get yarn cache directory path        id: yarn-cache-dir-path        run: echo &quot;::set-output name=dir::$(yarn cache dir)&quot;      - name: Use yarn cache        uses: actions/cache@v2        id: yarn-cache        with:          path: $&#123;&#123; steps.yarn-cache-dir-path.outputs.dir &#125;&#125;          key: $&#123;&#123; runner.os &#125;&#125;-yarn-$&#123;&#123; hashFiles(&#x27;**/yarn.lock&#x27;) &#125;&#125;          restore-keys: |            $&#123;&#123; runner.os &#125;&#125;-yarn-      # 安装依赖      - name: Install dependencies        run: |          yarn install --prefer-offline --frozen-lockfile      # 从之前设置的 secret 获取部署私钥      - name: Set up environment        env:          DEPLOY_KEY: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;        run: |          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;          mkdir -p ~/.ssh          echo &quot;$DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa          chmod 600 ~/.ssh/id_rsa          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts          git config --global user.name &quot;xweiba&quot;          git config --global user.email &quot;xiaoweiba1028@gmail.com&quot;      # 生成并部署      - name: Deploy        run: |          npx hexo clean &amp;&amp; npx hexo d -g \n\n部署只要 source 分支有修改就会触发仓库 Actions 的 Workflows 自动部署静态文件:\n\n","slug":"将hexo自动构建部署从Travis-CI迁移至GitHub-Actions","date":"2022-02-28T01:31:34.000Z","categories_index":"Hexo,GitHub","tags_index":"Hexo,Travis CI,GitHub Actions","author_index":"Weiba"},{"id":"3e8de84b59beb071f84ad0a51ed69a69","title":"Arthas - 反编译class并热更新","content":"1.反编译jad –source-only com.enableets.edu.paper.framework.service.TransformPaperService &gt; &#x2F;root&#x2F;TransformPaperService.java注意 重定向的写入会有多余信息, 需手动删除\n2.查找classLoaderHashsc -d com.enableets.edu.paper.framework.service.TransformPaperService | grep classLoaderHash会获取内存编译所需的 classLoaderHash\n3.使用内存编译mc -c 5b2133b1 &#x2F;root&#x2F;TransformPaperService.java -d &#x2F;root&#x2F;TransformPaperService.class\n4.热部署(如果改动不大,可直接修改本地源码, 将编译后的class热部署即可)redefine &#x2F;root&#x2F;TransformPaperService.class\n可能会遇到的报错\n反编译报错 Memory compiler error, exception message: Compilation Error经搜索是 Arthas 反编译器有bug, 可将class拖出来使用idea编译, 直接使用 redefine 热部署即可\n反编译报错属性值不对, 因为反编译出的class有问题, 将源码拖出来自己慢慢改.\n\n","slug":"Arthas - 反编译class并热更新","date":"2021-06-30T04:16:42.000Z","categories_index":"Arthas","tags_index":"Arthas,debug,调试","author_index":"Weiba"},{"id":"7439aff8f53103a2ebd62b031bb6dedb","title":"Web-通过DragDropTouch适配移动端drop事件","content":"DragDropTouch-Github\n最近碰到一个bug,移动dom的drag事件在手机端没有反应, 查了一下drag是鼠标的相关api, 而手机端只有touch事件. \n需求比较急, 而且我也只是个xx后端, 找了个开源的插件, 适配一下 ok 啦\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/** Drag and drop questions* */var QuestionDragDrop = window.QuestionDragDrop = &#123;    dropImage: function(event) &#123;        var _this = this;        event.preventDefault();        var srcHtml = event.dataTransfer.getData(&quot;text/html&quot;);        var type = $(srcHtml).attr(&quot;type&quot;);        if (type == &quot;answerImage&quot;) &#123;            var srcImgUrl = $(srcHtml).attr(&quot;src&quot;);            var answerId = $(srcHtml).attr(&quot;answerId&quot;);            $(event.target).attr(&quot;src&quot;, srcImgUrl);            $(event.target).attr(&quot;answerId&quot;, answerId);        &#125;    &#125;,    allowDropImage: function(event) &#123;        event.preventDefault();    &#125;,    getUserAnswer: function (settings) &#123;        var $this = settings.questionNode.userAnswer.$answer;        var questionArea = $($this).parent().parent();        var answerArr = [];        var ret = false;        questionArea.find(&quot;.question_content img.question_blank_image_area&quot;).each(function()&#123;            var answerid = $(this).attr(&quot;answerid&quot;);            if (!CommUtils.isEmpty(answerid))&#123;                answerArr.push(answerid);                ret = true;            &#125;else&#123;                answerArr.push(&quot; &quot;);            &#125;        &#125;);        return ret ? answerArr.join(&quot;,&quot;) : &#x27;&#x27;;    &#125;,    tranToDragQuestion: function(question, isMerge) &#123; // Drag and drop question processing, generate random options        var _this = this;        if (CommUtils.isEmpty(question) || question.type.code !== &quot;39&quot; ||            CommUtils.isEmpty(question.stem.plaintext) ||            CommUtils.isEmpty(question.answer.lable)) return question;        var blankImageMap = JSON.parse(question.stem.plaintext);        var liTemplate = &quot;&lt;span style=&#x27;display: inline; width: 200px; height: 100px; margin: 0px 10px 50px 10px;&#x27; &quot; +            &quot;class=&#x27;question_blank_image_area&#x27;&gt;&quot; +            &quot;&lt;img style=&#x27;max-width: 230px !important; max-height: 100px; border: 1px solid #42a3f5; margin-right: 20px; margin-bottom: 20px;&#x27; &quot; +            &quot;type=&#x27;answerImage&#x27; answerId=&#x27;&#123;0&#125;&#x27; src=&#x27;&#123;1&#125;&#x27;&gt;&quot; +            &quot;&lt;/span&gt;&quot;;        var keys = [];        if (question.answer.lable.indexOf(&quot;@&quot;) &gt; 0) &#123;            keys = question.answer.lable.split(&quot;@#@&quot;);        &#125; else if (question.answer.lable.indexOf(&quot;,&quot;) &gt; 0) &#123;            keys = question.answer.lable.split(&quot;,&quot;);        &#125;        keys.sort(function () &#123;            return Math.random() &gt; 0.5 ? -1 : 1;        &#125;);        var richText = &quot;&quot;;        $.each(keys,function (index,key) &#123;            var blankImage = blankImageMap[key];            richText += CommUtils.formatStr(liTemplate, key, blankImage.file.url);        &#125;);        if (isMerge) &#123;            question.stem.richText += (&quot;&lt;div style=&#x27;margin: 5px 5px 5px 5px; width: 100%;&#x27; class=&#x27;question_blank_image_option&#x27; data-key=&#x27;&quot; + question.questionId +&quot;&#x27;&gt;&quot; + richText + &quot;&lt;/div&gt;&quot;);        &#125; else &#123;            question.stem.richTextOpt = (&quot;&lt;div style=&#x27;margin: 5px 5px 5px 5px; width: 100%;&#x27; class=&#x27;question_blank_image_option&#x27; data-key=&#x27;&quot; + question.questionId +&quot;&#x27;&gt;&quot; + richText + &quot;&lt;/div&gt;&quot;);        &#125;        return question;    &#125;,    textBecomeImg: function (text, fontcolor, fontsize, imgWidth, x, y)&#123; // use canvas to convert text to pictures        var canvas = document.createElement(&#x27;canvas&#x27;);        //Less than 32 words plus 1, less than 60 words plus 2, less than 80 words plus 4, less than 100 words plus 6        var buHeight = 0;        if(fontsize &lt;= 32)&#123; buHeight = 1; &#125;        else if(fontsize &gt; 32 &amp;&amp; fontsize &lt;= 60 )&#123; buHeight = 2;&#125;        else if(fontsize &gt; 60 &amp;&amp; fontsize &lt;= 80 )&#123; buHeight = 4;&#125;        else if(fontsize &gt; 80 &amp;&amp; fontsize &lt;= 100 )&#123; buHeight = 6;&#125;        else if(fontsize &gt; 100 )&#123; buHeight = 10;&#125;        //For g j etc. sometimes there will be occlusion, here add some height        canvas.height=fontsize + buHeight ;        var context = canvas.getContext(&#x27;2d&#x27;);        //Erase the rectangle with the position size of (0,0) 200 x 200, erase means to make the area transparent        context.clearRect(0, 0, canvas.width, canvas.height);        context.fillStyle = fontcolor;        context.font=fontsize+&quot;px Arial&quot;;        //top (top alignment) hanging (middle alignment) bottom (bottom alignment) alphabetic is the default        context.textBaseline = &#x27;middle&#x27;;        context.fillText(text,0,fontsize/2)        //If the width and height are set directly here, the content will be lost, and the cause has not been found for the time being, you can temporarily solve it with the following scheme        //canvas.width = context.measureText(text).width;        //Option 1: You can copy the content first, then set the width, and then paste        //Option 2: Create a new canvas and paste the old canvas content        //Option 3: After setting the width on the top, set the text again        //Solution 1: After testing, there is a problem. After the font becomes larger, the display is not complete. The reason is that the default width of the canvas is not enough.        //If you give the canvas a large width at the beginning, this is fine.        //var imgData = context.getImageData(0,0,canvas.width,canvas.height);  first copy the content in the original canvas        //canvas.width = context.measureText(text).width;  then set the width and height        //context.putImageData(imgData,0,0); //paste the copied content last        //Option 3: After changing the size, reset the text once        if (imgWidth) &#123;            canvas.width = imgWidth;        &#125; else &#123;            canvas.width = context.measureText(text).width;        &#125;        context.fillStyle = fontcolor;        context.font=fontsize+&quot;px Arial&quot;;        context.textBaseline = &#x27;middle&#x27;;        if (x &amp;&amp; y) &#123;            context.fillText(text,x,y)        &#125; else &#123;            context.fillText(text,0,fontsize/2)        &#125;        var dataUrl = canvas.toDataURL(&#x27;image/png&#x27;);//Note that if the background is transparent, you need to use png        return dataUrl;    &#125;,    dropImageMobile: function (event) &#123;        console.log(&quot;dropImageMobile&quot;);        var _this = this;        var type = $(questionDragDropMoveDomTarget).attr(&quot;type&quot;);        if (questionDragDropMoveDomTarget == undefined || event.target == questionDragDropMoveDomTarget || $(event.target).attr(&quot;type&quot;) == &quot;answerImage&quot;) return;        event.preventDefault();        if (type == &quot;answerImage&quot;) &#123;            var srcImgUrl = $(questionDragDropMoveDomTarget).attr(&quot;src&quot;);            var answerId = $(questionDragDropMoveDomTarget).attr(&quot;answerId&quot;);            $(event.currentTarget).attr(&quot;src&quot;, srcImgUrl);            $(event.currentTarget).attr(&quot;answerId&quot;, answerId);        &#125;    &#125;,    dragstartMobile: function (event, type) &#123;        console.log(&quot;dragstartMobile&quot;);        window.questionDragDropMoveDomTarget = event.target;    &#125;,    dragenter: function (event, type) &#123;        console.log(&quot;dragenter&quot;);        console.log(event.dataTransfer);        console.log(event.target.currentSrc);    &#125;,    dragleave: function (event, type) &#123;        console.log(&quot;dragleave&quot;);        console.log(event.dataTransfer);        console.log(event.target.currentSrc);    &#125;,    dragend: function (event, type) &#123;        console.log(&quot;dragend&quot;);        console.log(event.dataTransfer);        console.log(event.target.currentSrc);    &#125;,    isMobile: function () &#123;        var userAgentInfo = navigator.userAgent;        var mobileAgents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];        var mobile_flag = false;        //根据userAgent判断是否是手机        for (var v = 0; v &lt; mobileAgents.length; v++) &#123;            if (userAgentInfo.indexOf(mobileAgents[v]) &gt; 0) &#123;                mobile_flag = true;                break;            &#125;        &#125;        var screen_width = window.screen.width;        var screen_height = window.screen.height;        //根据屏幕分辨率判断是否是手机        if (screen_width &lt; 500 &amp;&amp; screen_height &lt; 800) &#123;            mobile_flag = true;        &#125;        return mobile_flag;    &#125;,    initMobileEvent: function (isEvent) &#123;        for (var imgDom of $(&quot;.question_blank_image_area img[type=&#x27;answerImage&#x27;]&quot;)) &#123;            if (isEvent) &#123;                if (QuestionDragMobileMap.get(imgDom) != undefined) return;                QuestionDragMobileMap.set(imgDom, true);                $(imgDom).unbind();                $(imgDom).attr(&quot;draggable&quot;, &quot;draggableTouch&quot;);// 注意只有有`draggable`属性的节点才会被处理, 这里值只是做个标记                imgDom.addEventListener(&#x27;dragstart&#x27;, QuestionDragDrop.dragstartMobile, false);                imgDom.addEventListener(&#x27;dragenter&#x27;, QuestionDragDrop.dropImageMobile, false)            &#125; else &#123;                if (!QuestionDragMobileMap.get(imgDom) != undefined) return;                QuestionDragMobileMap.delete(imgDom);                imgDom.removeEventListener(&#x27;dragstart&#x27;, QuestionDragDrop.dragstartMobile, false);                imgDom.removeEventListener(&#x27;dragenter&#x27;, QuestionDragDrop.dropImageMobile, false)            &#125;        &#125;        for (var imgDom of $(&quot;img.stem.question_blank_image_area&quot;)) &#123;            if (isEvent) &#123;                if (QuestionDragMobileMap.get(imgDom)) return;                QuestionDragMobileMap.delete(imgDom, true);                $(imgDom).unbind();                $(imgDom).attr(&quot;draggable&quot;, &quot;draggableTouch&quot;);                imgDom.addEventListener(&#x27;dragstart&#x27;, QuestionDragDrop.dragstartMobile, false);                imgDom.addEventListener(&#x27;dragenter&#x27;, QuestionDragDrop.dropImageMobile, false);            &#125; else &#123;                if (!QuestionDragMobileMap.get(imgDom)) return;                QuestionDragMobileMap.delete(imgDom);                imgDom.removeEventListener(&#x27;dragstart&#x27;, QuestionDragDrop.dragstartMobile, false);                imgDom.removeEventListener(&#x27;dragenter&#x27;, QuestionDragDrop.dropImageMobile, false)            &#125;            console.log(&quot;change&quot;);        &#125;    &#125;&#125;;window.QuestionDragMobileMap = new Map();$(function () &#123;    if (QuestionDragDrop.isMobile()) &#123;        $(&quot;body&quot;).bind(&quot;DOMSubtreeModified&quot;, function () &#123;            QuestionDragDrop.initMobileEvent(false);            QuestionDragDrop.initMobileEvent(true);        &#125;);    &#125;&#125;);","slug":"Web-通过DragDropTouch适配移动端drop事件","date":"2021-06-10T05:43:38.000Z","categories_index":"Web","tags_index":"Web,移动端,适配","author_index":"Weiba"},{"id":"5b3fd36ba58de8c4f5cd292f46984b8d","title":"Nginx 相关","content":"直接返回文件内容12345678910location ^~ /get_json_file&#123;\tdefault_type application/json;\tadd_header Content-Type &#x27;application/json; charset=utf-8&#x27;;\talias D:/resouces/code/java/test.json;&#125;location ~ ^/get_json &#123;    default_type application/json;    return 200 &#x27;&#123;&quot;status&quot;:&quot;success&quot;,&quot;result&quot;:&quot;hello world!&quot;&#125;&#x27;;&#125;\n\n负载均衡\n配置 conf/nginx.conf\n\n\n默认轮询 添加下列配置 1234567891011121314http&#123;    ....    upstream tomcats &#123;        server 127.0.0.1:8080        server 127.0.0.1:9080    &#125;    ...&#125;server&#123;    ...    location / &#123;        proxy_pass http://tomcats;    &#125;&#125;\n\n错误记录重载配置 ./nginx -c ../conf/nginx.conf -s reload , 报错: nginx: [emerg] unknown directive. \n1原因是因为因为nginx.conf配置被windows下的记事本编辑过, 编码变成了UTF-8+BOOM, nginx 报错.\n\nreload 不生效浏览器端禁用缓存, 可发起新连接\nhttp 转发至 https123456789101112131415161718192021222324252627282930313233343536373839404142434445http &#123;    # 添加dns解析地址, nginx在proxy_pass转发时如果使用变量, 当此变量是域名时有很大几率会出现无法解析导致502问题    # 错误日志为: no resolver defined to resolve ***    resolver 8.8.8.8;&#125;# 443 server &#123;    listen 443 ssl;    server_name xxx.com;    ssl on;   #设置为on启用SSL功能。    root html;    index index.html index.htm;    ssl_certificate cert/xxx.pem;   #将domain name.pem替换成您证书的文件名。    ssl_certificate_key cert/xxx.key;   #将domain name.key替换成您证书的密钥文件名。    ssl_session_timeout 5m;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   #使用该协议进行配置。    ssl_prefer_server_ciphers on;    location = / &#123;        proxy_set_header Host $http_host;        proxy_redirect     off;        proxy_pass         http://xxx/xxx/;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;        client_max_body_size    1000m;    &#125;&#125;service &#123;    listen       80;    server_name  xxx.xxx.com;    location / &#123;        # GET 请求走301重定向, 非GET请求使用proxy_pass        if ($request_method ~ ^(POST|DELETE|OPTIONS)$) &#123;            # 注意使用变量转发时一定要添加resolver配置            proxy_pass https://$host;            break ;        &#125;        rewrite ^(.*)$   https://$host$1 permanent;    &#125;&#125;","slug":"Nginx 相关","date":"2021-05-18T05:07:23.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"Weiba"},{"id":"9b0c0b539f3413401920f77d831fd931","title":"vim 编辑器快捷键","content":"vim可以直接编辑jar等压缩包内容: vim xx.jar 再选择压缩包内配置文件修改.\n常用命令\n文本替换: 命令模式 : 下: %s/prepare-lesson-microservice/testiiiii/g\n删除所有内容: ggdG\n显示&#x2F;不显示行号: 命令模式 : 下: set nu/nonu\n无权限时保存文件: :w !sudo tee %\n\n","slug":"vim 编辑器快捷键","date":"2021-04-26T05:08:44.000Z","categories_index":"Vim","tags_index":"Vim,常用","author_index":"Weiba"},{"id":"477ffac67edf916373cde4892b84e3f3","title":"SpringBoot 启动源码解析","content":"1.启动1234public static void main(String[] args) &#123;    // 静态方法启动    SpringApplication.run(xxx.class, args);&#125;\n\n2. 初始化 SpringApplication 对象123456789101112131415161718192021222324252627public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;\tthis.resourceLoader = resourceLoader;\tAssert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);\tthis.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));\t/**\t  *设置webApplication类型, 三种类型:\t   NONE: 不是web环境\t   SERVLET:  【spring-webmvc + Servlet + Tomcat】命令式的、同步阻塞的\t   REACTIVE: 【spring-webflux + Reactor + Netty】响应式的、异步非阻塞的 https://www.cnblogs.com/cjsblog/p/12580518.html\t*/\tthis.webApplicationType = WebApplicationType.deduceFromClasspath();\t/**\t  * https://www.cnblogs.com/duanxz/p/11239291.html\t  * 通过扫描 META-INF/spring.factories 文件初始化 ApplicationContextInitializer 的实现类集合, 并实例化, 通过order注解排序\t  * ApplicationContextInitializer是Spring框架原有的东西，这个接口的主要作用就是在ConfigurableApplicationContext类型(或者子类型)的ApplicationContext做refresh之前，允许我们对ConfiurableApplicationContext的实例做进一步的设置和处理。\t  */\tsetInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\t/**\t  * https://www.cnblogs.com/lwcode6/p/12072202.html\t  * 通过扫描 META-INF/spring.factories 文件初始化 ApplicationListener 的实现类集合, 并实例化, 通过order注解排序\t  * ApplicationContext事件机制是观察者设计模式的实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理；如果容器中存在ApplicationListener的Bean，当ApplicationContext调用publishEvent方法时，对应的Bean会被触发。      */\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\t// 创建Main方法所在的对象实例\tthis.mainApplicationClass = deduceMainApplicationClass();&#125;\n\n2.1 执行run方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public ConfigurableApplicationContext run(String... args) &#123;\tStopWatch stopWatch = new StopWatch();\tstopWatch.start();\tConfigurableApplicationContext context = null;\tCollection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();\t/**\t  * 设置配置模式 https://blog.csdn.net/wodeyuer125/article/details/50502914\t  * 这里直接设置的java.awt.headless 模式\t  * 当我们写的java程序本身不许要显示awt界面，例如命令行程序，后端程序。为了提高计算效率和适配性我们可以使用这种模式，关闭图形显示等功能可以大大节省设备的计算能力，而且对一些本身没有相关显示设备的机器也能适配，程序也可以正常运行。\t  */\tconfigureHeadlessProperty();\t/**\t  * https://www.cnblogs.com/duanxz/p/11239291.html\t  * 通过扫描 META-INF/spring.factories 文件初始化 SpringApplicationRunListener 的实现类集合, 并实例化, 通过order注解排序\t  * SpringApplicationRunListener 接口的作用主要就是在Spring Boot 启动初始化的过程中可以通过SpringApplicationRunListener接口回调来让用户在启动的各个流程中可以加入自己的逻辑。\t  */\tSpringApplicationRunListeners listeners = getRunListeners(args);\t// 执行所有的SpringApplicationRunListener实例的starting生命周期方法\tlisteners.starting();\ttry &#123;\t    // 启动参数\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\t\t/**\t\t  * 1. getOrCreateEnvironment 根据webApplication类型初始化不同配置\t\t  *  1.1 SERVLET\t\t  *   1.1.1 初始化:servletConfigInitParams, servletContextInitParams\t\t  *   1.1.2 通过spring.jndi.ignore配置判断是否初始化 jndiProperties\t\t  *   1.1.3 通过super.customizePropertySources(propertySources); 初始化 systemProperties(JVM环境变量), systemEnvironment(系统环境变量)\t\t  *  1.2 REACTIVE和NONE一致\t\t  *   1.2.1 通过super.customizePropertySources(propertySources); 初始化 systemProperties(JVM环境变量), systemEnvironment(系统环境变量)\t\t  * 2. configureEnvironment 初始化参数\t\t  *  2.1 configurePropertySources 初始化命令行传入和方法的参数\t\t  *  2.2 configureProfiles 以spring.profiles.active为key从getOrCreateEnvironment初始化的环境变量对象来初始化ActiveProfiles\t\t  * 3. 通过SpringApplicationRunListener实例的后置处理程序environmentPrepared加载配置文件\t\t  *  3.1 SpringCloud BootstrapApplicationListener 初始化configName, $&#123;spring.cloud.bootstrap.name:bootstrap&#125;, 并读入配置文件\t\t  */\t\tConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\t\tconfigureIgnoreBeanInfo(environment);\t\tBanner printedBanner = printBanner(environment);\t\tcontext = createApplicationContext();\t\texceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\t\t\t\tnew Class[] &#123; ConfigurableApplicationContext.class &#125;, context);\t\tprepareContext(context, environment, listeners, applicationArguments, printedBanner);\t\trefreshContext(context);\t\tafterRefresh(context, applicationArguments);\t\tstopWatch.stop();\t\tif (this.logStartupInfo) &#123;\t\t\tnew StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\t\t&#125;\t\tlisteners.started(context);\t\tcallRunners(context, applicationArguments);\t&#125;\tcatch (Throwable ex) &#123;\t\thandleRunFailure(context, ex, exceptionReporters, listeners);\t\tthrow new IllegalStateException(ex);\t&#125;\ttry &#123;\t\tlisteners.running(context);\t&#125;\tcatch (Throwable ex) &#123;\t\thandleRunFailure(context, ex, exceptionReporters, null);\t\tthrow new IllegalStateException(ex);\t&#125;\treturn context;&#125;","slug":"SpringBoot 启动源码解析","date":"2021-04-15T04:27:17.000Z","categories_index":"SpringBoot","tags_index":"SpringBoot,源码","author_index":"Weiba"},{"id":"c898a2e2be8a819864ade34380c2b0d9","title":"JDK代理与CGLib代理","content":"JDK代理特点：\n目标类必须为实现了某个接口的实例，因为他生成的 class 文件就是一个实现了实例接口并继承了java.lang.reflect.Proxy类的匿名类。\n通过该匿名类调用InvocationHandler实例的 invoke 接口来增强，InvocationHandler 实例必须传入目标类实例, 他就像是对目标实例做了一层封装，并通过 invoke 接口钩子来实现增强\n通过Method.invoke(Object obj, Object... args)来完成实例的最终执行, obj 为目标类实例。\n\n缺点：\n只能代理实现了接口的实例，否则无法生成对应的匿名类，并且实例中非接口的方法无法代理。\n由于是通过反射直接执行实例的方法，在实例中调用其本类方法时，不会再次走代理，而是直接执行。\n\n生成的匿名类$Proxy0.class：Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), this) 返回的就是它的实例，他会实现目标类的全部接口。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package com.sun.proxy;import io.github.xweiba.proxy.IUserManager;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements IUserManager &#123;    private static Method m1;    private static Method m2;    private static Method m4;    private static Method m3;    private static Method m0;        static &#123;        try &#123;            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);            // 接口的实现方法            m4 = Class.forName(&quot;io.github.xweiba.proxy.IUserManager&quot;).getMethod(&quot;updata&quot;, Class.forName(&quot;java.lang.String&quot;));            m3 = Class.forName(&quot;io.github.xweiba.proxy.IUserManager&quot;).getMethod(&quot;add&quot;, Class.forName(&quot;java.lang.String&quot;));            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);        &#125; catch (NoSuchMethodException var2) &#123;            throw new NoSuchMethodError(var2.getMessage());        &#125; catch (ClassNotFoundException var3) &#123;            throw new NoClassDefFoundError(var3.getMessage());        &#125;    &#125;    public $Proxy0(InvocationHandler var1) throws  &#123;        // Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces, InvocationHandler h)        // Proxy.newProxyInstance()方法会将本类实例化并传入InvocationHandler h        // return cons.newInstance(new Object[]&#123;h&#125;);        // var1 即是InvocationHandler的实例对象，        super(var1);    &#125;    public final void updata(String var1) throws  &#123;        try &#123;            // super.h === InvocationHandler的实例对象, 通过它的invoke接口实现增强功能。            // invoke 中一般使用反射来完成目标对象的调用。 m4.invoke(targetObject, new Object[]&#123;var1&#125;);            super.h.invoke(this, m4, new Object[]&#123;var1&#125;);        &#125; catch (RuntimeException | Error var3) &#123;            throw var3;        &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);        &#125;    &#125;    //....&#125;\n\nCGLib 代理特点：\nCGLib 原理是针对目标类生成一个匿名子类，覆盖其中的所有方法。\n所有方法的执行都会通过 MethodInterceptor 的 intercept 接口来实现增强，新的匿名子类 class 就像是对目标类做了一层封装，并通过 intercept 接口钩子来实现增强，在需要执行目标类的方法时通过调用父类的方法来完成。\n通过Method.invokeSuper(Object obj, Object[] args)来完成实例的最终执行, obj 为匿名子类实例，注意不是invoke,\n执行的是匿名子类的实例父类方法，在父类方法中调用本类方法时，又会回到匿名子类中，所有会再次走代理完成增强。\n因为执行的就是新生成的匿名子类，效率理论上比JDK代理高。\n\n缺点：\n目标类和方法不能声明为final类型，否则无法生成匿名子类。\n\n生成的匿名类 UserManager$$EnhancerByCGLIB$$ddf60d63：CGLib无需传入目标类实例， 因为enhancer.create() 返回的就是继承自目标类的匿名子类实例对象，他会覆盖父类的所有方法;\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package io.github.xweiba.proxy.impl;import java.lang.reflect.Method;import net.sf.cglib.core.ReflectUtils;import net.sf.cglib.core.Signature;import net.sf.cglib.proxy.Callback;import net.sf.cglib.proxy.Factory;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class UserManager$$EnhancerByCGLIB$$ddf60d63 extends UserManager implements Factory &#123;    private boolean CGLIB$BOUND;    public static Object CGLIB$FACTORY_DATA;    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;    private static final Callback[] CGLIB$STATIC_CALLBACKS;    private MethodInterceptor CGLIB$CALLBACK_0;    private static Object CGLIB$CALLBACK_FILTER;    private static final Method CGLIB$add$0$Method;    private static final MethodProxy CGLIB$add$0$Proxy;    private static final Object[] CGLIB$emptyArgs;    private static final Method CGLIB$noITest$1$Method;    private static final MethodProxy CGLIB$noITest$1$Proxy;    private static final Method CGLIB$updata$2$Method;    private static final MethodProxy CGLIB$updata$2$Proxy;    private static final Method CGLIB$equals$3$Method;    private static final MethodProxy CGLIB$equals$3$Proxy;    private static final Method CGLIB$toString$4$Method;    private static final MethodProxy CGLIB$toString$4$Proxy;    private static final Method CGLIB$hashCode$5$Method;    private static final MethodProxy CGLIB$hashCode$5$Proxy;    private static final Method CGLIB$clone$6$Method;    private static final MethodProxy CGLIB$clone$6$Proxy;    static void CGLIB$STATICHOOK1() &#123;        CGLIB$THREAD_CALLBACKS = new ThreadLocal();        CGLIB$emptyArgs = new Object[0];        // var0 是当前类        Class var0 = Class.forName(&quot;io.github.xweiba.proxy.impl.UserManager$$EnhancerByCGLIB$$ddf60d63&quot;);        Class var1;        Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;&#125;, (var1 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods());        CGLIB$equals$3$Method = var10000[0];        CGLIB$equals$3$Proxy = MethodProxy.create(var1, var0, &quot;(Ljava/lang/Object;)Z&quot;, &quot;equals&quot;, &quot;CGLIB$equals$3&quot;);        CGLIB$toString$4$Method = var10000[1];        CGLIB$toString$4$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/String;&quot;, &quot;toString&quot;, &quot;CGLIB$toString$4&quot;);        CGLIB$hashCode$5$Method = var10000[2];        CGLIB$hashCode$5$Proxy = MethodProxy.create(var1, var0, &quot;()I&quot;, &quot;hashCode&quot;, &quot;CGLIB$hashCode$5&quot;);        CGLIB$clone$6$Method = var10000[3];        CGLIB$clone$6$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/Object;&quot;, &quot;clone&quot;, &quot;CGLIB$clone$6&quot;);        // 注意这里是被代理的class var1 = Class.forName(&quot;io.github.xweiba.proxy.impl.UserManager&quot;)).getDeclaredMethods()        var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;add&quot;, &quot;(Ljava/lang/String;)V&quot;, &quot;noITest&quot;, &quot;(Ljava/lang/String;)V&quot;, &quot;updata&quot;, &quot;(Ljava/lang/String;)V&quot;&#125;, (var1 = Class.forName(&quot;io.github.xweiba.proxy.impl.UserManager&quot;)).getDeclaredMethods());        CGLIB$add$0$Method = var10000[0];        // 传入被代理的class的方法信息和当前class，当执行MethodInterceptor的intercept接口时会传入CGLIB$add$0$Proxy，调用CGLIB$add$0$Proxy的invokeSuper        CGLIB$add$0$Proxy = MethodProxy.create(var1, var0, &quot;(Ljava/lang/String;)V&quot;, &quot;add&quot;, &quot;CGLIB$add$0&quot;);        CGLIB$noITest$1$Method = var10000[1];        CGLIB$noITest$1$Proxy = MethodProxy.create(var1, var0, &quot;(Ljava/lang/String;)V&quot;, &quot;noITest&quot;, &quot;CGLIB$noITest$1&quot;);        CGLIB$updata$2$Method = var10000[2];        CGLIB$updata$2$Proxy = MethodProxy.create(var1, var0, &quot;(Ljava/lang/String;)V&quot;, &quot;updata&quot;, &quot;CGLIB$updata$2&quot;);    &#125;    final void CGLIB$add$0(String var1) &#123;        super.add(var1);    &#125;    public final void add(String var1) &#123;        // this.CGLIB$CALLBACK_0 就是 MethodInterceptor 的实例对象，通过enhancer.setCallback(this)传入。        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;        if (var10000 == null) &#123;            CGLIB$BIND_CALLBACKS(this);            var10000 = this.CGLIB$CALLBACK_0;        &#125;        if (var10000 != null) &#123; // 通过子类实例(就是本类)调用时走MethodInterceptor的intercept接口来实现增强。            var10000.intercept(this, CGLIB$add$0$Method, new Object[]&#123;var1&#125;, CGLIB$add$0$Proxy);        &#125; else &#123; // 在MethodInterceptor的intercept中通过Method.invokeSuper(Object obj, Object[] args)调用时走父类的add方法。            super.add(var1);        &#125;    &#125;    final void CGLIB$noITest$1(String var1) &#123;        super.noITest(var1);    &#125;    public final void noITest(String var1) &#123;        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;        if (var10000 == null) &#123;            CGLIB$BIND_CALLBACKS(this);            var10000 = this.CGLIB$CALLBACK_0;        &#125;        if (var10000 != null) &#123;            var10000.intercept(this, CGLIB$noITest$1$Method, new Object[]&#123;var1&#125;, CGLIB$noITest$1$Proxy);        &#125; else &#123;            super.noITest(var1);        &#125;    &#125;    final void CGLIB$updata$2(String var1) &#123;        super.updata(var1);    &#125;    public final void updata(String var1) &#123;        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;        if (var10000 == null) &#123;            CGLIB$BIND_CALLBACKS(this);            var10000 = this.CGLIB$CALLBACK_0;        &#125;        if (var10000 != null) &#123;            var10000.intercept(this, CGLIB$updata$2$Method, new Object[]&#123;var1&#125;, CGLIB$updata$2$Proxy);        &#125; else &#123;            super.updata(var1);        &#125;    &#125;    final boolean CGLIB$equals$3(Object var1) &#123;        return super.equals(var1);    &#125;    public final boolean equals(Object var1) &#123;        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;        if (var10000 == null) &#123;            CGLIB$BIND_CALLBACKS(this);            var10000 = this.CGLIB$CALLBACK_0;        &#125;        if (var10000 != null) &#123;            Object var2 = var10000.intercept(this, CGLIB$equals$3$Method, new Object[]&#123;var1&#125;, CGLIB$equals$3$Proxy);            return var2 == null ? false : (Boolean)var2;        &#125; else &#123;            return super.equals(var1);        &#125;    &#125;    final String CGLIB$toString$4() &#123;        return super.toString();    &#125;    public final String toString() &#123;        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;        if (var10000 == null) &#123;            CGLIB$BIND_CALLBACKS(this);            var10000 = this.CGLIB$CALLBACK_0;        &#125;        return var10000 != null ? (String)var10000.intercept(this, CGLIB$toString$4$Method, CGLIB$emptyArgs, CGLIB$toString$4$Proxy) : super.toString();    &#125;    final int CGLIB$hashCode$5() &#123;        return super.hashCode();    &#125;    public final int hashCode() &#123;        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;        if (var10000 == null) &#123;            CGLIB$BIND_CALLBACKS(this);            var10000 = this.CGLIB$CALLBACK_0;        &#125;        if (var10000 != null) &#123;            Object var1 = var10000.intercept(this, CGLIB$hashCode$5$Method, CGLIB$emptyArgs, CGLIB$hashCode$5$Proxy);            return var1 == null ? 0 : ((Number)var1).intValue();        &#125; else &#123;            return super.hashCode();        &#125;    &#125;    final Object CGLIB$clone$6() throws CloneNotSupportedException &#123;        return super.clone();    &#125;    protected final Object clone() throws CloneNotSupportedException &#123;        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;        if (var10000 == null) &#123;            CGLIB$BIND_CALLBACKS(this);            var10000 = this.CGLIB$CALLBACK_0;        &#125;        return var10000 != null ? var10000.intercept(this, CGLIB$clone$6$Method, CGLIB$emptyArgs, CGLIB$clone$6$Proxy) : super.clone();    &#125;    public static MethodProxy CGLIB$findMethodProxy(Signature var0) &#123;        String var10000 = var0.toString();        switch(var10000.hashCode()) &#123;        case -1692737819:            if (var10000.equals(&quot;noITest(Ljava/lang/String;)V&quot;)) &#123;                return CGLIB$noITest$1$Proxy;            &#125;            break;        case -1358456834:            if (var10000.equals(&quot;add(Ljava/lang/String;)V&quot;)) &#123;                return CGLIB$add$0$Proxy;            &#125;            break;        case -508378822:            if (var10000.equals(&quot;clone()Ljava/lang/Object;&quot;)) &#123;                return CGLIB$clone$6$Proxy;            &#125;            break;        case 1653544538:            if (var10000.equals(&quot;updata(Ljava/lang/String;)V&quot;)) &#123;                return CGLIB$updata$2$Proxy;            &#125;            break;        case 1826985398:            if (var10000.equals(&quot;equals(Ljava/lang/Object;)Z&quot;)) &#123;                return CGLIB$equals$3$Proxy;            &#125;            break;        case 1913648695:            if (var10000.equals(&quot;toString()Ljava/lang/String;&quot;)) &#123;                return CGLIB$toString$4$Proxy;            &#125;            break;        case 1984935277:            if (var10000.equals(&quot;hashCode()I&quot;)) &#123;                return CGLIB$hashCode$5$Proxy;            &#125;        &#125;        return null;    &#125;    public UserManager$$EnhancerByCGLIB$$ddf60d63() &#123;        CGLIB$BIND_CALLBACKS(this);    &#125;    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;        CGLIB$THREAD_CALLBACKS.set(var0);    &#125;    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;        CGLIB$STATIC_CALLBACKS = var0;    &#125;    private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;        UserManager$$EnhancerByCGLIB$$ddf60d63 var1 = (UserManager$$EnhancerByCGLIB$$ddf60d63)var0;        if (!var1.CGLIB$BOUND) &#123;            var1.CGLIB$BOUND = true;            Object var10000 = CGLIB$THREAD_CALLBACKS.get();            if (var10000 == null) &#123;                var10000 = CGLIB$STATIC_CALLBACKS;                if (var10000 == null) &#123;                    return;                &#125;            &#125;            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];        &#125;    &#125;    public Object newInstance(Callback[] var1) &#123;        CGLIB$SET_THREAD_CALLBACKS(var1);        UserManager$$EnhancerByCGLIB$$ddf60d63 var10000 = new UserManager$$EnhancerByCGLIB$$ddf60d63();        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);        return var10000;    &#125;    public Object newInstance(Callback var1) &#123;        CGLIB$SET_THREAD_CALLBACKS(new Callback[]&#123;var1&#125;);        UserManager$$EnhancerByCGLIB$$ddf60d63 var10000 = new UserManager$$EnhancerByCGLIB$$ddf60d63();        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);        return var10000;    &#125;    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) &#123;        CGLIB$SET_THREAD_CALLBACKS(var3);        UserManager$$EnhancerByCGLIB$$ddf60d63 var10000 = new UserManager$$EnhancerByCGLIB$$ddf60d63;        switch(var1.length) &#123;        case 0:            var10000.&lt;init&gt;();            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);            return var10000;        default:            throw new IllegalArgumentException(&quot;Constructor not found&quot;);        &#125;    &#125;    public Callback getCallback(int var1) &#123;        CGLIB$BIND_CALLBACKS(this);        MethodInterceptor var10000;        switch(var1) &#123;        case 0:            var10000 = this.CGLIB$CALLBACK_0;            break;        default:            var10000 = null;        &#125;        return var10000;    &#125;    public void setCallback(int var1, Callback var2) &#123;        switch(var1) &#123;        case 0:            this.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;        default:        &#125;    &#125;    public Callback[] getCallbacks() &#123;        CGLIB$BIND_CALLBACKS(this);        return new Callback[]&#123;this.CGLIB$CALLBACK_0&#125;;    &#125;    public void setCallbacks(Callback[] var1) &#123;        this.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[0];    &#125;    static &#123;        CGLIB$STATICHOOK1();    &#125;&#125;\n\n反射相关方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) &#123;    MethodProxy proxy = new MethodProxy();    proxy.sig1 = new Signature(name1, desc);    proxy.sig2 = new Signature(name2, desc);    // cglib 中，c1为被代理类的class，c2为cglib生成的class(c1的子类)    proxy.createInfo = new MethodProxy.CreateInfo(c1, c2);    return proxy;&#125;private static class CreateInfo &#123;    // cglib 中，c1为被代理类的class，c2为cglib生成的class    Class c1;    Class c2;    NamingPolicy namingPolicy;    GeneratorStrategy strategy;    boolean attemptLoad;    public CreateInfo(Class c1, Class c2) &#123;        this.c1 = c1;        this.c2 = c2;        AbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();        if (fromEnhancer != null) &#123;            this.namingPolicy = fromEnhancer.getNamingPolicy();            this.strategy = fromEnhancer.getStrategy();            this.attemptLoad = fromEnhancer.getAttemptLoad();        &#125;    &#125;&#125;private void init() &#123;    if (this.fastClassInfo == null) &#123;        synchronized(this.initLock) &#123;            if (this.fastClassInfo == null) &#123;                MethodProxy.CreateInfo ci = this.createInfo;                MethodProxy.FastClassInfo fci = new MethodProxy.FastClassInfo();                // f1 由 c1 生成                fci.f1 = helper(ci, ci.c1);                // f2 由 c2 生成                fci.f2 = helper(ci, ci.c2);                fci.i1 = fci.f1.getIndex(this.sig1);                fci.i2 = fci.f2.getIndex(this.sig2);                this.fastClassInfo = fci;                this.createInfo = null;            &#125;        &#125;    &#125;&#125;public Object invoke(Object obj, Object[] args) throws Throwable &#123;        try &#123;            this.init();            MethodProxy.FastClassInfo fci = this.fastClassInfo;            // 在cglib中调用被代理类c1的方法对象的invoke方法            return fci.f1.invoke(fci.i1, obj, args);        &#125; catch (InvocationTargetException var4) &#123;            throw var4.getTargetException();        &#125; catch (IllegalArgumentException var5) &#123;            if (this.fastClassInfo.i1 &lt; 0) &#123;                throw new IllegalArgumentException(&quot;Protected method: &quot; + this.sig1);            &#125; else &#123;                throw var5;            &#125;        &#125;    &#125;public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;    try &#123;        this.init();        MethodProxy.FastClassInfo fci = this.fastClassInfo;        // 在cglib中调用被代理类c2(c1的子类)的方法对象的invoke方法，会通过方法的hashcode来定位最终执行的方法。        return fci.f2.invoke(fci.i2, obj, args);    &#125; catch (InvocationTargetException var4) &#123;        throw var4.getTargetException();    &#125;&#125;\n\n\n\n测试Demo:IUserManager:\n123456789101112131415package io.github.xweiba.proxy;/** * 测试接口 * * @author caleb_L * @date 2021/04/02 **/public interface IUserManager &#123;    void add(String user);    void updata(String user);&#125;\n\nUserManager:\n1234567891011121314151617181920212223242526package io.github.xweiba.proxy.impl;import io.github.xweiba.proxy.IUserManager;/** * 实现类 * * @author caleb_L * @date 2021/04/02 **/public class UserManager implements IUserManager &#123;    public void add(String user) &#123;        System.out.println(&quot;add: &quot; + user);        updata(user);    &#125;    public void updata(String user) &#123;        System.out.println(&quot;updata: &quot; + user);    &#125;    public void noITest(String user)&#123;        System.out.println(&quot;noITest: &quot; + user);    &#125;&#125;\n\n AbstractProxy.java:\n123456789101112131415161718192021222324252627282930313233343536373839package io.github.xweiba.proxy;/** * 代理测试抽象类 * * @author caleb_L * @date 2021/04/02 **/public abstract class AbstractProxy&lt;T&gt; implements IProxy&lt;T&gt; &#123;    /**     * 代理执行方法     *     * @date 2022/04/02 11:30     * @author caleb_L     * @param objects : 代理执行参数     * @return java.lang.Object     */    public abstract Object proxyExecute(Object ...objects) throws Throwable;    public abstract String getProxyType();    /**     * 代理增强钩子     *     * @date 2022/04/02 11:30     * @author caleb_L     * @param objects : 代理执行参数     * @return java.lang.Object     */    public Object proxyEnhance(Object... objects) throws Throwable &#123;        System.out.println(getProxyType() + &quot;代理开始&quot;);        Object execute = this.proxyExecute(objects);        System.out.println(getProxyType() + &quot;代理结束&quot;);        return execute;    &#125;&#125;\n\n JdkProxyHandler.java:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package io.github.xweiba.proxy;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * JDK 动态代理Demo * * @author caleb_L * @date 2021/04/02 **/public class JdkProxyHandler extends AbstractProxy&lt;Object&gt; implements InvocationHandler &#123;    public Object target;    public Object invoke(Object proxyClassObject, Method method, Object[] args) throws Throwable &#123;        // proxyClassObject对象是JDK生成的代理class实例        System.out.println(&quot;jdkProxy invoke: proxyClassObject.super.h == this -&gt; &quot; + (getFieldValue(proxyClassObject, &quot;h&quot;) == this));        return this.proxyEnhance(proxyClassObject, method, args);    &#125;    public Object getProxy(Object object) &#123;        this.target = object;        return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), this);    &#125;    public Object proxyExecute(Object... objects) throws Throwable &#123;        // objects = Object proxy, Method method, Object[] args        // proxy对象是JDK代理生成的class的实例，这里invoke必须使用原对象。        return ((Method)objects[1]).invoke(this.target, (Object[])objects[2]);    &#125;    public String getProxyType() &#123;        return &quot;JDK&quot;;    &#125;    public Object getFieldValue(Class clazz, Object person, String name) &#123;        Object o = null;        // 获取类中声明的字段        Field[] fields = clazz.getDeclaredFields();        for (Field field : fields) &#123;            if (field.getName().equals(name)) &#123;                // 避免 can not access a member of class com.java.test.Person with modifiers &quot;private&quot;                field.setAccessible(true);                try &#123;                    o = field.get(person);                    System.out.println(field.getName() + &quot;:&quot;+ field.get(person));                    break;                &#125; catch (IllegalAccessException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        if (o == null) &#123;            o = getFieldValue(person.getClass().getSuperclass(), person, name);        &#125;        return o;    &#125;    public Object getFieldValue(Object person, String name) &#123;        return getFieldValue(person.getClass(), person, name);    &#125;&#125;\n\nCGLibProxyMethodInterceptor:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445package io.github.xweiba.proxy;import io.github.xweiba.proxy.impl.UserManager;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * CGLib 动态代理Demo * * @author caleb_L * @date 2022/04/02 **/public class CGLibProxyMethodInterceptor extends AbstractProxy&lt;Class&gt; implements MethodInterceptor  &#123;    private Object target;    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;        return this.proxyEnhance(proxy, method, args, methodProxy);    &#125;    public Object getProxy(Class superclass) &#123;        target = new UserManager();        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(superclass);        enhancer.setCallback(this);        return enhancer.create();    &#125;    public Object proxyExecute(Object... objects) throws Throwable&#123;        // objects = Object proxy, Method method, Object[] args, MethodProxy methodProxy        // 使用 invoke 的话，在方法内调用本类方法不会走父类方法，传入代理对象会死循环，使用target的话就跟JDK代理一样了。        // return ((MethodProxy)objects[3]).invoke(target, (Object[])objects[2]);        // 使用 invokeSuper 来调用父类方法，父类即为目标类。        return ((MethodProxy)objects[3]).invokeSuper(objects[0], (Object[])objects[2]);    &#125;    public String getProxyType() &#123;        return &quot;CGLib&quot;;    &#125;&#125;\n\nProxyTestDemo:\n123456789101112131415161718192021222324252627282930313233343536373839404142package io.github.xweiba.proxy;import io.github.xweiba.proxy.impl.UserManager;import net.sf.cglib.core.DebuggingClassWriter;/** * 代理测试Demo * * @author caleb_L * @date 2022/04/02 **/public class ProxyTestDemo &#123;    public static void main(String[] args) &#123;        // 保存JDK代理生成的class文件        System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);        // 开启CGLib debug模式, 保存CGLib代理生成的class文件        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, System.getProperty(&quot;user.dir&quot;) + &quot;\\\\cglib&quot;);        // cgLib 生成的是代理类的子类，并通过MethodInterceptor的intercept接口增强        // cglib 不需要new实例，只需要class，因为他生成的是class的子类，返回子类的实例。        UserManager cgLibProxy = (UserManager)new CGLibProxyMethodInterceptor().getProxy(UserManager.class);        // 真正调用的是父类的add方法，父类add方法调用时，调用        cgLibProxy.add(&quot;test&quot;);        System.out.println(&quot;\\n\\n&quot;);        cgLibProxy.noITest(&quot;test&quot;);        System.out.println(&quot;\\n\\n&quot;);        // jdk 生成的是接口的实现类，所以只能代理接口，并通过InvocationHandler的invoke接口增强        // Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)        // (super.h.invoke(this, m3, new Object[]&#123;var1&#125;);)，  super.h === jdkProxy        // jdk代理执行时必须传入代理对象，因为他最终执行的还是真正的实例, 代理类只是用来增强的。        IUserManager jdkProxy = (IUserManager)new JdkProxyHandler().getProxy(new UserManager());        jdkProxy.add(&quot;test&quot;);        System.out.println(&quot;\\n\\n&quot;);        // 会抛出异常，因为jdk代理只会代理接口，他是接口的实现。        ((UserManager)jdkProxy).noITest(&quot;test&quot;);    &#125;&#125;\n\n输入日志：\n123456789101112131415161718192021222324252627CGLIB debugging enabled, writing to &#x27;D:\\resouces\\code\\java\\note\\cglib&#x27;CGLib代理开始add: testCGLib代理开始updata: testCGLib代理结束CGLib代理结束CGLib代理开始noITest: testCGLib代理结束h:io.github.xweiba.proxy.JdkProxyHandler@72b6cbccjdkProxy invoke: proxyClassObject.super.h == this -&gt; trueJDK代理开始add: testupdata: testJDK代理结束Exception in thread &quot;main&quot; java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to io.github.xweiba.proxy.impl.UserManager\tat io.github.xweiba.proxy.ProxyTestDemo.main(ProxyTestDemo.java:41)\n","slug":"JDK代理与CGLib代理","date":"2021-04-02T01:16:25.000Z","categories_index":"Java","tags_index":"CGLib,JDK代理,反射","author_index":"Weiba"},{"id":"b312b6d7635ef172fb071e9c891a0e3d","title":"Linux 常用命令","content":"内存查看内存\n1free -m\n回收内存\n1234# 将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I/O 和读写映射文件sync # 清空缓存的内存echo 3 &gt; /proc/sys/vm/drop_caches\n\n权限添加用户\n1adduser xxx\n\n给用户 root 权限\n123vim /etc/passwd#  将用户id改为 0tommy:x:0:33:tommy:/data/webroot:/bin/bash\n\n磁盘查看磁盘使用率\n1df -h\n\n查找大文件\n1234567891011121314# 大于100M的文件 + 表示大于 - 表示小于find / -type f -size +100M# 查看当前目录大小du -sh .# 查看所有目录大小du -h --max-depth=1# 显示前10个占用空间最大的文件或目录du -s * | sort -nr | head   # 查找占空间最大的文件与目录du –max-depth=1 \n\nls 命令\n\n按易读方式来显示大小 ls -lh\n\n文件相关\n查找大于 100M 的文件\nfind . -type f -size +100M  -print0 | xargs -0 du -h | sort -nr\n\n\n查找大于 100M 的文件并清空\nfind . -type f -size +100M | xargs -I {} sh -c ‘&gt; {}’\n\n\n查找大于 100M 的文件并删除\nfind . -type f -size +100M | xargs rm -rf\n\n\n快速查找文件\nupdatedb 更新文件索引数据库\nlocate [fileName]\n\n\n文件操作\n复制时复制软连接 : cp -d libpng15.so* /usr/local/opencv/4.1.0/libMark\n\n\n\n压缩&#x2F;解压tar\n压缩 tar -zcvf [打包后生成的文件名全路径] [要打包的目录]\n-c : create 建立压缩档案的参数；\n-z ： 是否需要用gzip压缩；\n-v : 压缩的过程中显示档案；\n-f : 置顶文档名，在f后面立即接文件名，不能再加参数\n\n\n解压 tar -zxvf [/source/kernel.tgz] -C [/source/ linux-2.6.29]\n-x : 解压缩压缩档案的参数；\n-C : 指定目录\n\n\n\n系统相关\n查看发行版本 : cat /etc/redhat-release\n查看内核版本 : uname -a\n查看 glibc 库最高支持版本 : strings /lib64/libc.so.6 |grep GLIBC_ \n\n\n\n\n\n\n\n\nglibc是gnu发布的libc库，即c运行库，glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。很多linux的基本命令，比如cp, rm, ll,ln等，都得依赖于它，如果操作错误或者升级失败会导致系统命令不能使用，严重的造成系统退出后无法重新进入，所以操作时候需要慎重。\n\nCPU 信息\n查看 CPU 型号 : cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c\n查看物理 CPU 个数 : cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l\n查看每个物理 CPU 中 core 的个数(即核数) : cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq\n查看逻辑 CPU 的个数 : cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l\n\n\n内存信息\n查看内存信息 : cat /proc/meminfo\n\n\n\nYUM 包管理器\nyum erase libselinux-2.0.94-5.3.el6_4.1.x86_64 卸载冲突包\n\n文本处理\n过滤出openCv 的 java依赖so: libopencv_java410.so 文件的所有依赖 so 目录 ldd libopencv_java410.so | awk -F &#39;=&gt;&#39; &#39;&#123;print $2&#125;&#39; | awk -F &#39; &#39; &#39;&#123;print $1&#125;&#39; | awk &#39;/./ &#123;print&#125;&#39; | grep -v &quot;(&quot; | sort -u\n\n","slug":"Linux 常用命令","date":"2021-02-25T05:09:32.000Z","categories_index":"Linux","tags_index":"常用命令,Linux","author_index":"Weiba"},{"id":"283905ab630dd738eb324336ee45880c","title":"Kettel 笔记","content":"命令行执行 kettel 文件Kitchen.bat /file D:\\resouces\\code\\java\\kettle\\真题迁移\\真题转换增量处理.kjb &gt;nul 2&gt;nul\n&quot;D:\\Program Files\\pdi-ce\\data-integration\\Kitchen.bat&quot; &quot;/file&quot; &quot;D:\\resouces\\code\\java\\kettle\\真题迁移\\真题转换增量处理.kjb&quot;\n隐藏输出结果:&quot;D:\\Program Files\\pdi-ce\\data-integration\\Kitchen.bat&quot; &quot;/file&quot; &quot;D:\\resouces\\code\\java\\kettle\\真题迁移\\真题转换增量处理.kjb&quot; &gt;nul 2&gt;nul\nktr 文件:打开 cmd 命令行窗口，转到 Pan.bat 所在的目录，如 D:\\Program Files\\pdi-ce\\data-integration, 然后执行文件的命令为：pan /file D:\\etltest\\EtltestTrans.ktr\nkjb 文件:打开 cmd 命令行窗口，转到 Pan.bat 所在的目录，如 D:\\Program Files\\pdi-ce\\data-integration ,然后执行文件的命令为：kitchen /file D:\\etltest\\jobOK.kjb\n1&quot;C:\\Program Files\\Java\\jdk1.8.0_121\\bin\\java.exe&quot;  &quot;-Xms512m&quot; &quot;-Xmx512m&quot; &quot;-XX:MaxPermSize=512m&quot; &quot;-Dhttps.protocols=TLSv1,TLSv1.1,TLSv1.2&quot; &quot;-Djava.library.path=libswt\\win64&quot; &quot;-DKETTLE_HOME=&quot; &quot;-DKETTLE_REPOSITORY=&quot; &quot;-DKETTLE_USER=&quot; &quot;-DKETTLE_PASSWORD=&quot; &quot;-DKETTLE_PLUGIN_PACKAGES=&quot; &quot;-DKETTLE_LOG_SIZE_LIMIT=&quot; &quot;-DKETTLE_JNDI_ROOT=&quot; -jar launcher\\launcher.jar -lib ..\\libswt\\win64  -main org.pentaho.di.kitchen.Kitchen -initialDir &quot;D:\\Program Files\\pdi-ce\\data-integration&quot;\\ /file D:\\resouces\\code\\java\\kettle\\真题迁移\\真题转换增量处理.kjb\n\nKettel 中使用java脚本\n\n\n\n\n\n\n\n\n小坑:\n\nlogBasic(gradeIdName.getId()); 打印日志\nMap, List等泛型无法自动推导, 需要强制类型转换.\nlambda 表达式无法使用, 如foreach等之类的. (不同JDK限制不同)\n\nMaven 依赖12345678910111213141516171819202122232425&lt;dependency&gt;    &lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;    &lt;artifactId&gt;kettle-core&lt;/artifactId&gt;    &lt;version&gt;8.2.0.0-342&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;    &lt;artifactId&gt;kettle-dbdialog&lt;/artifactId&gt;    &lt;version&gt;8.2.0.0-342&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;    &lt;artifactId&gt;kettle-engine&lt;/artifactId&gt;    &lt;version&gt;8.2.0.0-342&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;pentaho&lt;/groupId&gt;    &lt;artifactId&gt;pentaho-metadata&lt;/artifactId&gt;    &lt;version&gt;8.2.0.0-342&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;pentaho&lt;/groupId&gt;    &lt;artifactId&gt;pentaho-metaverse&lt;/artifactId&gt;    &lt;version&gt;8.2.0.0-342&lt;/version&gt;&lt;/dependency&gt;\n\n实例代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332package com.enableets.edu.kettle.question.service;import com.enableets.edu.framework.core.util.token.CustomTokenGenerator;import com.enableets.edu.framework.core.util.token.ITokenGenerator;import org.pentaho.di.core.exception.KettleException;import org.pentaho.di.core.exception.KettleStepException;import org.pentaho.di.trans.step.StepDataInterface;import org.pentaho.di.trans.step.StepMetaInterface;import org.pentaho.di.trans.steps.userdefinedjavaclass.TransformClassBase;import org.pentaho.di.trans.steps.userdefinedjavaclass.UserDefinedJavaClass;import org.pentaho.di.trans.steps.userdefinedjavaclass.UserDefinedJavaClassData;import org.pentaho.di.trans.steps.userdefinedjavaclass.UserDefinedJavaClassMeta;import java.util.*;/** * @author caleb_liu@enable-ets.com * @since 2020/09/16 17:37 **/public class buildKnowledgeService extends TransformClassBase &#123;    public buildKnowledgeService(UserDefinedJavaClass parent, UserDefinedJavaClassMeta meta, UserDefinedJavaClassData data) throws KettleStepException &#123;        super(parent, meta, data);    &#125;    private Map knowledgeMap = new HashMap();    public boolean processRow(StepMetaInterface stepMetaInterface, StepDataInterface stepDataInterface) throws KettleException &#123;        if (first) &#123;            first = false;        &#125;        Object[] r = getRow();        if (r == null) &#123;            logBasic(&quot;knowledgeMapSize:&quot; + knowledgeMap.size());            output();            setOutputDone();            return false;        &#125;        r = createOutputRow(r, data.outputRowMeta.size());        KnowledgeBO knowledge = new KnowledgeBO();        knowledge.setKnowledgeId(get(Fields.In, &quot;knowledge_id&quot;).getString(r));        knowledge.setKnowledgeName(get(Fields.In, &quot;knowledge_name&quot;).getString(r));        knowledge.setParentId(get(Fields.In, &quot;parent_id&quot;).getString(r));        knowledge.setSubjectId(get(Fields.In, &quot;subject_id&quot;).getLong(r));        knowledge.setGradeId(get(Fields.In, &quot;grade_id&quot;).getLong(r));        knowledge.setCreateTime(get(Fields.In, &quot;CREATE_TIME&quot;).getDate(r));        knowledge.setUpdateTime(get(Fields.In, &quot;UPDATE_TIME&quot;).getDate(r));        knowledge.setSearchCode(get(Fields.In, &quot;knowledge_id&quot;).getString(r));        knowledgeMap.put(knowledge.getKnowledgeId(), knowledge);        return true;    &#125;    private void output() throws KettleException &#123;        tranKnowledge();        ITokenGenerator tokenGenerator = new CustomTokenGenerator(Long.valueOf(1), Long.valueOf(100));        List list = new ArrayList(knowledgeMap.values());        for (int i = 0; i &lt; list.size(); i++) &#123;            KnowledgeBO knowledge = (KnowledgeBO) list.get(i);            int index = 0;            Object[] r = new Object[16];            r[index ++] = knowledge.getKnowledgeId();            r[index ++] = knowledge.getKnowledgeName();            r[index ++] = knowledge.getParentId();            r[index ++] = knowledge.getSubjectId();            r[index ++] = knowledge.getGradeId();            r[index ++] = knowledge.getCreateTime();            r[index ++] = knowledge.getUpdateTime();            /* 新增字段 */            r[index ++] = knowledge.getKnowledgeNo();            r[index ++] = knowledge.getKnowledgeOrder();            r[index ++] = knowledge.getMaterialVersionId();            r[index ++] = knowledge.getDelStatus();            r[index ++] = knowledge.getKnowledgeType();            r[index ++] = knowledge.getType();            r[index ++] = knowledge.getIsDisplay();            r[index ++] = knowledge.getSearchCode();            r[index ++] = tokenGenerator.getToken().toString();            putRow(data.outputRowMeta, r);        &#125;    &#125;    public void tranKnowledge() &#123;        logBasic(&quot;----tranKnowledge----&quot;);        List knowledgeListTemp = new ArrayList();        List list = new ArrayList(knowledgeMap.values()); // 转换后会导致无序, 需要先把根节点生成出来        logBasic(&quot;tranKnowledge listSize:&quot; + list.size());        for (int i = 0; i &lt; list.size(); i++) &#123;            KnowledgeBO knowledge = (KnowledgeBO) list.get(i);            KnowledgeBO parentKnowledge = (KnowledgeBO)knowledgeMap.get(knowledge.getParentId());            if (parentKnowledge != null) &#123;                if (parentKnowledge.getChildKnowledgeList() == null) parentKnowledge.setChildKnowledgeList(new ArrayList());                parentKnowledge.getChildKnowledgeList().add(knowledge);            &#125; else &#123;                knowledgeListTemp.add(knowledge);            &#125;        &#125;        logBasic(&quot;----tranKnowledge end----&quot;);        tranChildKnowledgeList(knowledgeListTemp, &quot;&quot;);    &#125;    public void tranChildKnowledgeList(List childKnowledgeList, String parentSearchCode) &#123;        logBasic(&quot;----tranChildKnowledgeList----&quot;);        logBasic(&quot;childKnowledgeList Size:&quot; + childKnowledgeList.size() + &quot;  parentSearchCode:&quot; + parentSearchCode);        for (int i = 0; i &lt; childKnowledgeList.size(); i++) &#123;            StringBuilder parentSearchCodeBuilder = new StringBuilder(parentSearchCode);            KnowledgeBO knowledge = (KnowledgeBO) childKnowledgeList.get(i);            if (!parentSearchCodeBuilder.toString().equals(&quot;&quot;)) &#123;                parentSearchCodeBuilder.append(&quot;-&quot;);            &#125;            String searchCode = parentSearchCodeBuilder + knowledge.getKnowledgeId();            knowledge.setSearchCode(searchCode);            knowledge.setKnowledgeOrder(i+1+&quot;&quot;);            knowledgeMap.put(knowledge.getKnowledgeId(), knowledge);            tranChildKnowledgeList(knowledge.getChildKnowledgeList(), searchCode);        &#125;        logBasic(&quot;----tranChildKnowledgeList end----&quot;);    &#125;    public class KnowledgeBO &#123;        private String knowledgeId;        private String knowledgeNo;        private String knowledgeName;        private String knowledgeGrade;        private String knowledgeOrder = &quot;1&quot;;        private String parentId;        private Long gradeId;        private Long subjectId;        private String materialVersionId = &quot;VER401&quot;;        private String delStatus = &quot;0&quot;;        private String knowledgeType = &quot;0&quot;;        private String description;        private String creator;        private Date createTime;        private String updator;        private Date updateTime;        private String outLineId;        private String type = &quot;2&quot;;        private String isDisplay = &quot;0&quot;;        private String searchCode;        private List childKnowledgeList = new ArrayList();        public String getKnowledgeId() &#123;            return knowledgeId;        &#125;        public void setKnowledgeId(String knowledgeId) &#123;            this.knowledgeId = knowledgeId;        &#125;        public String getKnowledgeNo() &#123;            return knowledgeId;        &#125;        public String getKnowledgeName() &#123;            return knowledgeName;        &#125;        public void setKnowledgeName(String knowledgeName) &#123;            this.knowledgeName = knowledgeName;        &#125;        public String getKnowledgeGrade() &#123;            return knowledgeGrade;        &#125;        public void setKnowledgeGrade(String knowledgeGrade) &#123;            this.knowledgeGrade = knowledgeGrade;        &#125;        public String getKnowledgeOrder() &#123;            return knowledgeOrder;        &#125;        public void setKnowledgeOrder(String knowledgeOrder) &#123;            this.knowledgeOrder = knowledgeOrder;        &#125;        public String getParentId() &#123;            return parentId;        &#125;        public void setParentId(String parentId) &#123;            this.parentId = parentId;        &#125;        public Long getGradeId() &#123;            return gradeId;        &#125;        public void setGradeId(Long gradeId) &#123;            this.gradeId = gradeId;        &#125;        public Long getSubjectId() &#123;            return subjectId;        &#125;        public void setSubjectId(Long subjectId) &#123;            this.subjectId = subjectId;        &#125;        public String getMaterialVersionId() &#123;            return materialVersionId;        &#125;        public void setMaterialVersionId(String materialVersionId) &#123;            this.materialVersionId = materialVersionId;        &#125;        public String getDelStatus() &#123;            return delStatus;        &#125;        public void setDelStatus(String delStatus) &#123;            this.delStatus = delStatus;        &#125;        public String getKnowledgeType() &#123;            return knowledgeType;        &#125;        public void setKnowledgeType(String knowledgeType) &#123;            this.knowledgeType = knowledgeType;        &#125;        public String getDescription() &#123;            return description;        &#125;        public void setDescription(String description) &#123;            this.description = description;        &#125;        public String getCreator() &#123;            return creator;        &#125;        public void setCreator(String creator) &#123;            this.creator = creator;        &#125;        public Date getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(Date createTime) &#123;            this.createTime = createTime;        &#125;        public String getUpdator() &#123;            return updator;        &#125;        public void setUpdator(String updator) &#123;            this.updator = updator;        &#125;        public Date getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(Date updateTime) &#123;            this.updateTime = updateTime;        &#125;        public String getOutLineId() &#123;            return outLineId;        &#125;        public void setOutLineId(String outLineId) &#123;            this.outLineId = outLineId;        &#125;        public String getType() &#123;            return type;        &#125;        public void setType(String type) &#123;            this.type = type;        &#125;        public String getIsDisplay() &#123;            return isDisplay;        &#125;        public void setIsDisplay(String isDisplay) &#123;            this.isDisplay = isDisplay;        &#125;        public String getSearchCode() &#123;            return searchCode;        &#125;        public void setSearchCode(String searchCode) &#123;            this.searchCode = searchCode;        &#125;        public List getChildKnowledgeList() &#123;            return childKnowledgeList;        &#125;        public void setChildKnowledgeList(List childKnowledgeList) &#123;            this.childKnowledgeList = childKnowledgeList;        &#125;    &#125;&#125;\n\nLinux 脚本vim start.sh\n1234#!/bin/bashcd /home/icampus3.0/kettle/pdi-ce/data-integration./kitchen.sh -file /home/icampus3.0/kettle/pdi-ce/work/真题迁移/真题转换增量处理.kjb &gt; /home/icampus3.0/kettle/pdi-ce/work/真题迁移/真题转换增量处理.log &amp; sleep 2\nchmod 755 start.sh\nvim stop.sh\n12345678#!/bin/bash#created by codeecho &quot;真题转换 stoped.....&quot;pid=$(ps aux|grep -v grep|grep &quot;java&quot;| grep &quot;真题&quot; | awk &#x27;&#123;print $2&#125;&#x27;);if [[ $pid -gt 1 ]]; then    kill -9 $pidfi\nchmod 755 stop.sh\n注意:自定义的输出字段需要在Kettel的java面板下方的字段中按顺序添加对应属性名称, 注意只能添加字段, 原字段是不可修改和改变位置的.\n","slug":"Kettel 笔记","date":"2021-01-26T04:57:33.000Z","categories_index":"Kettel","tags_index":"Kettel","author_index":"Weiba"},{"id":"75cc1d2989c37c8206e5e60b22917cb1","title":"Anacoda OpenCV 环境搭建","content":"[TOC]\nAnacoda 环境变量Anacoda 安装时会有加入环境变量的选项, 没有勾选的话手动加一下. 与 JDK 环境变量差不多:环境变量配置\nAnacoda 配置优化Anacoda 安装完毕后修改 pip 源, 默认是国外服务器, 下载安装较慢.\n命令行修改源和配置文件修改源取一个即可.\n命令行修改pip源上海交大pip源:\n123conda config --add channels https://mirrors.sjtug.sjtu.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.sjtug.sjtu.edu.cn/anaconda/cloud/conda-forge/conda config --set show_channel_urls yes\n\n配置修改pip源Windows在 c:\\user\\xxxName\\pip\\pip.ini 中加入\n1234567[global]# 清华源index-url=https://pypi.tuna.tsinghua.edu.cn/simple [install]  trusted-host=pypi.tuna.tsinghua.edu.cndisable-pip-version-check = true  timeout = 6000  \n需要 创建pip文件夹 与 pip.ini 文件。\nLinux123456789101112cd $HOME  mkdir .pip  cd .pipsudo vim pip.conf  在里面添加  [global]  index-url=https://pypi.tuna.tsinghua.edu.cn/simple[install]  trusted-host=pypi.tuna.tsinghua.edu.cn disable-pip-version-check = true  timeout = 6000 \n\nAnacoda 常用命令\nactivate xxx 激活环境\nconda info –envs 查看所有环境\nconda create -n tensorflow pip 创建一个 tensorflow 环境\nconda remove -n tensorflow –all  删除环境\nconda env create -f  d:\\python36_20190106.yml 从配置文件导入环境\nconda env export –file python36_20190106.yml 导出环境 到yml文件\npip install matplotlib 安装模块\nconda create -n py27 python&#x3D;2.7 创建一个py2.7\nconda clean –packages –tarballs | conda clean -a 清除缓存, 安装出错时可使用\n\nJupyterNotebookAnacoda 默认会安装 JupyterNotebook, 这是一个类wbe版的 python 执行工具. python 执行实时可见.\nJupyterNotebook 配置修改修改 JupyterNotebook 根目录: windows下设置JupyterNotebook默认目录\n设置完毕后可将 JupyterNotebook笔记.7z 压缩包解压到该目录, 配置好相关依赖即可直接执行里面的代码了.\n将Anacoda创建的环境导入到JupyterNotebook中Anacoda 创建的环境是不会自动导入到 JupyterNotebook 中的, 需要手动执行:\n\n创建python 3.6环境: conda create -n py36 python=3.6\n激活至 py36 环境: activate py36\n添加至 JupyterNotebook 中:12pip install ipykernel  # 可能会报错, No module named &#x27;setuptools._deprecation_warning`, 重新安装一下pip install -U setuptools 再执行.python -m ipykernel install --name python3.6 # 安装kernel, 再次打开notebook, 新建即可看到python3.6\n安装完毕后, 在该Anacoda环境下安装的依赖在JupyterNotebook的python3.6内核中都可使用.\n\nOpenCV 安装\n\n\n\n\n\n\n\n\n3.4.2 以后因部分算法被申请专利, 在开源版本中已移除, 推荐使用 3.4.1.15版本, 所有算法均可使用.\nOpenCV 相关whlwhl文件已在压缩包 JupyterNotebook笔记.7z\\OpenCV\\环境配置库\\ 目录下\n3.4.1.15 依赖在线下载地址:\n\nopencv_contrib_python-3.4.1.15-cp36-cp36m-win_amd64\nopencv_python-3.4.1.15-cp36-cp36m-win_amd64.whl\n\nOpenCV 安装12conda create -n py36 python=3.6 # 已安装的就不需要执行这个了activate py36\n\n安装OpenCV whl12pip install opencv_python-3.4.1.15-cp36-cp36m-win_amd64.whlpip install opencv_contrib_python-3.4.1.15-cp36-cp36m-win_amd64\n\n安装OpenCV使用过程中的相关依赖文件在压缩包 JupyterNotebook笔记.7z\\OpenCV\\环境配置库\\ 目录下\n12pip install matplotlib-3.1.2-cp36-cp36m-win_amd64.whlpip install numpy-1.17.4-cp36-cp36m-win_amd64.whl","slug":"Anacoda OpenCV 环境搭建","date":"2021-01-13T06:02:47.000Z","categories_index":"Python","tags_index":"Anacoda,OpenCV,Python","author_index":"Weiba"},{"id":"41c7b401621718ddd84559c090fb4c3e","title":"CentOS 6 GCC 编译升级至5.1.0","content":"由于 CentOS 6 停止更新支持了, 官方都将yum软件源关闭了. 原来的安装方式已失效. 只能手动编译了.\n\n下载GCC 5.1.0 源码包: wget http://mirrors.ustc.edu.cn/gnu/gcc/gcc-5.1.0/gcc-5.1.0.tar.bz2\n\n解压: tar xvf gcc-5.1.0.tar.bz2\n\n安装gcc需要下载诸如gmp、mpfr、mpc等依赖文件，执行download_prerequisites将会自动下载这些软件并解压到当前目录: ./contrib/download_prerequisites\n\n新建一个build目录, 执行mark前的configura\n 123mkdir buildcd build ../configure --prefix=/usr/local/gcc-5.1.0 --disable-multilib --enable-languages=c,c++,java\n开始编译: make -j4\n\n安装 \n 1234make installwhich gcc # 将原来的gcc改名mv /usr/bin/gcc /usr/bin/gcc_bakln  -s /usr/local/gcc-5.1.0/bin/x86_64-unknown-linux-gnu-gcc-5.1.0 /usr/bin/gcc # 创建软连接\n\n测试: gcc --version\n","slug":"CentOS 6 GCC 编译升级至5.1.0","date":"2021-01-07T05:14:50.000Z","categories_index":"Linux","tags_index":"CentOS6,GCC,升级","author_index":"Weiba"},{"id":"c2590929dff188b1d2c68c1fe0e71bf7","title":"Linux Python 2.6 升级至 2.7","content":"\n\n\n\n\n\n\n\n\n来自: CentOs 6.x 升级 Python 版本 至2.7.X\n一. 更新系统和开发工具集及所需依赖1. 更新系统及开发工具12yum -y update # 可不做yum groupinstall -y &#x27;development tools&#x27;\n\n2. 安装 python 工具需要的额外软件包 SSL, bz2, zlib1yum install -y zlib-devel bzip2-devel openssl-devel xz-libs wget\n\n3. 下载源码并解压12345wget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tar.xzOr 镜像地址: wget http://mirrors.sohu.com/python/2.7.9/Python-2.7.9.tar.xzxz -d Python-2.7.9.tar.xztar -xvf Python-2.7.9.tar -C ./\n\n二. 编译安装1. 编译配置1234cd Python-2.7.9./configure --prefix=/usr/localmake make altinstall\n\n2. 检查是否安装成功1python2.7 -V\n\nopencv 编译时是直接调用 python2.7 的, 可以不做第三步\n三. 配置环境变量或使用软链接替换原python命令1. 设置软连接1ln -sf /usr/local/bin/python2.7 /usr/bin/python\n\n2. 配置环境变量, 如过原来安装过应该不用配置12vim /etc/profileexport PATH=&quot;/usr/local/bin:$PATH&quot;\n\nCentOS 需要修改yum文件第一行, 否则yum会报错: vim /usr/bin/yum\n1#!/usr/bin/python2.6","slug":"Linux Python 2.6 升级至 2.7","date":"2021-01-07T05:12:18.000Z","categories_index":"Linux","tags_index":"Python,升级,Linux","author_index":"Weiba"},{"id":"8bcb69080e95667d048fcbfaac728449","title":"解决CentOS6停止更新支持后yum源失效的问题","content":"现在测试比较正常的国内源: sohu\nCentOS-Base.repo:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445# CentOS-Base.repo## This file uses a new mirrorlist system developed by Lance Davis for CentOS.# The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the# remarked out baseurl= line instead.##[base]name=CentOS-$releasever – Basebaseurl=http://mirrors.sohu.com/centos/6.10/os/$basearch/gpgcheck=1gpgkey=http://mirrors.sohu.com/centos/RPM-GPG-KEY-CentOS-6#released updates[updates]name=CentOS-$releasever – Updatesbaseurl=http://mirrors.sohu.com/centos/6.10/updates/$basearch/gpgcheck=1gpgkey=http://mirrors.sohu.com/centos/RPM-GPG-KEY-CentOS-6#packages used/produced in the build but not released#[addons]#name=CentOS-$releasever – Addons#baseurl=http://mirrors.sohu.com/centos/$releasever/addons/$basearch/#gpgcheck=1#gpgkey=http://mirrors.sohu.com/centos/RPM-GPG-KEY-CentOS-6#additional packages that may be useful[extras]name=CentOS-$releasever – Extrasbaseurl=http://mirrors.sohu.com/centos/6.10/extras/$basearch/gpgcheck=1gpgkey=http://mirrors.sohu.com/centos/RPM-GPG-KEY-CentOS-6#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever – Plusbaseurl=http://mirrors.sohu.com/centos/6.10/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.sohu.com/centos/RPM-GPG-KEY-CentOS-6\n\nepel.repo:\n1234567891011121314151617181920212223242526272829[epel]name=Extra Packages for Enterprise Linux 6 - $basearch#baseurl=http://mirrors.aliyuncs.com/epel/6/$basearchbaseurl=http://mirrors.sohu.com/centos/6/os/$basearch/#http://mirrors.sohu.com/epel/6/$basearchhttp://mirrors.sohu.com/centos/6/os/$basearch/ failovermethod=priorityenabled=1gpgcheck=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6 [epel-debuginfo]name=Extra Packages for Enterprise Linux 6 - $basearch - Debugbaseurl=http://mirrors.aliyuncs.com/epel/6/$basearch/debughttp://mirrors.sohu.com/epel/6/$basearch/debugfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6gpgcheck=0 [epel-source]name=Extra Packages for Enterprise Linux 6 - $basearch - Sourcebaseurl=http://mirrors.aliyuncs.com/epel/6/SRPMShttp://mirrors.sohu.com/epel/6/SRPMSfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6gpgcheck=0\n\n更新yum:\n12yum clean allyum makecache","slug":"解决CentOS6停止更新支持后yum源失效的问题","date":"2021-01-07T05:11:31.000Z","categories_index":"Linux","tags_index":"CentOS6","author_index":"Weiba"},{"id":"e221c7ea9d04dfff024e9e4e2166f289","title":"CentOS 6.X yum 安装高版本 gcc","content":"\n\n\n\n\n\n\n\n\n为CentOS 6、7升级gcc至4.8、4.9、5.2、6.3、7.3等高版本\n添加yum源安装GCC安装GCC 4.8 安装123wget http://people.centos.org/tru/devtools-2/devtools-2.repo -O /etc/yum.repos.d/devtools-2.repo yum install devtoolset-2-gcc devtoolset-2-binutils devtoolset-2-gcc-c++\n\nGCC 4.9 安装12wget https://copr.fedoraproject.org/coprs/rhscl/devtoolset-3/repo/epel-6/rhscl-devtoolset-3-epel-6.repo -O /etc/yum.repos.d/devtools-3.repoyum install devtoolset-3-gcc devtoolset-3-binutils devtoolset-3-gcc-c++\n\nGCC 5.2 安装12wget https://copr.fedoraproject.org/coprs/hhorak/devtoolset-4-rebuild-bootstrap/repo/epel-6/hhorak-devtoolset-4-rebuild-bootstrap-epel-6.repo -O /etc/yum.repos.d/devtools-4.repoyum install devtoolset-4-gcc devtoolset-4-binutils devtoolset-4-gcc-c++\n\n将系统GCC切换到安装的版本切换版本:\n123scl enable devtoolset-2 bash # 4.8scl enable devtoolset-3 bash # 4.9scl enable devtoolset-4 bash # 5.2\n需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。如果要长期使用的话：\n1echo &quot;source /opt/rh/devtoolset-版本号/enable&quot; &gt;&gt;/etc/profile","slug":"CentOS 6.X yum 安装高版本 gcc","date":"2021-01-07T05:10:28.000Z","categories_index":"Linux","tags_index":"GCC,Linux,CentOs,yum","author_index":"Weiba"},{"id":"fce5245168646e1e5d9fe3befd2601df","title":"Spring-Bean的生命周期","content":"Spring-AnnotationApplicationContext 核心注入流程在构造方法执行完毕时, 容器就已经创建好了.\n1. AnnotatedBeanDefinitionReaderthis.reader = new AnnotatedBeanDefinitionReader(this); 时会注入一个 ConfigurationClassPostProcessor\nConfigurationClassPostProcessor 实现了 BeanDefinitionRegistrarPostProcessor 接口, BeanDefinitionRegistrarPostProcessor 继承了 BeanFactoryPostProcessor.\n2. ClassPathBeanDefinitionScannerthis.scanner = new ClassPathBeanDefinitionScanner(this) 时会在 includeFilters 中添加一个 new AnnotationTypeFilter(Component.class) 用来支持 @Component 注解.\n3. register(componentClasses);将配置类注入到 beanDefinitionMap 中.\n4. refresh()真正的处理流程\n4.1\n在BeanFactory初始化完毕后开始处理 BeanDefinitionRegistrarPostProcessor, 调用 ConfigurationClassPostProcessor 的 postProcessorBeanDefinitionRegister 接口, 解析 AppConfig.class 配置类, 并将其注入为 bean. 2.1 通过 ConfigurationClassParser\n\nFactoryBean是一个包装了对象的Bean, 他会生成两个Beandefinition, 创建两个Bean, 一个是他本身A, 还有一个是他getObject()接口返回的对象B, 他与@Bean注解到方法上的的区别就是, 他在A对象创建Bean时, 不会调用Spring创建Bean生命周期的全部方法, 只会调用BeanPostProcessor的before方法, 因为要通过这个创建动态代理. A对象撞见Bean时会调用, B对象创建Bean时不会调用, 因为B对象是在A对象doCreateBean过程中创建的.\n@DependsOn 依赖指定bean的注解, 被注解的类在bean的创建过程中会先创建此注解标记的beanName\n\nnew AnnotationApplicationContext(AppConfig.class)\nAnnotationApplicationContext 构造方法调用父类构造方法创建FactoryBen对象。\n初始化扫描器Scanner, 并配置一个includefilter过滤器,添加 @ComponentScan 注解.\n使用 Spring 的类的元信息解析器解析 AppConfig.class, 这个解析器是使用  AMS 字节码解析技术实现的, 因为 classloader 解析类时会把 class 加载到jvm中. 在接下来扫描包时不是每一个class都是bean的.\n开始扫描bean的流程, 前先通过excludeFilter判断 AppConfig 是不是在排除中, 是直接返回,\n不在排除中, 再判断是否在includefilterr中, 因为有默认的 @ComponentScan , 取其值. 通过元信息解析器的方法获取值下的所有class的元信息,如b.\n还是会通过filter过滤器过滤, 过滤成功后会判断是否有 @Candidate 条件判断注解, 有的话在通过条件判断是否成功. 且不为接口|不包含非静态子类|不包含@lookup注解方法的抽象类, 成功再往下解析.最后将class的包名xxx.xxx.xxService存入Beandefinition的beanClass(此阶段的beanName),扫描完成返回所有的Beandefinition集合Beandefinitions. 此时只设置了名字. \n遍历Beandefinition开始做真正的解析, 设置scope值, 生成baen的名字, 首先通过Component注解的值, 没有值的话通过类的短名生成(默认首字符小写. 注意如果类的前两个字符都是大写, 那么首字符不会小写, 而是直接用类名 如ABTest.class-&gt;ABTest, Abtest-&gt; abtest)\n给Beandefinition设置默认值,\n解析 @Lazy @primary @DependsOn @Role @Description\n检查Spring容器中是否已经存在该Beanname, 如果有相同的的名字, 且Beandefinition相同, Beandefinition对应的class也相同, 那么会抛异常, 如果Beandefinition不同, 但class相同会忽略, 这种情况只存在于该类被两个@ComponentScan注解扫描到了, 所以会忽略, 如果在同一个@ComponentScan中出现同名的会抛出异常. \nSpring容器中不存在创建一个BeandefinitionHolder对象, 添加到Beandefinitions中并注册到BeandefinitionMap中.\n初始化完毕后开始遍历Beandefinitions, 首先合并Beandefinition, 如果Bean A有parent属性, 找到parent的Beandefinition B, 将B克隆一份, 然后将b存在的属性复制给B. 返回合并后的RootBeandefinition. 如果没有parent, 将A克隆一份, 返回RootBeandefinition, 都会存入RootBeandefinition map中. 后面都是使用这个Map的RootBeandefinition.\n获取到RootBeandefinition后, 判断是否为非抽象的Beandefinition(注意不是class是否是抽象类, 而是Bean的属性是否设置为了抽象的,基本没用), 非懒加载且是单例的, 开始创建Bean.\n创建前判断是否为FactoryBean,不是的走getBean(beanname)方法创Bean. 里面会调用doCreateBan(),内部会添加到单例池中.\n如果是FactoryBean, 会先创建一个带 &amp;+beanName 的Bean, 也就是FactoryBean对应的Bean,注意他在单例池中的key没有&amp;前缀, 然后判断FactoryBean实例化对象是否是实现了SmartFactoryBean(它继承了FactoryBean), 且实现的isEagerInit()接口返回true, 那么此时会调用getBean(beanName)去创建FactoryBean的getObject()对象B的Bean, B不会存到单例池, 存放的是factoryBeanObjectCache缓存map中.\n所有的非懒加载单例bean都创建完毕后, 判断单例bean是否实现了 SmartInitialzingSingleton接口. 实现了就调用接口的afterSingletonsInstantiated()方法. 这是一个可扩展的点.\ngetBean(beanName) 中, 如果传入的beanname前缀包含&amp;会先将所有&amp;去掉-&gt;newBeanname, 然后通过newBeanname去单例池中获取bean, \n能取到Bean, 判断beanname是否包含&amp;, 如果包含&amp;会判断取出的bean是否是factoryBean, 不是的话抛异常.是的话就直接返回.  如果传入的beanname不带&amp;, 那么取出factoryBean的bean后会判断是否是FactoryBean, 是的话返回它的getObject()对应的Bean.\n取不到就通过newBeanname创建Bean.\n\ndoGetBean\ntranfromeBeanName(), 将传入的beanName进行转换, 带&amp;前缀的去掉前缀(FactoryBean), 别名的取出主id;\ngetSingleton(beanName) 获取bean. &#x2F;&#x2F;因为绝大多数都是单例bean, 所以这里会直接去单例池去拿. 28法则 \n拿不到开始创建, \n检查是否有父BeanFactory, 且当前RootBeandefinitionMap中没有beanname对应的bean, 调用父BeanFactory的getBean方法去获取.\n没有的话从RootBeandefinitionMap中通过beanName获取合并后的Beandefinition A;\n检查A是不是Abstract的\n遍历A中的DependsOns, 检查依赖的Beanname B, 检查B中是又否又通过@DependsOn注解依赖了A, 是抛出异常(循环依赖). 不是存入dependentBeanMap, key为B, value为A的beanname. 然后通过B的beanName创建bean. 创建完毕继续往下走.\n判断A是单例还是多例的还是其他的作用域(Scope)如Session等, 如果是单例的, 通过 getSingleton(beanna, lamba表达式), 获取bean\n进入 getSingleon方法. 首先通过BeanName判断单例池中有没有,有直接返回, 没有把beanname加入到正在创建中的singletonsCurrentluInCretaion集合中. 然后执行lamba表达式. lambda表达式中调用createBean()创建出真正的对象, 放入单例池中.\n如果是多例的先调用beforPrototypeCreation(beanName), 再调用createBean, 最后调用afterPrototypeCreation(beanName)\n如果是其他作用域先去Scope的缓存中scopes中获取, 获取不到去创建Scope对应的bean.\n\ncreateBean(beanName, beandefinition, argas)\n将 beandefinition 赋值给中间变量mbdTouse, 通过 beandefinition 进行class加载-&gt;resolvedClass.  加载时beanName还是类名, 如果不设置BeanClassLoader的话(过context.getBeanFactory().setBeanClassLoader(xxx)来设置),会使用默认的ClassLoader. 默认的classLoader首先会获取当前线程的classLoader(在加载Spring容器前通过Thread.currentThread().setClassLoader(xxxx)来设置, 默认是空的, 支持tomcat打破双亲委派的类加载器场景), 如果没加载到再获取当前类的类加载器, 如果当前类被放到了jre&#x2F;lib中, 他会被bootstrapClassLoader加载, 也就是jvm加载, 在运行时是拿不到的. 还拿不到的话会调用ClassLoader.getSystemClassLoader()方法, 其实就是AppClassloader.获取到类加载器后, 再通过BeanName获取到bean的类名className. 如果设置了SpringEl表达式, 会先通过El表达式去获取Bean的class.没有的话就通过ClassLoader.loadClass(className)返回class对象resolvedClass了\n克隆一个BeanDefinition, 并将class对象设置进去. mbdTouse &#x3D; new RootBeandefinition(beandefinition); mbdTouse.setBeanClass(resolvedClass)\n调用实例化前resolveBeforeInstantiation(beanName, mbdTouse)接口 InstantiationAwarBeanPosetProcessor, 会判断是否为合成Bean, 合成Bean该接口不执行., 和BeanPostProcessor接口不同, BeanPostProcessor时对象已经创建了, InstantiationAwarBeanPosetProcessor是对象创建之前. 它的接口签名是public Object Instantiation(class,beanName), 而BeanPostProcessor是public Object initialization(object, beanName), InstantiationAwarBeanPosetProcessor可以自定义对象的实例化.如果你实现了多个InstantiationAwarBeanPosetProcessor接口, 并且内部都是针对同一个bean的,那么只要有一个InstantiationAwarBeanPosetProcessor的postProcessorBeforeInstantiation(class, beanName) 返回了对象, 其他的都不会调用了. 因为这个接口就是用来自定义对象的. 注意这个接口可以返回任意对象. \n如果InstantiationAwarBeanPosetProcessor接口返回了对象, 他会调用一次bean &#x3D; applyBeanPostProcessorsAfterInitialization(bean, beanName); 对象实例化后的接口. BeanPostProcessor.postProcessAfterInitialization(result, beanName); 因为它要对对象做AOP. 没有创建对象执行doCreateBean(beanName, mbdToUse, args)\n\ndoCreateBean(beanName, mbdToUse, args)\n首先通过beanName在factoryBeanInstanceCache中获取instanceWrapper,(有可能在本Bean创建之前，就有其他Bean把当前Bean给创建出来了（比如依赖注入过程中）), 没有的话调用 createBeanInstance(beanName, mbd, args)创建 instanceWrapper;\ncreateBeanInstance(beanName, mbd, args) 中先判断有没有加载class, 没有的话先加载.\n通过 getInstanceSupplier 实例化  12345// BeanDefinition中添加了Supplier，则调用Supplier来得到对象Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();if (instanceSupplier != null) &#123;\treturn obtainFromSupplier(instanceSupplier, beanName);&#125;\n没有的话通过 @Bean 方式创建 instanceWrapper\n还没有的话开始通过构造方法创建 instanceWrapper.\n首先判断 args 参数是否为空, 且mbd中已经找过构造方法了, 是的话如果mbd.constructorArgumentsResolved为true, 通过有参构造方法autowireConstructor(beanName, mbd, null, null);(方法内会拿到缓存好的构造方法的入参)创建instanceWrapper, 没有的话通过无参构造instantiateBean(beanName, mbd);创建.\n没有找过构造方法的话下面开始通过推断构造来创建 instanceWrapper\n首先通过 SmartInstantiationAwareBeanPostProcessor 扩展点找构造方法, 可以利用SmartInstantiationAwareBeanPostProcessor来控制用beanClass中的哪些构造方法, 比如AutowiredAnnotationBeanPostProcessor会把加了@Autowired注解的构造方法找出来\n通过构造方法创建 instanceWrapper\n实例化之后会调用合并后的扩展点 MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);方法. 这个里面可以通过 mdb.setInitMethed(“方法名”) 设置初始化方法. 通过mdb.getPropertyValues().add(“orderService”, new orderService()), 对属性赋值.\n处理循环依赖\n调用InstantiationAwarBeanPosetProcessor的postProcessorAfterInstrantiation(instanceWrapper.instance, beanName) 实例化后方法. 注意这里传入的obj是没有被代理的对象.此时属性还是没有注入值的.\n开始属性注入, 首先会执行Spring自带的依赖注入, 就是如果你的@Bean(autowired&#x3D;Autowired.BY_NAME)写了autowired属性, 并设置了 Autowired.BY_NAME 或者 Autowired.BY_TYPE, 他会调用你Bean对象中的所有set方法, 通过set注入属性.注意没有属性他也会调用, ByType是通过方法入参类型调用的, ByName是通过setXXX的xxx方法注入的. 该方法可以使没有被@Component注解的类也有属性注入的能力, 因为 @Component 相对于是一个插件的能力, 如果在容器启动时不设置includeFilter @Component, 那么Spring就没有属性注入的能力了. 而且如果你使用xml方式启动容器, 且不开启注解配置, 那么没有 @Component 是不是都不能属性注入了? \n然后调用InstantiationAwarBeanPosetProcessor的的postProcessorProperties() 方法. Spring有一个AutowiredAnnotationBeanPostProcessor实现类完成了@Autowired 注解注入的能力. CommonAnnotationBeanPostProcessor实现类完成了 @Resource @WebServiceRef @EJB 注解注入的能力\n在AutowiredAnnotationBeanPostProcessor中, 如果你在前期扩展点通过BeanDefinition.getPropertyValues().add(“xxx”, new XXX())给xxx赋值, 那么@Autowired注解不会再对这个属性赋值.\n属性填充完毕后执行 initializeBean(beanName, exposedObject, mbd); 初始化真正的Bean\n调用invokeAwareMethods(String beanName, Object bean)方法, 里面会调用 ((BeanNameAware) bean).setBeanName(beanName); ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n调用初始化前 wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); 执行所有的 BeanPostProcessors.postProcessBeforeInitialization(result, beanName);\n初始化前中有一个Spring默认的 CommonAnnotationBeanPostProcessor 实现类的构造方法中会设置setInitAnnotationType(PostConstruct.class),setDestroyAnnotationType(PreDestroy.class); 设置完成后, 在调用postProcessBeforeInitialization方法时就会处理@PostConstruct注解和@PreDestroy注解. 然后在他的父类InitDestroyAnnotationBeanPostProcessor的buildLifecycleMetadata的doWithLocalMethods中, 会找到所有的@PostConstruct注解的方法, 加入到initConstructMethod集合中, 注意这里是循环调用, 如果有父类, 会把父类的方法放到前面,先执行父类方法, 返回LifecycleMetadata, 并通过LifecycleMetadata.invokeDestroyMethods(bean, beanName);执行方法. \n初始化前还有一个实现类 ApplicationContextAwareProcessor, 如果bean是EnvironmentAware, EmbeddedValueResolverAware, ResourceLoaderAware, ApplicationEventPublisherAware, MessageSourceAware, ApplicationContextAware, ApplicationStartupAware其中某一个接口的实现类的, 那么就执行接口对应的方法.\n调用初始化 invokeInitMethods(beanName, wrappedBean, mbd);\n首先判断是否实现了 InitializingBean 接口, 实现了调用 ((InitializingBean) bean).afterPropertiesSet();\n接下来如果 BeanDefinition 中有mbd.getInitMethodName(); 且不是afterPropertiesSet方法, 执行InitMethodName对应的方法.\n继续执行初始化后方法 wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); 执行所有的BeanPostProcessor.postProcessAfterInitialization(result, beanName); \n初始化后的 BeanPostProcessor.postProcessAfterInitialization(result, beanName); 中会做AOP. 注意只有 @Configuration和添加@AspectJAutoProxyRegistrar且类上有@Aspect或类或方法上 有@Transactional 注解的才会被代理.\n并且AOP对应的bean也是通过 ImportBeanDefinitionRegistrar 注入的. \ninitializeBean执行完毕后, 执行registerDisposableBeanIfNecessary(beanName, bean, mbd); 这是bean销毁相关的\n\nBean销毁实现DisposableBean或AutoCloseale接口或在方法上添加 @Perdestory 注解,在Bean销毁时调用. spring容器销毁的时候执行. 通过context.registerShutdownHook()注册关闭钩子也可以调用.\nregisterDisposableBeanIfNecessary(beanName, bean, mbd); 中会记录Bean有没有实现DisposableBean或AutoCloseale接口, 然后判断 BeanDefinition 有没有指定销毁的方法, BeanDefinition.setDestoryMehodName(“xxx”),  如果你把setDestoryMehodName设置为”{inferred}”, 那么 Spring销毁时会调用类的 close方法, 如果没有继续调用shutdown方法.如果前面都找不到会继续判断是否有实现了DestructionAwareBeanPostProcessor的Bean. 并执行它的requiresDestruction方法.判断是否需要执行销毁逻辑.DestructionAwareBeanPostProcessor接口中有两个方法 boolean requiresDestruction(Object bean)设置bean是否需要被销毁, void postProcessBeforeDestruction(Object bean, String beanName) 执行具体的销毁逻辑.InitDestroyAnnotationBeanPostProcessor是实现了DestructionAwareBeanPostProcessor的, 在初始化前时他将@PerDestory注解记录了, 在此时就会通过这个去判断是否有销毁的方法.\n如果有销毁方法, 且是单例bean通过beanName和(此时Bean是DisposableBean类型)Bean存入到disposableBeans map中. 原型bean因为Spring根本没有记录, 所以不会执行销毁方法\n","slug":"Spring-Bean的生命周期","date":"2020-12-23T07:46:50.000Z","categories_index":"Spring","tags_index":"Spring,Bean","author_index":"Weiba"},{"id":"37b160dc5b6462bbe02a296b20c77e54","title":"武汉公交实时查询接口","content":"该参数加密算法使用: https://www.jianshu.com/p/04eba47f7c07\n参数加密so中的公钥和私钥:\n12345678910111213141516171819202122232425262728293031323334353637-----BEGIN RSA PRIVATE KEY-----MIIEowIBAAKCAQEA3eL/Ywvi1ShPy7uRofo10qv5Za8s2yqOCWl5P0ybgLlOJ7anXat5wwwkbX73U0V235Tm5e8dTINlGswRMy9wJOi4jT16d540JOo3Hr6rughM9GmW6Ri4wWw1CwARYMX04uM6C2F5xxpPfdgihlYLLfK4xAhMlyuhq1G49YUXj+pzBFdC2kpCKTgdP3yUeNrLNNg+Eu5InVH8C6iVQ96a1LzSX5F2LoTffwK18ESNAOLBITVTUvlBm4pvvuX9QfD63Zj+gnpEKPrDvi+0S6hlSWBTISBCB8Dm4oKlFXGBbP6UZgMwM84hFGMunCOwrNBbBgIwV219ICgB1mqM8gTPlQIDAQABAoIBADS9FIidNaAGgdjhzz6ZsxtMxu11UosRNUtlZ201LyzMXpgv4N3xuPI0O6BO8kg3lYaU5MC4MdWS0YAqCtiIqPYM3nirqSUvVCOGC+3h0f1YpbneMwFaX+eRaZYgwQCobIlVCuHTnFdHmKdHrQUTBHs6WtI1SscPltCajwTESpJo7PSF0+5vkRK5FgpQ5obaO4Q9JfRo7UL3d+FTJ4dwWLJCwTeWzPOqjfoSDGHZFc34nUANhEIh8Gx22FF9n+hO7EUPNNUalKLLLvmRwEFTMQXw1fKHf/2F88vYuxvo4TxGm9oZjPPgl+U1GkAo/pbiNmH5UdM1yFKBu1WDfC56qSECgYEA85ylHCYqbb6ZnMprTjSkW2tLqEOOQofDi3M5EI6ptYUHL3i3ksP7QZaOu0/5hpbW17aanSbX0ny1zTD8cbHHPQHa5AGUMRVrlGGraNgmlisu0BW9Q/22UqylBt3SLeC4Zm2uTLhxonNVleAvnAHnfEHk9KqCdVztCtfzZ0ELsnkCgYEA6SuIZm6lx2VGe4lqEpWEnAVs7d+QpHLcA1vbhzqfs4V1lVI72G4lE5XJg1ip9NQTMEmTKb7WiHB5BCtwEkLkEPv6rs2f4xkVktfpUgYUM6VBHCzOnP5CPL/XSp72bT+5kGJxRSUe3npy01XTVLb+BFlDFcTR/eniI5fZ+QoVXv0CgYB/AwfOolNyvnImnh7OOoIKq+lZREeShmg8d4mkCU2QN1hktsK3QXjpXE70eCD3vAMtmqYIE21o7951qfmkaXUgaKwwPmZ+JNXfGgEde7y6hK82jG8OWORLPHoaF2Lyynw54yuCEpQkh49ywdzwsMl5Ln3p1lCIUjfAdJESH4ayuQKBgBFb01DE5gSdLo0d4s61YOT4pm5jGXKUtnptiT9dBuynf+R49cmcEZiOqyzjGewHKdKLd7BA69nGfcvoq/RAFJiLGdOPrVqL0IZZGp6nozNhFyLQ1yTq7OV25sFAalohx1/PZF1gcRbhCNFg71W8Ndb/CjaBq5x6oAJEWM7oiETFAoGBAIT3I1MyHwqsaou+50XgASFrHIbXN2A1pOlueUQr9ObSUOGaKoYDwk2pO8s7PliYz6tByLgMUfTUNhtsuLSneShfZD6ZFTHtmfyrmldH3N6YrTScQ8L+tMbVMFJcj3dlUht0sd8miZvv2w5LIOInTVJQyRTkThuEr+wDOau1KkvA-----END RSA PRIVATE KEY----------BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3eL/Ywvi1ShPy7uRofo10qv5Za8s2yqOCWl5P0ybgLlOJ7anXat5wwwkbX73U0V235Tm5e8dTINlGswRMy9wJOi4jT16d540JOo3Hr6rughM9GmW6Ri4wWw1CwARYMX04uM6C2F5xxpPfdgihlYLLfK4xAhMlyuhq1G49YUXj+pzBFdC2kpCKTgdP3yUeNrLNNg+Eu5InVH8C6iVQ96a1LzSX5F2LoTffwK18ESNAOLBITVTUvlBm4pvvuX9QfD63Zj+gnpEKPrDvi+0S6hlSWBTISBCB8Dm4oKlFXGBbP6UZgMwM84hFGMunCOwrNBbBgIwV219ICgB1mqM8gTPlQIDAQAB-----END PUBLIC KEY-----\n\nPKCS8 格式私钥\n12345678910111213141516171819202122232425262728-----BEGIN PRIVATE KEY-----MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDd4v9jC+LVKE/Lu5Gh+jXSq/llryzbKo4JaXk/TJuAuU4ntqddq3nDDCRtfvdTRXbflObl7x1Mg2UazBEzL3Ak6LiNPXp3njQk6jcevqu6CEz0aZbpGLjBbDULABFgxfTi4zoLYXnHGk992CKGVgst8rjECEyXK6GrUbj1hReP6nMEV0LaSkIpOB0/fJR42ss02D4S7kidUfwLqJVD3prUvNJfkXYuhN9/ArXwRI0A4sEhNVNS+UGbim++5f1B8PrdmP6CekQo+sO+L7RLqGVJYFMhIEIHwObigqUVcYFs/pRmAzAzziEUYy6cI7Cs0FsGAjBXbX0gKAHWaozyBM+VAgMBAAECggEANL0UiJ01oAaB2OHPPpmzG0zG7XVSixE1S2VnbTUvLMxemC/g3fG48jQ7oE7ySDeVhpTkwLgx1ZLRgCoK2Iio9gzeeKupJS9UI4YL7eHR/Vilud4zAVpf55FpliDBAKhsiVUK4dOcV0eYp0etBRMEezpa0jVKxw+W0JqPBMRKkmjs9IXT7m+RErkWClDmhto7hD0l9GjtQvd34VMnh3BYskLBN5bM86qN+hIMYdkVzfidQA2EQiHwbHbYUX2f6E7sRQ801RqUossu+ZHAQVMxBfDV8od//YXzy9i7G+jhPEab2hmM8+CX5TUaQCj+luI2YflR0zXIUoG7VYN8LnqpIQKBgQDznKUcJiptvpmcymtONKRba0uoQ45Ch8OLczkQjqm1hQcveLeSw/tBlo67T/mGltbXtpqdJtfSfLXNMPxxscc9AdrkAZQxFWuUYato2CaWKy7QFb1D/bZSrKUG3dIt4Lhmba5MuHGic1WV4C+cAed8QeT0qoJ1XO0K1/NnQQuyeQKBgQDpK4hmbqXHZUZ7iWoSlYScBWzt35CkctwDW9uHOp+zhXWVUjvYbiUTlcmDWKn01BMwSZMpvtaIcHkEK3ASQuQQ+/quzZ/jGRWS1+lSBhQzpUEcLM6c/kI8v9dKnvZtP7mQYnFFJR7eenLTVdNUtv4EWUMVxNH96eIjl9n5ChVe/QKBgH8DB86iU3K+ciaeHs46ggqr6VlER5KGaDx3iaQJTZA3WGS2wrdBeOlcTvR4IPe8Ay2apggTbWjv3nWp+aRpdSBorDA+Zn4k1d8aAR17vLqErzaMbw5Y5Es8ehoXYvLKfDnjK4ISlCSHj3LB3PCwyXkufenWUIhSN8B0kRIfhrK5AoGAEVvTUMTmBJ0ujR3izrVg5PimbmMZcpS2em2JP10G7Kd/5Hj1yZwRmI6rLOMZ7Acp0ot3sEDr2cZ9y+ir9EAUmIsZ04+tWovQhlkanqejM2EXItDXJOrs5XbmwUBqWiHHX89kXWBxFuEI0WDvVbw11v8KNoGrnHqgAkRYzuiIRMUCgYEAhPcjUzIfCqxqi77nReABIWschtc3YDWk6W55RCv05tJQ4ZoqhgPCTak7yzs+WJjPq0HIuAxR9NQ2G2y4tKd5KF9kPpkVMe2Z/KuaV0fc3pitNJxDwv60xtUwUlyPd2VSG3Sx3yaJm+/bDksg4idNUlDJFOROG4Sv7AM5q7UqS8A=-----END PRIVATE KEY-----\n\n\n坐标使用火星坐标, 可使用高德地图直接渲染\n\n通过经纬度查询附近站点信息http://androidbus.wuhancloud.cn:9087/app/v5/420100/nearby/114.398237/30.507407.do\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288&#123;    &quot;resultCode&quot;:&quot;1&quot;,    &quot;resultDes&quot;:&quot;&quot;,    &quot;data&quot;:[        &#123;            &quot;i&quot;:&quot;027-2118&quot;,            &quot;n&quot;:&quot;珞喻路鲁巷&quot;,            &quot;j&quot;:114.3959353301365,            &quot;w&quot;:30.50732862893219,            &quot;l&quot;:[                &#123;                    &quot;n&quot;:&quot;401&quot;,                    &quot;0i&quot;:&quot;027-401-0&quot;,                    &quot;0ns&quot;:&quot;鲁磨路光谷广场&quot;,                    &quot;0es&quot;:&quot;鲁磨路磨山&quot;,                    &quot;0nb&quot;:4,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-401-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;夹河路公交停车场&quot;,                    &quot;1nb&quot;:4,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;510&quot;,                    &quot;0i&quot;:&quot;027-510-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路珞雄路&quot;,                    &quot;0es&quot;:&quot;关山大道公交场站&quot;,                    &quot;0nb&quot;:4,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-510-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;鲇鱼套公交场站&quot;,                    &quot;1nb&quot;:7,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;518&quot;,                    &quot;0i&quot;:&quot;027-518-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路珞雄路&quot;,                    &quot;0es&quot;:&quot;光谷四路九峰一路&quot;,                    &quot;0nb&quot;:2,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-518-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;武昌火车站综合体&quot;,                    &quot;1nb&quot;:7,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;521&quot;,                    &quot;0i&quot;:&quot;027-521-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路珞雄路&quot;,                    &quot;0es&quot;:&quot;关山大道汽发社区&quot;,                    &quot;0nb&quot;:2,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-521-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;中山路凤凰山&quot;,                    &quot;1nb&quot;:2,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;567内环&quot;,                    &quot;0i&quot;:&quot;027-N567-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路光谷广场&quot;,                    &quot;0es&quot;:&quot;珞狮南路华中农大&quot;,                    &quot;0nb&quot;:6,                    &quot;0at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;567外环&quot;,                    &quot;0i&quot;:&quot;027-W567-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;0es&quot;:&quot;珞狮南路华中农大&quot;,                    &quot;0nb&quot;:8,                    &quot;0at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;572&quot;,                    &quot;0i&quot;:&quot;027-572-0&quot;,                    &quot;0ns&quot;:&quot;民族大道光谷广场&quot;,                    &quot;0es&quot;:&quot;龙城路南湖社区&quot;,                    &quot;0nb&quot;:0,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-572-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;中山路凤凰山&quot;,                    &quot;1nb&quot;:6,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;583&quot;,                    &quot;0i&quot;:&quot;027-583-0&quot;,                    &quot;0ns&quot;:&quot;民族大道光谷广场&quot;,                    &quot;0es&quot;:&quot;龙城西路&quot;,                    &quot;0nb&quot;:2,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-583-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;二七路二七横路&quot;,                    &quot;1nb&quot;:4,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;59&quot;,                    &quot;0i&quot;:&quot;027-59-0&quot;,                    &quot;0ns&quot;:&quot;鲁磨路光谷广场&quot;,                    &quot;0es&quot;:&quot;鲁磨路南望山&quot;,                    &quot;0nb&quot;:7,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-59-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;南湖公交场站&quot;,                    &quot;1nb&quot;:-2,                    &quot;1at&quot;:0                &#125;,                &#123;                    &quot;n&quot;:&quot;591&quot;,                    &quot;0i&quot;:&quot;027-591-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路珞雄路&quot;,                    &quot;0es&quot;:&quot;光谷一路文豪路&quot;,                    &quot;0nb&quot;:12,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-591-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;珞狮南路华中农大&quot;,                    &quot;1nb&quot;:8,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;702&quot;,                    &quot;0i&quot;:&quot;027-702-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路珞雄路&quot;,                    &quot;0es&quot;:&quot;珞喻东路油篓口&quot;,                    &quot;0nb&quot;:4,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-702-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;和平大道建设二路&quot;,                    &quot;1nb&quot;:4,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;703&quot;,                    &quot;0i&quot;:&quot;027-703-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路光谷广场&quot;,                    &quot;0es&quot;:&quot;珞喻东路高坡店&quot;,                    &quot;0nb&quot;:7,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-703-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;汉口火车站&quot;,                    &quot;1nb&quot;:3,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;709&quot;,                    &quot;0i&quot;:&quot;027-709-0&quot;,                    &quot;0ns&quot;:&quot;鲁磨路光谷广场&quot;,                    &quot;0es&quot;:&quot;鲁磨路南望山&quot;,                    &quot;0nb&quot;:5,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-709-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;园林路北洋桥西路&quot;,                    &quot;1nb&quot;:-2,                    &quot;1at&quot;:0                &#125;,                &#123;                    &quot;n&quot;:&quot;72&quot;,                    &quot;0i&quot;:&quot;027-72-0&quot;,                    &quot;0ns&quot;:&quot;鲁磨路光谷广场&quot;,                    &quot;0es&quot;:&quot;鲁磨路南望山&quot;,                    &quot;0nb&quot;:8,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-72-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;南湖公交场站&quot;,                    &quot;1nb&quot;:-2,                    &quot;1at&quot;:0                &#125;,                &#123;                    &quot;n&quot;:&quot;728&quot;,                    &quot;0i&quot;:&quot;027-728-0&quot;,                    &quot;0ns&quot;:&quot;民族大道光谷广场&quot;,                    &quot;0es&quot;:&quot;熊家咀路熊家咀&quot;,                    &quot;0nb&quot;:6,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-728-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;邓甲村停车场&quot;,                    &quot;1nb&quot;:0,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;810&quot;,                    &quot;0i&quot;:&quot;027-810-0&quot;,                    &quot;0ns&quot;:&quot;民族大道光谷广场&quot;,                    &quot;0es&quot;:&quot;华丽环保工业园&quot;,                    &quot;0nb&quot;:5,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-810-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;欢乐大道危家湾&quot;,                    &quot;1nb&quot;:2,                    &quot;1at&quot;:-1                &#125;,                &#123;                    &quot;n&quot;:&quot;905&quot;,                    &quot;0i&quot;:&quot;027-905-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路鲁巷&quot;,                    &quot;0es&quot;:&quot;珞喻路鲁巷&quot;,                    &quot;0nb&quot;:7,                    &quot;0at&quot;:-1,                    &quot;1i&quot;:&quot;027-905-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;兴新街公交停车场&quot;,                    &quot;1nb&quot;:-2,                    &quot;1at&quot;:0                &#125;,                &#123;                    &quot;n&quot;:&quot;YX518&quot;,                    &quot;0i&quot;:&quot;027-YX518-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路珞雄路&quot;,                    &quot;0es&quot;:&quot;佳园路光谷创业街&quot;,                    &quot;0nb&quot;:-3,                    &quot;0at&quot;:0,                    &quot;1i&quot;:&quot;027-YX518-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;武昌火车站综合体&quot;,                    &quot;1nb&quot;:-3,                    &quot;1at&quot;:0                &#125;,                &#123;                    &quot;n&quot;:&quot;YX583&quot;,                    &quot;0i&quot;:&quot;027-YX583-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;0es&quot;:&quot;二七路二七横路&quot;,                    &quot;0nb&quot;:-3,                    &quot;0at&quot;:0,                    &quot;1i&quot;:&quot;027-YX583-1&quot;,                    &quot;1ns&quot;:&quot;民族大道光谷广场&quot;,                    &quot;1es&quot;:&quot;民族大道光谷广场&quot;,                    &quot;1nb&quot;:-3,                    &quot;1at&quot;:0                &#125;,                &#123;                    &quot;n&quot;:&quot;YX703&quot;,                    &quot;0i&quot;:&quot;027-YX703-0&quot;,                    &quot;0ns&quot;:&quot;珞喻路鲁巷&quot;,                    &quot;0es&quot;:&quot;珞喻路鲁巷&quot;,                    &quot;0nb&quot;:-3,                    &quot;0at&quot;:0,                    &quot;1i&quot;:&quot;027-YX703-1&quot;,                    &quot;1ns&quot;:&quot;珞喻路吴家湾&quot;,                    &quot;1es&quot;:&quot;汉口火车站&quot;,                    &quot;1nb&quot;:-2,                    &quot;1at&quot;:0                &#125;            ]        &#125;,        &#123;            &quot;i&quot;:&quot;027-648&quot;,            &quot;n&quot;:&quot;珞喻路光谷广场&quot;,            &quot;j&quot;:114.40057926222842,            &quot;w&quot;:30.50562377905755        &#125;,        &#123;            &quot;i&quot;:&quot;027-1721&quot;,            &quot;n&quot;:&quot;民族大道上钱村&quot;,            &quot;j&quot;:114.39810476799097,            &quot;w&quot;:30.50456846832778        &#125;,        &#123;            &quot;i&quot;:&quot;027-1851&quot;,            &quot;n&quot;:&quot;鲁磨路光谷广场&quot;,            &quot;j&quot;:114.39987958339023,            &quot;w&quot;:30.510660833965325        &#125;,        &#123;            &quot;i&quot;:&quot;027-110&quot;,            &quot;n&quot;:&quot;虎泉街地铁光谷广场站&quot;,            &quot;j&quot;:114.39504461944803,            &quot;w&quot;:30.505324409576573        &#125;    ]&#125;\n\n线路详情查询http://bus.wuhancloud.cn:9087/website/web/420100/line/027-638-1.do\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226&#123;    &quot;resultCode&quot;:&quot;1&quot;,    &quot;resultDes&quot;:&quot;&quot;,    &quot;data&quot;:&#123;        &quot;lineName&quot;:&quot;638&quot;,        &quot;lineId&quot;:&quot;027-638-1&quot;,        &quot;lineNo&quot;:&quot;638&quot;,        &quot;direction&quot;:1,        &quot;startStopName&quot;:&quot;中山路武昌火车站&quot;,        &quot;endStopName&quot;:&quot;豹子山公交停车场&quot;,        &quot;firstTime&quot;:&quot;06:55&quot;,        &quot;lastTime&quot;:&quot;20:55&quot;,        &quot;price&quot;:&quot;2.0&quot;,        &quot;line2Id&quot;:&quot;027-638-0&quot;,        &quot;stops&quot;:[            &#123;                &quot;stopId&quot;:&quot;027-I-3014&quot;,                &quot;stopName&quot;:&quot;中山路武昌火车站&quot;,                &quot;lng&quot;:114.31501511770729,                &quot;lat&quot;:30.528365127936446,                &quot;stopOrder&quot;:1,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;4201001174935369549090816&quot;,                &quot;stopName&quot;:&quot;白沙洲大道栅栏口&quot;,                &quot;lng&quot;:1831.39,                &quot;lat&quot;:0,                &quot;stopOrder&quot;:2,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-1658&quot;,                &quot;stopName&quot;:&quot;白沙洲大道武泰闸&quot;,                &quot;lng&quot;:114.30348438737946,                &quot;lat&quot;:30.519204356957456,                &quot;stopOrder&quot;:3,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-2196&quot;,                &quot;stopName&quot;:&quot;白沙洲大道江民路&quot;,                &quot;stopOrder&quot;:4,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-1989&quot;,                &quot;stopName&quot;:&quot;白沙洲大道烽火村&quot;,                &quot;lng&quot;:114.29832020505167,                &quot;lat&quot;:30.508575906281138,                &quot;stopOrder&quot;:5,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-1765&quot;,                &quot;stopName&quot;:&quot;白沙洲大道余家湾&quot;,                &quot;lng&quot;:114.29441898865656,                &quot;lat&quot;:30.502856796186734,                &quot;stopOrder&quot;:6,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-207&quot;,                &quot;stopName&quot;:&quot;白沙洲大道乔木湾&quot;,                &quot;lng&quot;:114.28213316737985,                &quot;lat&quot;:30.501552471483652,                &quot;stopOrder&quot;:7,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-1838&quot;,                &quot;stopName&quot;:&quot;白沙洲大道八坦路&quot;,                &quot;lng&quot;:114.28590649460378,                &quot;lat&quot;:30.49390342740423,                &quot;stopOrder&quot;:8,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-220&quot;,                &quot;stopName&quot;:&quot;白沙洲大道张家湾&quot;,                &quot;lng&quot;:114.28297978201233,                &quot;lat&quot;:30.48995641879138,                &quot;stopOrder&quot;:9,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-471&quot;,                &quot;stopName&quot;:&quot;白沙洲大道青菱乡&quot;,                &quot;lng&quot;:114.28015872827761,                &quot;lat&quot;:30.485852346519746,                &quot;stopOrder&quot;:10,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-304&quot;,                &quot;stopName&quot;:&quot;白沙洲大道罗家村&quot;,                &quot;lng&quot;:114.27644600409211,                &quot;lat&quot;:30.480848694169588,                &quot;stopOrder&quot;:11,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-1547&quot;,                &quot;stopName&quot;:&quot;白沙洲大道凌吴墩&quot;,                &quot;lng&quot;:114.27300508698501,                &quot;lat&quot;:30.47553556827826,                &quot;stopOrder&quot;:12,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-407&quot;,                &quot;stopName&quot;:&quot;白沙洲大道农产品市场&quot;,                &quot;lng&quot;:114.2697583662323,                &quot;lat&quot;:30.464428605081583,                &quot;stopOrder&quot;:13,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;644&quot;,                &quot;stopName&quot;:&quot;白沙洲大道武汉工商学院&quot;,                &quot;lng&quot;:11415.8733,                &quot;lat&quot;:3027.8867,                &quot;stopOrder&quot;:14,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;643&quot;,                &quot;stopName&quot;:&quot;白沙洲大道丽水路&quot;,                &quot;lng&quot;:11415.8617,                &quot;lat&quot;:3027.71,                &quot;stopOrder&quot;:15,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-1799&quot;,                &quot;stopName&quot;:&quot;白沙洲大道中医药大学&quot;,                &quot;stopOrder&quot;:16,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;4201001148863771813613568&quot;,                &quot;stopName&quot;:&quot;白沙洲大道黄家湖三街&quot;,                &quot;lng&quot;:30.44956,                &quot;lat&quot;:0,                &quot;stopOrder&quot;:17,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-1751&quot;,                &quot;stopName&quot;:&quot;白沙洲大道武科大&quot;,                &quot;lng&quot;:114.26130176324327,                &quot;lat&quot;:30.441082616685858,                &quot;stopOrder&quot;:18,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-I-3324&quot;,                &quot;stopName&quot;:&quot;白沙洲大道红霞园艺社区&quot;,                &quot;lng&quot;:114.26126783539144,                &quot;lat&quot;:30.43422722929774,                &quot;stopOrder&quot;:19,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-I-3323&quot;,                &quot;stopName&quot;:&quot;白沙洲大道武汉交通职业学院&quot;,                &quot;lng&quot;:114.2610188590291,                &quot;lat&quot;:30.428464163983598,                &quot;stopOrder&quot;:20,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-I-3322&quot;,                &quot;stopName&quot;:&quot;白沙洲大道爱家名校华城&quot;,                &quot;lng&quot;:114.26063669086638,                &quot;lat&quot;:30.423474821595903,                &quot;stopOrder&quot;:21,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-I-3320&quot;,                &quot;stopName&quot;:&quot;华中城建材物流大市场&quot;,                &quot;stopOrder&quot;:22,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;027-743&quot;,                &quot;stopName&quot;:&quot;白沙洲大道龚家铺&quot;,                &quot;lng&quot;:114.2597691867997,                &quot;lat&quot;:30.41164394375509,                &quot;stopOrder&quot;:23,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;4201001280045626469650432&quot;,                &quot;stopName&quot;:&quot;星光大道白沙洲大道&quot;,                &quot;lng&quot;:30.40964,                &quot;lat&quot;:0,                &quot;stopOrder&quot;:24,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;4201001174709131534405632&quot;,                &quot;stopName&quot;:&quot;星光大道龚家铺小区&quot;,                &quot;lng&quot;:30.40936,                &quot;lat&quot;:0,                &quot;stopOrder&quot;:25,                &quot;metro&quot;:&quot;&quot;            &#125;,            &#123;                &quot;stopId&quot;:&quot;4201001202764528937603072&quot;,                &quot;stopName&quot;:&quot;豹子山公交停车场&quot;,                &quot;lng&quot;:30.40985,                &quot;lat&quot;:0,                &quot;stopOrder&quot;:26,                &quot;metro&quot;:&quot;&quot;            &#125;        ],        &quot;buses&quot;:[            &quot;92449|12|3|0|114.30749260639593|30.5210102768074&quot;,            &quot;92442|12|8|0|114.28906131170046|30.498180021843286&quot;,            &quot;92436|12|18|1|114.26113908437466|30.441832768265776&quot;,            &quot;92451|12|23|0|114.26117347420019|30.415380095397236&quot;        ]    &#125;&#125;\n\n站点线路查询http://bus.wuhancloud.cn:9087/website/web/420100/stop/027-1547.do?Type=LineDetail\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123;    &quot;resultCode&quot;:&quot;1&quot;,    &quot;resultDes&quot;:&quot;&quot;,    &quot;data&quot;:&#123;        &quot;stop&quot;:&#123;            &quot;stopId&quot;:&quot;027-I-3323&quot;,            &quot;stopName&quot;:&quot;白沙洲大道武汉交通职业学院&quot;,            &quot;lng&quot;:114.2610188590291,            &quot;lat&quot;:30.428464163983598        &#125;,        &quot;lines&quot;:[            &#123;                &quot;lineName&quot;:&quot;638&quot;,                &quot;line0Id&quot;:&quot;027-638-0&quot;,                &quot;line0No&quot;:&quot;638&quot;,                &quot;line0Direction&quot;:0,                &quot;line0NextStop&quot;:&quot;白沙洲大道红霞园艺社区&quot;,                &quot;line0StartStop&quot;:&quot;豹子山公交停车场&quot;,                &quot;line0EndStop&quot;:&quot;中山路武昌火车站&quot;,                &quot;line0Metro&quot;:&quot;&quot;,                &quot;line0NearBus&quot;:-2,                &quot;line1Id&quot;:&quot;027-638-1&quot;,                &quot;line1No&quot;:&quot;638&quot;,                &quot;line1Direction&quot;:1,                &quot;line1NextStop&quot;:&quot;白沙洲大道爱家名校华城&quot;,                &quot;line1StartStop&quot;:&quot;中山路武昌火车站&quot;,                &quot;line1EndStop&quot;:&quot;豹子山公交停车场&quot;,                &quot;line1Metro&quot;:&quot;&quot;,                &quot;line1NearBus&quot;:-1            &#125;,            &#123;                &quot;lineName&quot;:&quot;906&quot;,                &quot;line0Id&quot;:&quot;027-906-0&quot;,                &quot;line0No&quot;:&quot;906&quot;,                &quot;line0Direction&quot;:0,                &quot;line0NextStop&quot;:&quot;白沙洲大道红霞园艺社区&quot;,                &quot;line0StartStop&quot;:&quot;武昌大道纸坊火车站&quot;,                &quot;line0EndStop&quot;:&quot;武昌火车站公交场站&quot;,                &quot;line0Metro&quot;:&quot;&quot;,                &quot;line0NearBus&quot;:12,                &quot;line1Id&quot;:&quot;027-906-1&quot;,                &quot;line1No&quot;:&quot;906&quot;,                &quot;line1Direction&quot;:1,                &quot;line1NextStop&quot;:&quot;白沙洲大道爱家名校华城&quot;,                &quot;line1StartStop&quot;:&quot;武昌火车站公交场站&quot;,                &quot;line1EndStop&quot;:&quot;武昌大道纸坊火车站&quot;,                &quot;line1Metro&quot;:&quot;&quot;,                &quot;line1NearBus&quot;:2            &#125;        ]    &#125;&#125;","slug":"武汉公交实时查询接口","date":"2020-12-23T06:33:21.000Z","categories_index":"API","tags_index":"武汉公交","author_index":"Weiba"},{"id":"d5d550d47c4edaaafccc375e86982c77","title":"Angular-踩坑记录","content":"错误记录报错信息:1234at Object.emitError (D:\\resouces\\code\\web\\content-v5\\node_modules\\webpack\\lib\\NormalModule.js:173:6)at D:\\resouces\\code\\web\\content-v5\\node_modules\\@angular-devkit\\build-angular\\src\\webpack\\plugins\\postcss-cli-resources.js:125:28at runMicrotasks (&lt;anonymous&gt;)at processTicksAndRejections (internal/process/task_queues.js:97:5)\n错误现象: 页面返回 Cannot GET /\n解决方法: 是因为插件中的css中引用了不存在的资源或路径错误导致的, 由于css或js做过压缩处理, 所有代码都会格式化成了一行, 所以不会爆出错误的具体位置, 将添加的静态资源格式化后再bulid就可以看到错误位置了.\n报错信息:12345Error: src/app/content-resource/content-resource.component.html:2:3 - error NG8001: &#x27;app-header&#x27; is not a known element:1. If &#x27;app-header&#x27; is an Angular component, then verify that it is part of this module.2. If &#x27;app-header&#x27; is a Web Component then add &#x27;CUSTOM_ELEMENTS_SCHEMA&#x27; to the &#x27;@NgModule.schemas&#x27; of this component to suppress this message.2   &lt;app-header&gt;&lt;/app-header&gt;\n\n错误现象: 找不到依赖模块的内置组件\n解决方法: 在模块的@NgModule注解中增加exports属性并添加对应组件. 不exports的组件，只能在当前模块中（也就是 declarations 中有此组件的那个模块）中使用.其他模块是无法使用的.\n报错信息:HttpClient 请求报错: \n1Unexpected token i in JSON at position 12 at JSON.parse (&lt;anonymous&gt;) at XMLHttpRequest.onLoad\n\n错误现象: 请求失败\n解决方法: 是因为返回的数据json格式问题. 调整格式即可.\n报错信息:1Module not found: Error: Can&#x27;t resolve &#x27;crypto&#x27; in &#x27;\n\n错误现象: 无法打开页面\n解决方法: 删除node库, 重新安装, 操作步骤:\n123npm install rimraf -g //安装删除指令rimraf node_modules //卸载node库npm install\n据说原因是使用cnpm安装的库有问题, 最好还是用npm安装吧\n","slug":"Angular-踩坑记录","date":"2020-12-01T05:50:28.000Z","categories_index":"Angular","tags_index":"Angular,错误记录","author_index":"Weiba"},{"id":"100e25b235b593fdefa511a488012cb9","title":"Angular中表单校验","content":"9.Angular中的表单校验1. 模板驱动表单1234567891011121314151617181. 需要引入FormsModuleimport &#123; FormsModule &#125; from &#x27;@angular/forms&#x27;;2. 通过ngModel双向绑定属性,并设置校验规则&lt;input id=&quot;name&quot; name=&quot;name&quot; required minlength=&quot;4&quot; appForbiddenName=&quot;bob&quot; [(ngModel)]=&quot;name&quot; /&gt;3. 在html中设置错误提示&lt;div *ngIf=&quot;name.invalid &amp;&amp; (name.dirty || name.touched)&quot;class=&quot;alert alert-danger&quot;&gt;  &lt;div *ngIf=&quot;name.errors.required&quot;&gt;    Name is required.  &lt;/div&gt;  &lt;div *ngIf=&quot;name.errors.minlength&quot;&gt;    Name must be at least 4 characters long.  &lt;/div&gt;  &lt;div *ngIf=&quot;name.errors.forbiddenName&quot;&gt;    Name cannot be Bob.  &lt;/div&gt;&lt;/div&gt;\n\n\n\n\n\n\n\n\n\n\n优缺点:只有简单修改html就能完成表单数据绑定和验证但当表单字段过多,会使HTML过于复杂\n2. 响应式表单\n\n\n\n\n\n\n\n\n优缺点:解耦HTML,针对大表单数据,易于维护代码编写比模板驱动表单复杂\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546471. 需要引入ReactiveFormsModuleimport &#123; ReactiveFormsModule &#125; from &#x27;@angular/forms&#x27;;2. 需要引入formGroup,formControl,FormBuilder,Validatorsimport &#123;FormBuilder,FormControl ,FormGroup, Validators&#125; from &#x27;@angular/forms&#x27;;3. e.g    HTML:    - 1. 首先得在html中定义FormGroup对象    &lt;form [formGroup]=&quot;liveChannel&quot; (ngSubmit)=&quot;onSubmit()&quot;&gt;&lt;/form&gt;        - 2. 定义FormController属性变量    &lt;input id=&quot;name&quot; name=&quot;name&quot; formControlName=&quot;name&quot; /&gt;          - 3.设置错误提示HTML    &lt;span class=&quot;error&quot; *ngIf=&quot;liveChannel.get(&#x27;name&#x27;).hasError(&#x27;required&#x27;) &amp;&amp; (liveChannel.get(&#x27;name&#x27;).touched || liveChannel.get(&#x27;name&#x27;).dirty)&quot;&gt;频道名称不能为空&lt;/span&gt;        TS:    - 1. 定义FormGroup对象    liveChannel: FormGroup;        - 2. 绑定表单,通过FormBuilder可简化    initForm() &#123;        this.liveChannel = this.fb.group(&#123;          name: [&#x27;&#x27;, [Validators.required, Validators.minLength(4), Validators.maxLength(32)]],          ...        &#125;);     &#125;         - 3. 编写提交方法    onSubmit() &#123;        for (const i in this.liveChannel.controls) &#123;          //设置控件状态为已修改值          this.liveChannel.controls[i].markAsDirty();          //设置控件状态为已失焦          this.liveChannel.controls[i].markAsTouched();          //触发每个formControl的验证事件          this.liveChannel.controls[i].updateValueAndValidity();        &#125;        //判断是否校验通过        if (this.liveChannel.valid) &#123;          //获取表单数据...进行后续操作          console.log(this.liveChannel.value);        &#125; else &#123;          console.log(&#x27;error&#x27;);        &#125;    &#125;\n\n\n\n\n\n\n\n\n\n解释:liveChannel.get(‘name’).hasError(‘required’):判断该控件是否有包含  required的错误liveChannel.get(‘name’).touched: 判断该控件是否有失焦liveChannel.get(‘name’).dirty: 判断该控件值是否有修改name: [‘’, [Validators.required, Validators.minLength(4), Validators.maxLength(32)]]: 第一个参数’’是用来绑定控件的初始值,第二个参数[]用于设置该控件的校验规则\n","slug":"Angular中表单校验","date":"2020-11-23T06:01:10.000Z","categories_index":"Angular","tags_index":"Angular,表单效验","author_index":"Weiba"},{"id":"426c2df2123a8c9ebb620e7b7f9b2ec7","title":"Angular中的模块","content":"8.Angular中的模块1. 创建自定义模块1234ng g module 路径创建带路由的模块ng g module 路径 --routing\n\n2. 使用自定义模块1234567891011121314151617181920212223242526272829303132333435363738e.g:    1. 创建自定义模块        ng g module modules/user --routing            2. 创建模块下子组件        ng g component modules/user/components/address            3. 创建模块根组件        ng g component modules/user            4. 在自定义模块中暴露出想在根组件中使用的子组件    @NgModule(&#123;      declarations: [模块下的子组件],      imports: [        CommonModule,        LiveChannelRoutingModule      ],      exports:[想暴露出去的子组件]    &#125;)        5. 在根模块中导入自定义模块,即在app.module.ts文件中修改    import &#123; 自定义模块 &#125; from &#x27;./live-channel/live-channel.module&#x27;;        @NgModule(&#123;      declarations: [        AppComponent,        HeaderComponent,        FooterComponent,        MenuComponent      ],      imports: [        BrowserModule,        AppRoutingModule,        自定义模块,      ],      providers: [],      bootstrap: [AppComponent]    &#125;)","slug":"Angular中的模块","date":"2020-11-23T06:00:40.000Z","categories_index":"Angular","tags_index":"Angular,模块","author_index":"Weiba"},{"id":"916332084fd7dc942b98c22c9189dcf4","title":"Angular中的路由","content":"7.Angular中的路由1. 路由123456789101112131415161718- 路由: 即根据不同的url地址,动态的让根组件挂载其他组件,来实现一个单页面应用程序- 带路由模块的项目比起不带路由项目中:    1. 在app目录下多一个app-routing.modules.ts,即路由的配置文件    2. 在app.modules.ts中引入了路由模块,并注入        import &#123;AppRoutingModule&#125; from &#x27;./app-routing.module&#x27;;                @NgModule(&#123;            ...            imports:[                BrowserModule,                AppRoutingModule            ]            ...        &#125;)    3.在根组件的html中新增了标签        &lt;router-outlet&gt;&lt;/router-outlet&gt;\n\n2. 路由的使用1234567891011121314151617181920212223241. 需要在路由的配置文件app-routing.modules.ts中,引入使用路由的组件    import &#123;xxxComponent&#125; from &#x27;../components/xxx&#x27;;    2. 配置路由    const routes: Routes = [        &#123;path:&#x27;xxx&#x27;,component:xxxComponenet&#125;,        ...        &#123;path:&#x27;**&#x27;,redirectTo:&#x27;xxxPath&#x27; | component:xxxComponenet&#125;    ]        path: url地址    component: 访问对应path,需要挂载的组件        path:&#x27;**&#x27;,即任意路由,一般用于匹配其他值或默认值(类似switch中的default)    redirectTo: 跳转的路由(也可配置component,挂载对应的路由,一般还是跳转)    3. 组件模板中使用路由(使用routerLink),并配置router-outlet来显示动态加载的路由组件视图    // routerLink即路由path,可配置为动态(即使用 [] ),也可为静态    &lt;a [routeLink]=&#x27;/home&#x27;&gt;首页&lt;/a&gt;    &lt;router-outlet&gt;&lt;/router-outlet&gt;    4. 路由选中状态    //给路由的标签加上routerLinkActive属性,属性值即class名,在css样式文件中设置样式即可    &lt;a [routeLink]=&#x27;/home&#x27; routerLinkActive=&quot;active&quot;&gt;首页&lt;/a&gt;\n\n3. 路由跳转传值\n路由get传值\n123456789101112131415161718// 例如 url=/xxx?aid=1231. 组件html中(前端)&lt;a [routeLink]=[&#x27;/home&#x27;] [queryParams]=&quot;&#123;aid:123,xxx:xxx,...&#125;&quot;&gt;首页&lt;/a&gt;2. 组件后台获取get传值//首先需要在组件后台引入ActivatedRouteimport &#123;ActivatedRoute&#125; from &#x27;@angular/router&#x27;;export class xxx implements OnInit&#123;    constructor( public route:ActivatedRoute)&#123;&#125;        ngOnInit()&#123;        //因为 this.route.queryParams 是一个RxJs对象,因此要通过subscribe()来获取        this.route.queryParams.subscribe((data)=&gt;&#123;            console.log(data.aid);        &#125;)    &#125;&#125;\n\n动态路由\n12345678910111213141516171819202122232425// 例如 url=/xxx/1231. 需要修改路由的配置文件//其中:aid为动态值,类似于java中的pathParamconst routes: Routes = [    &#123;path:&#x27;xxx/:aid&#x27;,component:xxxComponenet&#125;,]2. 组件html中(前端)//直接在routeLink中传递参数 &lt;a [routeLink]=[&#x27;/home&#x27;,data]&gt;首页&lt;/a&gt;   3. 组件后台获取值//首先需要在组件后台引入ActivatedRouteimport &#123;ActivatedRoute&#125; from &#x27;@angular/router&#x27;;export class xxx implements OnInit&#123;    constructor( public route:ActivatedRoute)&#123;&#125;        ngOnInit()&#123;        //因为 this.route.params也是一个RxJs对象,因此同样通过subscribe()来获取        this.route.params.subscribe((data)=&gt;&#123;            console.log(data.aid);        &#125;)    &#125;&#125;\n\n通过js跳转路由\n123456789101112131415161718192021222324252627282930同样分为2种,动态路由js跳转,以及路由getJs跳转1. js-动态路由跳转    - 需要引入Route模块    import &#123;Route&#125; from &#x27;@angular/router&#x27;;        - 注入route,通过route.navigate()进行跳转    export class xxx implements OnInit&#123;        constructor( public route:Route)&#123;&#125;                ngOnInit()&#123;&#125;                goDetail()&#123;            this.route.navigate([&#x27;url&#x27;,param]);        &#125;    &#125;    2. js-get传值跳转    - 需要引入NavigationExtras模块    import &#123;Route,NavigationExtras&#125; from &#x27;@angular/router&#x27;;        - 定义queryParams    let queryParams:NavigationExtras = &#123;        queryParams:&#123;&#x27;aid&#x27;:&#x27;xxx&#x27;&#125;    &#125;        this.route.navigate([&#x27;url&#x27;],queryParams);        //注意,动态路由,传值写在[]内,get传值,写在[]外    \n\n4. 父子路由(嵌套路由)12345678910111213只需要修改路由的配置文件,新增children属性const routes: Routes = [        &#123;            path:&#x27;xxx&#x27;,component:xxxComponenet            children:[                &#123;path:&#x27;xxx/children1&#x27;,component:xxxComponenet1&#125;,                &#123;path:&#x27;xxx/children2&#x27;,component:xxxComponenet2&#125;,                &#123;path:&#x27;xxx/**&#x27;,redirectTo:&#x27;xxx/children1&#x27;&#125;            ]        &#125;,        ...        &#123;path:&#x27;**&#x27;,redirectTo:&#x27;xxxPath&#x27; | component:xxxComponenet&#125;    ]","slug":"Angular中的路由","date":"2020-11-23T06:00:04.000Z","categories_index":"Angular","tags_index":"Angular,路由","author_index":"Weiba"},{"id":"21cec739d9353f83b2ea3174a0c5b537","title":"Angular中的生命周期函数","content":"5.Angular中的生命周期函数1. Angular中的生命周期函数1234567891011121314151617生命周期函数执行顺序,从上到下1. ngOnChanges(): 父子组件互相传值时会触发,首次触发一定在ngOnInit()之前2. ngOnInit(): 初始化组件以及指令(此时dom并未完全加载),一般将请求数据的操作放到这里3. ngDoCheck(): 可以做一些自定义操作,来监测数据是否变化4. ngAfterContentInit(): 组件渲染完成后调用5. ngAfterContentChecked(): 在每次组件渲染完成后,可以做一些自定义操作6. ngAfterViewInit(): 视图加载完成,一般在这里进行dom操作7. ngAfterViewChecked(): 在每次视图加载完成后,可以做一些自定义操作8. ngOnDestroy(): 组件销毁时触发\n\n\n\n\n\n\n\n\n\n构造方法不属于生命周期函数,在构造方法中,除了对成员变量初始化之外,其他什么都不应该做\n","slug":"Angular中的生命周期函数","date":"2020-11-23T05:58:53.000Z","categories_index":"Angular","tags_index":"Angular,生命周期","author_index":"Weiba"},{"id":"853392868a1566344a3a7642bacafe28","title":"Angular中在Rxjs中并行处理多个Observable","content":"15.Rxjs中并行处理多个Observable1. forkJoin1234567let o1 = new Observable();let o2 = new Observable();let o3 = new Observable();forkJoin([o1,o2,o3]).subscribe([r1,r2,r3]=&gt;&#123;    ...&#125;)\n\n\n\n\n\n\n\n\n\nforkJoin:当每个Observable都完成时,才会触发subscribe方法,即每个Observable对象内,都需要有observer.complete()\n2. combineLatest12345678let o1 = new Observable();let o2 = new Observable();let o3 = new Observable();combineLatest([o1,o2,o3]).subscribe([r1,r2,r3]=&gt;&#123;    ...&#125;)\n\n\n\n\n\n\n\n\n\ncombineLatest:第一次,需要所有Observable都有返回值,后面只要某一个监听的Observable,返回值有更新,都会触发subscribe方法\n","slug":"Angular中在Rxjs中并行处理多个Observable","date":"2020-11-23T05:58:15.000Z","categories_index":"Angular","tags_index":"Angular,Rxjs,Observable","author_index":"Weiba"},{"id":"eaf20d8c0e78dfcdaa662d58c5894839","title":"Angular中的指令","content":"14.Angular中的指令1. 指令类型\n\n\n\n\n\n\n\n\nAngular 中有三种类型的指令  \n\n组件 — 拥有模板的指令\n结构型指令 — 通过添加和移除 DOM 元素改变 DOM 布局的指令\n属性型指令 — 改变元素、组件或其它指令的外观和行为的指令\n\n2. 属性指令\n\n\n\n\n\n\n\n\n创建指令: ng generate directive xxxxx\n12345678910111213141516171819202122232425262728import &#123; Directive &#125; from &#x27;@angular/core&#x27;;@Directive(&#123;  selector: &#x27;[appHighlight]&#x27;&#125;)export class HighlightDirective &#123;  @Input() highlightColor: string;  constructor(el: ElementRef) &#123;     el.nativeElement.style.backgroundColor = this.highlightColor;  &#125;    @HostListener(&#x27;mouseenter&#x27;) onMouseEnter() &#123;    this.highlight(&#x27;yellow&#x27;);  &#125;    @HostListener(&#x27;mouseleave&#x27;) onMouseLeave() &#123;    this.highlight(null);  &#125;  &#125;el: ElementRef: ElementRef 通过其 nativeElement 属性给你了直接访问宿主 DOM 元素的能力。@Input(): 可以接收传递给指令的参数,不命名,默认和变量名称一样,也可以使用别名,即写成其他名字,如指令名,直接通过 [appHighlight]=&#x27;xxxx&#x27;,接收参数,并且可以写多个,来接收多个传入的参数@HostListener(): 让你订阅某个属性型指令所在的宿主 DOM 元素的事件\n\n\n\n3. 结构指令\n\n\n\n\n\n\n\n\n结构指令的作用是:塑造或重塑 DOM 的结构，比如添加、移除或维护这些元素, NgIf、NgFor和NgSwitch是常见的三个内置的结构型指令  \n\n\n\n\n\n\n\n\n\n一个宿主元素上只能有一个结构型指令\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162星号（*）前缀: 如*ngIf,星号是一个用来简化更复杂语法的“语法糖”。 从内部实现来说，Angular 把 *ngIf 属性 翻译成一个 &lt;ng-template&gt; 元素 并用它来包裹宿主元素实际解析代码如下:&lt;ng-template [ngIf]=&quot;hero&quot;&gt;  &lt;div class=&quot;name&quot;&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;/ng-template&gt;import &#123; Directive, Input, TemplateRef, ViewContainerRef &#125; from &#x27;@angular/core&#x27;;/** * Add the template content to the DOM unless the condition is true. * * If the expression assigned to `appUnless` evaluates to a truthy value * then the templated elements are removed removed from the DOM, * the templated elements are (re)inserted into the DOM. * * &lt;div *appUnless=&quot;errorCount&quot; class=&quot;success&quot;&gt; *   Congrats! Everything is great! * &lt;/div&gt; * * ### Syntax * * - `&lt;div *appUnless=&quot;condition&quot;&gt;...&lt;/div&gt;` * - `&lt;ng-template [appUnless]=&quot;condition&quot;&gt;&lt;div&gt;...&lt;/div&gt;&lt;/ng-template&gt;` * */@Directive(&#123; selector: &#x27;[appUnless]&#x27;&#125;)export class UnlessDirective &#123;  private hasView = false;  constructor(    private templateRef: TemplateRef&lt;any&gt;,    private viewContainer: ViewContainerRef) &#123; &#125;  @Input() set appUnless(condition: boolean) &#123;    if (!condition &amp;&amp; !this.hasView) &#123;      this.viewContainer.createEmbeddedView(this.templateRef);      this.hasView = true;    &#125; else if (condition &amp;&amp; this.hasView) &#123;      this.viewContainer.clear();      this.hasView = false;    &#125;  &#125;&#125;Input、TemplateRef 和 ViewContainerRef，你在任何结构型指令中都会需要它们TemplateRef:取得&lt;ng-template&gt;的内容ViewContainerRef:访问这个视图容器该指令的使用者会把一个 true/false 条件绑定到 [appUnless] 属性上。 也就是说，该指令需要一个带有 @Input 的 appUnless 属性。一旦该值的条件发生了变化，Angular 就会去设置 appUnless 属性。因为不能用 appUnless 属性，所以你要为它定义一个设置器（setter）。    1.如果条件为假，并且以前尚未创建过该视图，就告诉视图容器（ViewContainer）根据模板创建一个内嵌视图。    2.如果条件为真，并且视图已经显示出来了，就会清除该容器，并销毁该视图。没有人会读取 appUnless 属性，因此它不需要定义 getter。","slug":"Angular中的指令","date":"2020-11-23T05:56:50.000Z","categories_index":"Angular","tags_index":"Angular,指令","author_index":"Weiba"},{"id":"d4364c984cc79dd6b4a34500dd5c7bd3","title":"Angular中的打包部署","content":"13.Angular中的打包部署1.打包指令12345ng build --base-href xx --prod--base-href:指定在生成和识别URL时应保留的URL前缀。--prod: 指定生产模式,会压缩文件并去掉代码中的console\n\n\n2.实例1234567891011121314151617181920212223   # /lv/ 是nginx中监听的path- 打包,并指定前缀ng build --base-href /lv/  --aot --prod   - nginx中配置 location需要与ng打包的前缀一致location ^~ /lv &#123;\talias   D:/IdeaProject/ETS-Cloud_LiveService/front/live-manager/dist/live-manager; # 这是angular生成的dist文件夹存放的位置\tindex  index.html index.htm;\ttry_files $uri $uri/ /index.html =404; # 注意此句，一定要加上。否则配置的子路由等无法使用&#125;# 配置webSocket连接   location ^~ /live/websocket &#123;       proxy_pass http://live-microservice;       proxy_set_header Host $host;       proxy_set_header X-Real-IP $remote_addr;       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;       client_max_body_size 1000m;       proxy_set_header Upgrade $http_upgrade;  #ws配置       proxy_set_header Connection &quot;upgrade&quot;;   #ws配置   &#125;\n\n\n3.angular中编码方式获取APP-BASE-HREF\n\n\n\n\n\n\n\n\n1.第一种方式,通过index.html中的的值,来动态获取\n123456789101112131415161718192021222324252627282930313233343536/** * This function is used internal to get a string instance of the `&lt;base href=&quot;&quot; /&gt;` value from `index.html`. * This is an exported function, instead of a private function or inline lambda, to prevent this error: * * `Error encountered resolving symbol values statically.` * `Function calls are not supported.` * `Consider replacing the function or lambda with a reference to an exported function.` * * @param platformLocation an Angular service used to interact with a browser&#x27;s URL * @return a string instance of the `&lt;base href=&quot;&quot; /&gt;` value from `index.html` */export function getBaseHref(platformLocation: PlatformLocation): string &#123;    return platformLocation.getBaseHrefFromDOM();&#125;@NgModule(&#123;    declarations: [        AppComponent    ],    providers: [        &#123;            provide: APP_BASE_HREF,            useFactory: getBaseHref,            deps: [PlatformLocation]        &#125;    ],    bootstrap: [        AppComponent    ]&#125;)export class AppModule &#123; &#125;constructor(@Inject(APP_BASE_HREF) private baseHref: string) &#123;    console.log(`APP_BASE_HREF is $&#123;this.baseHref&#125;`);&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n通过指定LocationStrategy,通过Angular中LocationStrategy.getBaseHref()来获取\n\n123456789101112131415161718...import &#123; LocationStrategy, PathLocationStrategy &#125; from &#x27;@angular/common&#x27;;...@NgModule(&#123;  providers: [    ...    &#123;provide: LocationStrategy, useClass: PathLocationStrategy&#125;,    ...  ],  ...&#125;)export class AppModule &#123; &#125;constructor(private locationStrategy: LocationStrategy, ...) &#123;  console.log(this.locationStrategy.getBaseHref());  ...&#125;\n\n\n4.集成https12345678910111213141516171819202122232425262728293031   server &#123;\tlisten 8886 ssl;       server_name  xxx.com;       index index.html index.php;       ssl_certificate      /etc/ssl/hwlive/4464505_hwlive.enable-ets.com.pem;       ssl_certificate_key  /etc/ssl/hwlive/4464505_hwlive.enable-ets.com.key;       ssl_session_cache    shared:SSL:1m;       ssl_session_timeout  5m;       ssl_ciphers  ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;       ssl_prefer_server_ciphers  on;\t\tlocation ^~ /live/websocket &#123;        proxy_pass http://live-microservice;           proxy_set_header Host $host;           proxy_set_header X-Real-IP $remote_addr;           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;           client_max_body_size 1000m;           proxy_set_header Upgrade $http_upgrade;\t\tproxy_set_header Connection &quot;upgrade&quot;;        &#125;\t \t     location /lv &#123;           alias /home/icampus3.0/pkgs/live-microservice/dist/live-manager;   \t\tindex index.html index.htm;   \t\ttry_files $uri $uri/ /index.html =404;        &#125;&#125;","slug":"Angular中的打包部署","date":"2020-11-23T05:55:58.000Z","categories_index":"Angular","tags_index":"Angular,打包,部署","author_index":"Weiba"},{"id":"c54bc56e9a6984ec854ec855b661e852","title":"Angular中的路由守卫(Guard)","content":"11.路由守卫-Guard1.Guard123456有四种类型:    1.canActivate: 控制是否允许进入路由    2.canActivateChild: 等同于canActivate，只不过针对是所有子路由    3.canDeactivate: 控制是否允许离开路由    4.canLoad: 控制是否允许延迟加载整个模块\n\n\n\n\n\n属性名\n接口名\n\n\n\ncanActivate\nCanActivate\n\n\ncanActivateChild\nCanActivateChild\n\n\ncanDeactivate\nCanDeactivate\n\n\ncanLoad\nCanLoad\n\n\n\n\n\n\n\n\n\n\n\ncanDeactivate 需要指明具体的组件类名以外，其他接口只是将首字母大写而已。假定需要一个某个角色才能访问某些路由，就需要一个 CanActivate 守卫类。\n2. 如何使用12&#123; path: &#x27;auth&#x27;, component: GuardAuthComponent, canActivate: [ CanAuthProvide ] &#125;,&#123; path: &#x27;admin&#x27;, loadChildren: &#x27;./admin/admin.module#AdminModule&#x27;, canLoad: [ CanAuthProvide ] &#125;","slug":"Angular中的路由守卫(Guard)","date":"2020-11-23T05:55:16.000Z","categories_index":"Angular","tags_index":"Angular,Guard,路由守卫","author_index":"Weiba"},{"id":"ec5c1cad41982d5d9681c6467b72a951","title":"Angular中的拦截器","content":"10.Angular中的拦截器1. 拦截器12345678910111213141516171819202122232425261.需要实现HttpInterceptor接口@Injectable()export class SignInterceptor implements HttpInterceptor &#123;    intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt;&#123;        ...    &#125;&#125;2.暴露拦截器链import &#123; HTTP_INTERCEPTORS &#125; from &#x27;@angular/common/http&#x27;;import &#123;SignInterceptor&#125; from &#x27;./sign.interceptor&#x27;;//multi:true 表示有多个拦截器export const httpInterceptorProviders = [  &#123;provide: HTTP_INTERCEPTORS, useClass: SignInterceptor, multi: true&#125;,];3.在模块中使用拦截器@NgModule(&#123;  declarations: [...],  imports: [...],  providers: [httpInterceptorProviders]&#125;)","slug":"Angular中的拦截器","date":"2020-11-23T05:54:32.000Z","categories_index":"Angular","tags_index":"Angular,拦截器","author_index":"Weiba"},{"id":"7aef0660ec2ed29ddc3bc1051080913a","title":"Angular中的Dom操作以及父子组件通讯","content":"4.Angular中的Dom操作以及父子组件通讯1. 组件中获取Dom对象123组件中的ngOnInit()方法,是组件和指令初始化完成,并不是真正的dom加载完成  组件中还有一个ngAfterViewInit()方法,这个是视图加载完成,因此建议把dom操作都放在这个方法内\n2. 通过@ViewChild装饰器获取Dom对象123456789101112131415161718191.需要在html中给dom起一个名字,e.g:&lt;div #myBox&gt;&lt;/div&gt;2.在组件中引入viewChild,e.g:import &#123;Component,OnInit,ViewChild&#125; from &#x27;@angular/core&#x27;;3.通过@ViewChild装饰器获取Dom对象,通过类的成员变量,e.g:    export classs xxx implements OnInit &#123;                @ViewChild(&quot;myBox&quot;) myBox:any;                constructor()&#123;            ...        &#125;    &#125;4.在生命周期函数ngAfterViewInit中操作Dom对象,e.g://nativeElement才是dom对象this.myBox.nativeElement\n\n3. 通过@ViewChild获取子组件1234567891.在html中引入子组件,并命名,e.g:&lt;app-header #header &gt;&lt;/app-header&gt; &lt;div #myBox&gt;&lt;/div&gt;2.同获取dom对象一样,引入viewChild,创建成员变量接受组件实例,e.g: @ViewChild(&quot;header&quot;) header:any;4.在生命周期函数ngAfterViewInit中就可以调用子组件的方法:this.header.xxx()\n4. 组件中通讯1234567891011121314151617181920212223242526272829303132333435363738391.子组件调用父组件中的属性或方法(父组件 -&gt; 子组件 传值)    - 1. 父组件调用子组件时,需要传入数据,e.g:        &lt;app-header [msg]=&#x27;msg&#x27;&gt;&lt;/app-header&gt;                [msg]:是自定义属性,名称对应子组件中的成员变量        =&#x27;msg&#x27;:是父组件中所拥有的成员变量            - 2. 子组件中引入Input模块        import &#123;Component,OnInit,ViewChild,Input&#125; from &#x27;@angular/core&#x27;;        - 3. 子组件中通过@Input接收父组件传过来的数据        export classs xxx implements OnInit &#123;                    @Input() msg:string;                        constructor()&#123;                ...            &#125;        &#125;    //同理,可传递方法,以及父组件本身(传this),e.g:        &lt;app-header [msg]=&#x27;msg&#x27; [method]=&#x27;method&#x27; [parent]=&#x27;this&#x27;&gt;&lt;/app-header&gt;        2.父组件调用子组件中的属性或方法(子组件 -&gt; 父组件 传值)    可以通过@ViewChild来调用.同上    3.子组件通过@Output广播给父组件传值 (子组件 -&gt; 父组件 传值)    - 1. 子组件引入Output和EventEmitter,e.g:        import &#123;Component,OnInit,Output,EventEmitter&#125; from &#x27;@angular/core&#x27;;        - 2. 子组件中实例化EventEmitter        //相当于注册了一个广播节点        @Output private outer = new EventEmitter();            - 3. 父组件监听广播,即将广播节点传递给父组件        &lt;app-footer #footer (outer)=&#x27;run()&#x27;&gt;&lt;/app-footer&gt;                其中:(outer)对应子组件中广播节点的名称,run()是父组件的方法                ","slug":"Angular中的Dom操作以及父子组件通讯","date":"2020-11-23T05:53:55.000Z","categories_index":"Angular","tags_index":"Angular,Dom,父子组件通讯","author_index":"Weiba"},{"id":"06068962b522e5630d6e1e61ca839338","title":"Angular中的服务Service","content":"3.Angular中的服务1. 服务Service\n\n\n\n\n\n\n\n\nAngular中组件和组件之间是不能相互调用以及通讯的,因此,一般的公共方法都写到服务(Service)中.服务之间是可以相互调用的\n12345678910111.创建服务(Service)ng g service 目录/服务名称通过此命令创建的组件,会在app.module.ts中import引入此服务,并且在@NgModule的providers中添加2.使用服务需要在组件中先import引入此服务,在通过构造方法,将服务赋给组件,e.g: export class MyComponent Implements OnInit &#123;    constructor(public storageService:StorageService)&#123;        ...    &#125;&#125;","slug":"Angular中的服务Service","date":"2020-11-23T05:53:11.000Z","categories_index":"Angular","tags_index":"Angular,Service","author_index":"Weiba"},{"id":"81a97be8cb2174c7de758b6997cb9612","title":"Angular基础指令","content":"2.Angular基础指令1. 基础指令12345678910111213141516171819202122232425262728291. 数据绑定: 使用双大括号 &#123;&#123;xxx&#125;&#125;,例 &#123;&#123;name&#125;&#125;2. 属性绑定: 使用[属性名]=&quot;xxx&quot;,例 &lt;span [title]=&quot;xxx&quot;&gt;&lt;/span&gt;3. html绑定: [innerHTML]=&quot;xxx&quot; 4. 数据循环    &lt;li *ngFor=&quot;let item of xxx; let key=index&quot;&gt;        &#123;&#123;key&#125;&#125; ---  &#123;&#123;item&#125;&#125;    &lt;/li&gt;5. 条件判断:     *ngIf=&quot;条件表达式&quot;        [ngSwitch]=&quot;xxx&quot;,e.g:        &lt;span [ngSwitch]=&quot;xxx&quot;&gt;            &lt;p *ngSwitchCase=&quot;1&quot;&gt;结果1&lt;/p&gt;            &lt;p *ngSwitchCase=&quot;2&quot;&gt;结果2&lt;/p&gt;            &lt;p *ngSwitchDefault&gt;默认值&lt;/p&gt;        &lt;/span&gt;6. 动态改变class:    //flag为后台动态值    &lt;div [ngClass]=&quot;&#123;&#x27;red&#x27;:flag,&#x27;blue&#x27;:!flag&#125;&quot;&gt;&lt;/div&gt;7. 动态改变style:     //xxx为后台动态值    &lt;div [ngStyle]=&quot;&#123;&#x27;color&#x27;:xxx&#125;&quot;&gt;&lt;/div&gt;8. 管道    //例时间格式化管道    &#123;&#123;date | date:&#x27;yyyy-MM-dd HH:mm:ss&#x27;&#125;&#125;    9. 事件    //$event为事件对象,$event.target为当前dom对象    &lt;button (click)=&quot;xxx($event)&quot;&gt;点击事件&lt;button&gt;\n\n\n\n\n\n\n\n\n\nangular模板中允许简单的运算.e.g: 3其他管道请参考链接\n2. 双向数据绑定1234567891011121314151. 双向数据绑定,一般只用于表单,在Angular中使用,需要先引入表单模块    import &#123; FormsModule &#125; from &#x27;@angular/forms&#x27;;    @NgModule(&#123;        ...        imports: [            BrowserModule,            FormsModule        ],       ...    &#125;]    2. 双向数据绑定,使用[(ngModel)]=&#x27;xxx&#x27;    &lt;input type=&quot;text&quot; [(ngModel)]=&quot;keywords&quot;/&gt;    &lt;p&gt;&#123;&#123;keywords&#125;&#125;&lt;/p&gt;    ","slug":"Angular基础指令","date":"2020-11-23T05:52:09.000Z","categories_index":"Angular","tags_index":"Angular","author_index":"Weiba"},{"id":"63ae680989128f9ed17c2c80c9c6b8c5","title":"Angular基础","content":"1.Angular基础1. Angular环境搭建txt1. 安装node.js\n2. 安装cnpm  \n    npm install -g cnpm --registry=https://registry.npm.taobao.org\n3. 安装Angular脚手架\n   npm install -g @angular/cli     或者    cnpm install -g @angular/cli2. Angular创建项目txt1. 使用 ng new 项目名称,来创建Angular\n    ng new angulardemo\n 跳过npmi安装,请使用\n    ng new angulardemo --skip-install\n\n2. 运行项目\n    ng serve --open3. Angular项目目录文件介绍txt1. e2e : 端对端测试文件\n2. node_modules : 依赖库,存放的依赖文件\n3. src : 源代码(主要开发部分)\n4. angular.json : angular的配置文件\n5. package.json : 项目的配置文件\n6. tsconfig.json和tslint.json : ts的配置文件4. src目录详解txt1. app : 存放组件和根模块目录\n2. assets : 存放静态资源\n3. browserslist : 支持浏览器配置文件\n4. index.html : html入口文件\n5. karma.conf.js : 端对端测试文件\n6. main.js : 整个项目的入口\n7.style.scss : 全局的样式文件5. app目录详解txt1. app.module.ts : Angular根摸快,告诉浏览器如何组装应用  \n    BrowserModule:浏览器解析摸快  \n    NgModule:Angular核心模块\n    AppComponent:根组件\n    @NgModule:是一个装饰器,接受一个元数据对象,告诉Angular如何编译以及启动\n        declarations: 配置当前项目运行所需要的组件\n        imports: 配置当前项目运行所依赖的其他模块\n        providers: 配置项目所需要的服务\n        bootstarp: 指定应用主视图,一般放根组件\n        \n2. app.component.ts :组件定义文件\n    @Component: 组件装饰器\n        selector: 组件名称\n        templateUrl: 组件使用的html\n        styleUrls: 组建使用的css6. 组件txt1. 创建组件,使用angular-cli\n    ng g component 目录/组件名\n    通过此命令创建的组件,会在app.module.ts中import引入此组件,并且在@NgModule的declarations中添加","slug":"Angular基础","date":"2020-11-23T05:51:28.000Z","categories_index":"Angular","tags_index":"Angular","author_index":"Weiba"},{"id":"f5cbc0301f4d116b2f3249f5495844f0","title":"Idea 设置及插件记录","content":"\n\n\n\n\n\n\n\n\n 记录下新环境的配置\n生成类&#x2F;接口注释设置位置: Setting-Editor-File and Code Templates-Class|Interface\n12345678/**** $&#123;description&#125;** @author caleb_liu@enable-ets.com** @create $&#123;DATE&#125;**/\n\n添加类&#x2F;接口注释模板设置位置: Setting-Editor-Live Templates, 在 Java 中添加一个模板或新建一个模板组, 注意不要开头不要写 /, 会使 idea 内置方法失效, 使用方法: 在类或方法上使用 / + 触发关键字\n1234567**** $description$** @author xxx* @since $date$ **/\n\n\n\n\n\n\n\n添加方法注释模板12345678** * $description$ * @date $date$ $time$ * @since caleb_liu@enable-ets.com$params$$return$$throws$ */\n\nparams 脚本 :\n1groovyScript(&quot;if(\\&quot;$&#123;_1&#125;\\&quot;.length() == 2) &#123;return &#x27;&#x27;;&#125; else &#123;def result=&#x27;&#x27;; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList();for(i = 0; i &lt; params.size(); i++) &#123;if(i&lt;(params.size()-1))&#123;result+=&#x27; * @param &#x27; + params[i] + &#x27; : &#x27; + &#x27;\\\\n&#x27;&#125;else&#123;result+=&#x27; * @param &#x27; + params[i] + &#x27; : &#x27;&#125;&#125;; return result;&#125;&quot;, methodParameters()); \n\nreturn 脚本:\n1groovyScript(&quot;def returnType = \\&quot;$&#123;_1&#125;\\&quot;; def result = &#x27; * @return &#x27; + returnType; return result;&quot;, methodReturnType());\n\n\n\n\n\n编码设置设置位置: Setting-Editor-File Encodings   全部勾选 UTF-8 . \n\n\n忽略文件设置位置: Setting-Editor-File Types-Ignore Files and Folders , 添加 &quot;.*; *.iml&quot;\n插件服务器管理工具,  自带arthas 诊断工具: Alibaba Cloud Toolkit \nMybatis 跳转插件: &#96;Free Mybatis plugin&#96;&#96;\nMybatis  sql 生成插件: MyBatis Log Plugin \n控制台日志过滤插件: Grep Console\n热部署套装: JRebel and XRebel for IntelliJ 和 JRebel MybatisPlus, 激活地址: http://120.78.90.245:8081/06219f8c-42a9-4d40-b809-048ed91f87bf\nLombok 支持 : Lombok \nMaven 扩展: &#96;Maven Helper\n接口跳转插件: RestfulTool\n翻译: Translation\n\n\n\n\n","slug":"Idea-设置及插件记录","date":"2020-10-14T01:30:19.000Z","categories_index":"Idea","tags_index":"Idea","author_index":"Weiba"},{"id":"f37e90084f71b064e32056ae6b93b141","title":"Idea 自动生成 PO 脚本","content":"\n\n\n\n\n\n\n\n\n使用 Groovy 脚本生成对应的PO, 非 Mybatis逆向工程生成, \n来自: IDEA – 自动生成POJO\nGroovy脚本记录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import com.intellij.database.model.DasTableimport com.intellij.database.model.ObjectKindimport com.intellij.database.util.Caseimport com.intellij.database.util.DasUtilimport java.text.DateFormatimport java.text.SimpleDateFormat/* * Available context bindings: *   SELECTION   Iterable&lt;DasObject&gt; *   PROJECT     project *   FILES       files helper */packageName = &quot;com.xxx.po;&quot;  //这里要换成自己项目 实体的包路径typeMapping = [        (~/(?i)int/)                      : &quot;Integer&quot;,  //数据库类型和Jave类型映射关系        (~/(?i)float|double|decimal|real/): &quot;Double&quot;,        (~/(?i)bool|boolean/)             : &quot;Boolean&quot;,        (~/(?i)datetime|timestamp/)       : &quot;java.util.Date&quot;,        (~/(?i)date/)                     : &quot;java.sql.Date&quot;,        (~/(?i)time/)                     : &quot;java.sql.Time&quot;,        (~/(?i)/)                         : &quot;String&quot;]FILES.chooseDirectoryAndSave(&quot;Choose directory&quot;, &quot;Choose where to store generated files&quot;) &#123; dir -&gt;    SELECTION.filter &#123; it instanceof DasTable &amp;&amp; it.getKind() == ObjectKind.TABLE &#125;.each &#123; generate(it, dir) &#125;&#125;def generate(table, dir) &#123;    def className = javaName(table.getName(), true) + &quot;PO&quot;    def fields = calcFields(table)    new File(dir, className + &quot;.java&quot;).withPrintWriter(&quot;utf-8&quot;) &#123; out -&gt; generate(out, table, className, fields) &#125;&#125;def generate(out, table, className, fields) &#123;    def tableName = table.getName()    out.println &quot;package $packageName&quot;    out.println &quot;&quot;    out.println &quot;import lombok.*;&quot;    out.println &quot;&quot;    out.println &quot;import javax.persistence.*;&quot;    out.println &quot;&quot;    out.println &quot;/**&quot;    out.println &quot; * @author xxx&quot;    out.println &quot; **/&quot;    out.println &quot;@Data&quot;    out.println &quot;@Entity&quot;    out.println &quot;@Table(name = \\&quot;$tableName\\&quot;)&quot;    out.println &quot;public class $className &#123;&quot;    out.println &quot;&quot;    // 这里如果需要生成id字段需要打开    if ((tableName + &quot;_id&quot;).equalsIgnoreCase(fields[0].colum) || &quot;id&quot;.equalsIgnoreCase(fields[0].colum)) &#123;        out.println &quot;    @Id&quot;        out.println &quot;    @GeneratedValue(strategy=GenerationType.IDENTITY)&quot;    &#125;    fields.each() &#123;        if (it.comment != &quot;&quot; &amp;&amp; it.comment != null) &#123;            out.println &quot;    /**&quot;            out.println &quot;      * $&#123;it.comment&#125;&quot;            out.println &quot;      **/&quot;        &#125;        if (it.annos != &quot;&quot;) out.println &quot;  $&#123;it.annos&#125;&quot;        if (it.colum != it.name) &#123;            out.println &quot;    @Column(name = \\&quot;$&#123;it.colum&#125;\\&quot;)&quot;        &#125;        out.println &quot;    private $&#123;it.type&#125; $&#123;it.name&#125;;&quot;        out.println &quot;&quot;    &#125;    out.println &quot;&#125;&quot;&#125;def calcFields(table) &#123;    DasUtil.getColumns(table).reduce([]) &#123; fields, col -&gt;        def spec = Case.LOWER.apply(col.getDataType().getSpecification())        def typeStr = typeMapping.find &#123; p, t -&gt; p.matcher(spec).find() &#125;.value        fields += [[                           name   : javaName(col.getName(), false),                           colum  : col.getName(),                           type   : typeStr,                           comment: col.getComment(),                           annos  : &quot;&quot;]]    &#125;&#125;def javaName(str, capitalize) &#123;    def s = str.split(/(?&lt;=[^\\p&#123;IsLetter&#125;])/).collect &#123; Case.LOWER.apply(it).capitalize() &#125;            .join(&quot;&quot;).replaceAll(/[^\\p&#123;javaJavaIdentifierPart&#125;]/, &quot;_&quot;).replaceAll(/_/, &quot;&quot;)    capitalize || s.length() == 1 ? s : Case.LOWER.apply(s[0]) + s[1..-1]&#125;\n\n","slug":"Idea-自动生成-PO-脚本","date":"2020-09-30T05:28:48.000Z","categories_index":"Idea","tags_index":"Idea,Java","author_index":"Weiba"},{"id":"3bdfbcd280906945c52159d485008d9b","title":"Linux 安装配置 Elasticsearch-2.4.6","content":"\n\n\n\n\n\n\n\n\nES最新版已经到 7.x 了,  想用最新版啊, 多了很多特性.但是这个环境是做业务测试的, 原来用的就是 2.4.6 , 防止出问题, 延续了.\n下载安装进入工作目录, 执行即可:\n123wget https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/tar/elasticsearch/2.4.6/elasticsearch-2.4.6.tar.gztar -zxvf elasticsearch-2.4.6.tar.gzcd elasticsearch-2.4.6/ \n\n基础配置编辑 vim config/elasticsearch.yml 文件, 放开以下配置的注释并修改.\n12345cluster.name: test-esnode.name: masternetwork.host: 192.168.134.22 # http.port: 8200discovery.zen.ping.unicast.hosts: [&quot;192.168.100.35&quot;]\n\n启动和关闭启动1./bin/elasticsearch -Des.insecure.allow.root=true \n\n守护模式1./bin/elasticsearch -Des.insecure.allow.root=true -d \n\n关闭直接 kill 进程\n1kill -9 pid\n\n加个脚本vim start.sh \n1234#!/bin/bashecho &quot;elasticsearch start...&quot;/home/icampus3.0/elasticsearch-2.4.6/bin/elasticsearch -Des.insecure.allow.root=true -d\n\nvim stop.sh\n12345678#!/bin/bash#created by codeecho &quot;elasticsearch stoped.....&quot;pid=$(ps aux|grep -v grep|grep &quot;elasticsearch&quot;|awk &#x27;&#123;print $2&#125;&#x27;);if [[ $pid -gt 1 ]]; then    kill -9 $pidfi\n\nvim restart.sh\n12345#!/bin/bashcd /home/icampus3.0/elasticsearch-2.4.6./stop.sh./start.sh\n\n给权限 :\nchmod 755 start.sh stop.sh restart.sh\n","slug":"Linux-安装配置-ElasticSearch-2-4-6","date":"2020-09-29T08:01:01.000Z","categories_index":"ElasticSearch","tags_index":"Linux,Elasticsearch","author_index":"Weiba"},{"id":"d541a36f3dacb48a21926b2d741c0c48","title":"Linux Mycat 安装","content":"\n\n\n\n\n\n\n\n\n最近有个数据迁移需求, 量比较大, 搞个新环境测试下~ \n以下内容参考至官方文档: https://github.com/MyCATApache/Mycat-Server/wiki\n下载 Mycat官网下载后解压即可.\n目录说明1234--bin\t\t启动目录--conf\t\t配置文件存放配置文件--lib\t\tMyCAT自身的jar包或依赖的jar包的存放目录。--logs\t\tMyCAT日志的存放目录。日志存放在logs/log中，每天一个文件\n\n运行Linux 相关脚本:\n123456789101112131415./mycat start 启动./mycat stop 停止./mycat console 前台运行./mycat install 添加到系统自动启动（暂未实现）./mycat remove 取消随系统自动启动（暂未实现）./mycat restart 重启服务./mycat pause 暂停./mycat status 查看启动状态\n\n配置 MycatMycat 最重要的3大配置文件：\n服务配置 server.xmlsystem  参数是所有的 mycat 参数配置，比如添加解析器：defaultSqlParser，其他类推  user  是用户参数。\n添加两个 mycat 逻辑库：user  和 pay.\n123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mycat:server SYSTEM &quot;server.dtd&quot;&gt;&lt;mycat:server xmlns:mycat=&quot;http://io.mycat/&quot;&gt;\t&lt;system&gt;\t\t&lt;property name=&quot;defaultSqlParser&quot;&gt;druidparser&lt;/property&gt;\t\t&lt;property name=&quot;mutiNodeLimitType&quot;&gt;1&lt;/property&gt;\t\t&lt;property name=&quot;serverPort&quot;&gt;3309&lt;/property&gt;\t\t&lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt;\t\t&lt;property name=&quot;processors&quot;&gt;16&lt;/property&gt;\t\t&lt;property name=&quot;processorExecutor&quot;&gt;16&lt;/property&gt;\t\t&lt;property name=&quot;useOffHeapForMerge&quot;&gt;0&lt;/property&gt;\t&lt;/system&gt;\t&lt;!-- 任意设置登陆 mycat 的用户名,密码,数据库  --&gt;\t&lt;user name=&quot;mycat&quot;&gt;\t\t&lt;property name=&quot;password&quot;&gt;xxx&lt;/property&gt;\t\t&lt;property name=&quot;schemas&quot;&gt;xxx_schemas&lt;/property&gt;\t&lt;/user&gt;&lt;/mycat:server&gt;\n\n逻辑库配置 schema.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;\t&lt;!-- 设置表的存储方式.schema name=&quot;TESTDB&quot; 与 server.xml中的 TESTDB 设置一致  --&gt;\t&lt;schema name=&quot;xxx_schemas&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;2000&quot;&gt;\t\t&lt;!-- 全局表 dataNode 都会写一份 --&gt;\t\t&lt;table name=&quot;t_as_subject&quot; primaryKey=&quot;id&quot; dataNode=&quot;node_0$1-4&quot; type=&quot;global&quot;/&gt;\t\t\t        &lt;!-- rule 为分库规则, 这里使用一致性HASH分库, childTable 数据会与父级分到同一个库中 --&gt;\t\t&lt;table name=&quot;t_as_question&quot; primaryKey=&quot;question_id&quot; dataNode=&quot;node_0$1-4&quot; rule=&quot;sharding-by-murmur-question_id&quot;&gt;\t\t\t&lt;childTable name=&quot;t_as_question_option&quot; primaryKey=&quot;question_option_id&quot; joinKey=&quot;question_id&quot; parentKey=&quot;question_id&quot;/&gt;\t\t&lt;/table&gt;\t\t&lt;table name=&quot;t_as_option&quot; primaryKey=&quot;option_id&quot; dataNode=&quot;node_0$1-4&quot; rule=&quot;sharding-by-murmur-option_id&quot;/&gt;\t&lt;/schema&gt;\t&lt;!-- 设置dataNode 对应的数据库,及 mycat 连接的地址dataHost --&gt;\t&lt;dataNode name=&quot;node_01&quot; dataHost=&quot;resource-cluster&quot; database=&quot;question_storage_00&quot; /&gt;\t&lt;dataNode name=&quot;node_02&quot; dataHost=&quot;resource-cluster&quot; database=&quot;question_storage_01&quot; /&gt; \t&lt;dataNode name=&quot;node_03&quot; dataHost=&quot;resource-cluster&quot; database=&quot;question_storage_02&quot; /&gt;\t&lt;dataNode name=&quot;node_04&quot; dataHost=&quot;resource-cluster&quot; database=&quot;question_storage_03&quot; /&gt;\t\t&lt;dataHost name=&quot;resource-cluster&quot; maxCon=&quot;1000&quot; minCon=&quot;50&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&gt;\t\t&lt;!--心跳检测 --&gt;\t\t\t&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;\t\t\t\t&lt;!-- can have multi write hosts --&gt;\t&lt;writeHost host=&quot;hostM1&quot; url=&quot;127.0.0.1:3306&quot; user=&quot;root&quot; password=&quot;test123&quot;/&gt;\t&lt;/dataHost&gt;&lt;/mycat:schema&gt;\n\n分库规则 rule.xml定义 schema.xml table 标签绑定的分库规则:\n1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- - - Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); \t- you may not use this file except in compliance with the License. - You \tmay obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 \t- - Unless required by applicable law or agreed to in writing, software - \tdistributed under the License is distributed on an &quot;AS IS&quot; BASIS, - WITHOUT \tWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the \tLicense for the specific language governing permissions and - limitations \tunder the License. --&gt;&lt;!DOCTYPE mycat:rule SYSTEM &quot;rule.dtd&quot;&gt;&lt;mycat:rule xmlns:mycat=&quot;http://io.mycat/&quot;&gt;\t&lt;tableRule name=&quot;sharding-by-murmur-question_id&quot;&gt;\t\t&lt;rule&gt;\t\t  &lt;columns&gt;question_id&lt;/columns&gt;\t\t  &lt;algorithm&gt;murmur&lt;/algorithm&gt;\t\t&lt;/rule&gt;\t&lt;/tableRule&gt;\t&lt;tableRule name=&quot;sharding-by-murmur-option_id&quot;&gt;\t\t&lt;rule&gt;\t\t  &lt;columns&gt;option_id&lt;/columns&gt;\t\t  &lt;algorithm&gt;murmur&lt;/algorithm&gt;\t\t&lt;/rule&gt;\t&lt;/tableRule&gt;\t&lt;function name=&quot;murmur&quot; class=&quot;io.mycat.route.function.PartitionByMurmurHash&quot;&gt;\t\t&lt;property name=&quot;seed&quot;&gt;0&lt;/property&gt;&lt;!-- 默认是0 --&gt;        &lt;property name=&quot;count&quot;&gt;4&lt;/property&gt;&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片 --&gt;        &lt;property name=&quot;virtualBucketTimes&quot;&gt;160&lt;/property&gt;&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍 --&gt;        &lt;!-- &lt;property name=&quot;weightMapFile&quot;&gt;weightMapFile&lt;/property&gt; 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1&gt;代替 --&gt;        &lt;property name=&quot;bucketMapPath&quot;&gt;/home/icampus3.0/mycat/bucketMapPath&lt;/property&gt;            &lt;!--    用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;\t&lt;/function&gt;&lt;/mycat:rule&gt;\n\nMycat 报错ERROR: No such file or directory (2)错误信息：\n12345678910ERROR  | wrapper  | 2020/09/28 14:27:27 | JVM exited while loading the application.STATUS | wrapper  | 2020/09/28 14:27:31 | Launching a JVM...ERROR  | wrapper  | 2020/09/28 14:27:31 | Unable to start JVM: No such file or directory (2)ERROR  | wrapper  | 2020/09/28 14:27:31 | JVM exited while loading the application.STATUS | wrapper  | 2020/09/28 14:27:36 | Launching a JVM...ERROR  | wrapper  | 2020/09/28 14:27:36 | Unable to start JVM: No such file or directory (2)ERROR  | wrapper  | 2020/09/28 14:27:36 | JVM exited while loading the application.FATAL  | wrapper  | 2020/09/28 14:27:36 | There were 5 failed launches in a row, each lasting less than 300 seconds.  Giving up.FATAL  | wrapper  | 2020/09/28 14:27:36 |   There may be a configuration problem: please check the logs.STATUS | wrapper  | 2020/09/28 14:27:36 | &lt;-- Wrapper Stopped\n\n原因可能是JVM参数没有配置或者配置错误,  查看  wrapper.conf  中 wrapper.java.command 路径是否正确:\n1wrapper.java.command=/home/icampus3.0/jdk_1.8.0_212/bin/java\n\nERROR: 元素类型为 “mycat:rule” 的内容必须匹配 “(tableRule*,function*)”错误信息:\n1234567891011121314151617181920212223242526272829303132333435363738394041INFO   | jvm 1    | 2020/09/28 14:36:45 | WrapperSimpleApp: Encountered an error running main: java.lang.ExceptionInInitializerErrorINFO   | jvm 1    | 2020/09/28 14:36:45 | java.lang.ExceptionInInitializerErrorINFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.MycatStartup.main(MycatStartup.java:53)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at java.lang.reflect.Method.invoke(Method.java:498)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at java.lang.Thread.run(Thread.java:748)INFO   | jvm 1    | 2020/09/28 14:36:45 | Caused by: io.mycat.config.util.ConfigException: org.xml.sax.SAXParseException; lineNumber: 26; columnNumber: 14; 元素类型为 &quot;mycat:rule&quot; 的内容必须匹配 &quot;(tableRule*,function*)&quot;。INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.config.loader.xml.XMLRuleLoader.load(XMLRuleLoader.java:95)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.config.loader.xml.XMLRuleLoader.&lt;init&gt;(XMLRuleLoader.java:64)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.config.loader.xml.XMLSchemaLoader.&lt;init&gt;(XMLSchemaLoader.java:74)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.config.loader.xml.XMLSchemaLoader.&lt;init&gt;(XMLSchemaLoader.java:87)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.config.ConfigInitializer.&lt;init&gt;(ConfigInitializer.java:74)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.config.MycatConfig.&lt;init&gt;(MycatConfig.java:72)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.MycatServer.&lt;init&gt;(MycatServer.java:144)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.MycatServer.&lt;clinit&gt;(MycatServer.java:96)INFO   | jvm 1    | 2020/09/28 14:36:45 |       ... 7 moreINFO   | jvm 1    | 2020/09/28 14:36:45 | Caused by: org.xml.sax.SAXParseException; lineNumber: 26; columnNumber: 14; 元素类型为 &quot;mycat:rule&quot; 的内容必须匹配 &quot;(tableRule*,function*)&quot;。INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:203)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.error(ErrorHandlerWrapper.java:134)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:396)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:327)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:284)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator.handleEndElement(XMLDTDValidator.java:1994)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator.endElement(XMLDTDValidator.java:879)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanEndElement(XMLDocumentFragmentScannerImpl.java:1782)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2967)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:602)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:505)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:842)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:771)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:243)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:339)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at javax.xml.parsers.DocumentBuilder.parse(DocumentBuilder.java:121)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.config.util.ConfigUtil.getDocument(ConfigUtil.java:115)INFO   | jvm 1    | 2020/09/28 14:36:45 |       at io.mycat.config.loader.xml.XMLRuleLoader.load(XMLRuleLoader.java:86)INFO   | jvm 1    | 2020/09/28 14:36:45 |       ... 14 moreSTATUS | wrapper  | 2020/09/28 14:36:47 | &lt;-- Wrapper Stopped\n\n这个错误原因是 rule.xml 中 function 配置内容不能在 tableRule 配置之前, 调换下顺序即可\n1234567891011121314&lt;tableRule name=&quot;sharding-by-murmur&quot;&gt;    &lt;rule&gt;        &lt;columns&gt;id&lt;/columns&gt;        &lt;algorithm&gt;murmur&lt;/algorithm&gt;    &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name=&quot;murmur&quot; class=&quot;io.mycat.route.function.PartitionByMurmurHash&quot;&gt;    &lt;property name=&quot;seed&quot;&gt;0&lt;/property&gt;&lt;!-- 默认是0 --&gt;    &lt;property name=&quot;count&quot;&gt;4&lt;/property&gt;&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片 --&gt;    &lt;property name=&quot;virtualBucketTimes&quot;&gt;160&lt;/property&gt;&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍 --&gt;    &lt;!-- &lt;property name=&quot;weightMapFile&quot;&gt;weightMapFile&lt;/property&gt; 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1&gt;代替 --&gt;    &lt;property name=&quot;bucketMapPath&quot;&gt;/home/mycat/bucketMapPath&lt;/property&gt;        &lt;!--    用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;&lt;/function&gt;\n\nNavicat 打开表报错: find no route错误信息:\n \n\n修改 schema.xml 的 checkSQLschema=“false” , 改为 true 即可. \n当该值为 true 时，例如我们执行语句 select * from TESTDB.company. mycat 会把语句修改为 select * from company  去掉 TESTDB。\n1&lt;schema name=&quot;db_store&quot; checkSQLschema=&quot;true&quot; sqlMaxLimit=&quot;100&quot;&gt;\n\nSQL 排序报错: all columns in order by clause should be in the selected column list!xxx这是 mycat 的一个 bug ，无法识别sql中的 ` 符号, 去掉  sql 中的 ` 号即可.\n详情: mycat执行sql报 all columns in group by clause should be in the selected column list.!logis_id错误\n源码: \n\n\nMycat 插入报错:  Unknown column ‘_mycat_op_time’ in ‘field list’这个是由参数 useGlobleTableCheck 控制的全局表一致性检测，原理通过在全局表增加 _MYCAT_OP_TIME 字段来进行一致性检测，类型为 bigint，create语句通过 mycat 执行会自动加上这个字段，其他情况请自己手工添加。 \n在创建全局表类型的表时添加这个字段: \n1`_mycat_op_time` bigint(20) DEFAULT NULL\n\n","slug":"Linux-Mycat-安装","date":"2020-09-28T03:13:46.000Z","categories_index":"Mycat","tags_index":"Linux,Mycat,_mycat_op_time","author_index":"Weiba"},{"id":"76d5c77f5891921bb88d3dcae699a119","title":"Linux JDK 8 安装","content":"\n\n\n\n\n\n\n\n\ndemo新环境, 非Docker记录一下~\n下载JDK8Oracle 下载需要注册, 直接去github上下载~~ \n项目地址: oracle-java\nJDK8 Linux x64 下载地址: jdk-8u212-linux-x64.tar.gz\n上传至服务器解压即可~\n配置环境变量在文件 /etc/profile 末尾添加 JAVA 相关环境变量:\n123456vim /etc/profileJAVA_HOME=/home/icampus3.0/jdk_1.8.0_212JRE_HOME=$JAVA_HOME/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH\n\n应用环境变量:\n1source /etc/profile\n\n检查一下命令行执行:\n1java -version\n\n","slug":"Linux-JDK-8-安装","date":"2020-09-28T03:03:07.000Z","categories_index":"JDK","tags_index":"Linux,JDK8","author_index":"Weiba"},{"id":"0ba36a39af1ad225c0b1ce2dd6022e39","title":"Mysql 常用命令","content":"\n\n\n\n\n\n\n\n\n记录一下平时用到的命令\n导入 sql : \n1source /var/xxx.sql\n\nCentOS 7 开启关闭Mysql12systemctl mysqld startsystemctl mysqld stop\n\n","slug":"Mysql-常用命令","date":"2020-09-28T01:14:48.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"Weiba"},{"id":"a30ac6a54ea09f38ac5d37e16d5ad5e0","title":"Hexo Next 主题设置优化","content":"\n\n\n\n\n\n\n\n\n next 主题相当有名, 不过默认配置看起来略微单调. 搜索了一下, 觉得这篇  使用 Github 空间搭建 Hexo 技术博客——使用NexT优化博客  相当不错, 记录一下.\n可能是版本不同, 还是略微有点差异的.\n主题配置 next 配置为 theme/next/_config.yaml 文件, 直接用vim或其他编辑器修改, 保存即可生效, 不用重启 hexo\n开启需要的导航栏在 next 配置中找到 menu 看看自己博客所需的导航栏, 需要开启的将头部 # 号删除即可.\n123456789menu:  home: / || fa fa-home # 首页  about: /about/ || fa fa-user # 关于  tags: /tags/ || fa fa-tags # 标签  categories: /categories/ || fa fa-th # 分类  archives: /archives/ || fa fa-archive # 归档  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat        \n\n显示如下:\n\n\nmenu_settings 配置控制是否显示导航栏的图标和对应的文章数量\n123menu_settings:  icons: true # 是否显示图标  badges: false # 是否显示文章数量\n\n创建导航栏对应的页面命令行窗口进入项目目录执行\n1234$ hexo new page about   #看看menu上还有什么标签没创建就行创建$ hexo new page tags    #创建标签$ hexo new page categories #创建分类$ hexo new page achives #创建归档\n\n创建完成之后我们在自己项目查找，如我的是 myblog/source/ 目录下查看新创建好的相关标签页面，里面包含各自的index.md文件，大家可以自行编辑了。\nSchemes方案设置页面结构修改:\n12345# Schemes#scheme: Muse  #这是 Nex默认版本，黑白主调，大量留白#scheme: Mist  #Muse 的紧凑版本，整洁有序的单栏外观#scheme: Pisces #双栏 Scheme，小家碧玉似的清新scheme: Gemini  #双子座，也是双栏形式，和Pisces类似\n\n\n\nSocial 修改12345678910111213141516social:  GitHub: https://github.com/xweiba || fab fa-github  E-Mail: mailto:xiaoweiba1028@gmail.com || fa fa-envelope  #Weibo: https://weibo.com/yourname || fab fa-weibo  #Google: https://plus.google.com/yourname || fab fa-google  #Twitter: https://twitter.com/yourname || fab fa-twitter  #FB Page: https://www.facebook.com/yourname || fab fa-facebook  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow  #YouTube: https://youtube.com/yourname || fab fa-youtube  #Instagram: https://instagram.com/yourname || fab fa-instagram  #Skype: skype:yourname?call|chat || fab fa-skypesocial_icons:  enable: true # 开启  icons_only: true # 只显示图标 不显示名称  transition: true\n\n\n\n头像设置12345678avatar:  # Replace the default image and set the url here.  url: https://avatars1.githubusercontent.com/u/24520686?s=400&amp;u=78b21dec789dfb9c51379f11ae2722672546e3a6&amp;v=4 #头像图片路径 图片放置在next/source/images  # If true, the avatar will be dispalyed in circle.  rounded: false #是否显示圆形头像，true表示圆形，false默认  # If true, the avatar will be rotated with the cursor.  rotated: false #是否旋转 true表示旋转，false默认  opacity: 0.7  #透明度0~1之间\n\n\n\ntoc边栏中的目录设置12345toc:  enable: true #是否启动侧边栏  number: true  #自动将列表编号添加到toc。  wrap: true #true时是当标题宽度很长时，自动换到下一行  max_depth: 6 # 最大深度\n\n\n\nCreative Commons 4.0国际许可设置\n\n\n\n开启pjax获取 theme-next-pjax 主题插件：\n1git clone https://github.com/theme-next/theme-next-pjax themes/next/source/lib/pjax\n\n修改 next 配置:\n123# Easily enable fast Ajax navigation on your website.# Dependencies: https://github.com/theme-next/theme-next-pjax  一般有 `Dependencies` 的都需要单独下载依赖pjax: true\n\n开启本地搜索修改 next 配置:\n12345678910111213# Local Search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false\n\n\n\n添加标签云标签云官方GitHub：hexo-tag-cloud\n在 hexo 根目录安装标签云依赖：npm install -save hexo-tag-cloud\n编辑主题模板文件 themes/next/layout/_macro/sidebar.swig ，添加标签云：\n1234567891011&#123;% if site.tags.length &gt; 1 %&#125;    &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123; url_for(&#x27;/js/tagcloud.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123; url_for(&#x27;/js/tagcanvas.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;    &lt;div class=&quot;widget-wrap&quot;&gt;        &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt;            &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width:100%&quot;&gt;                &#123;&#123; list_tags() &#125;&#125;            &lt;/canvas&gt;        &lt;/div&gt;    &lt;/div&gt;&#123;% endif %&#125;\n\n\n\n图片放大插件修改 next 配置文件，开启 fancybox 功能：\n123456789fancybox: truevendors:  jquery: //cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js  fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js  fancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.csscustom_file_path:  # 开启 fancybox 后片文章会显示图描叙，暂未看到配置选项，使用自定义样式隐藏掉。  style: source/_data/styles.styl \n\nsource/_data/styles.styl 配置：\n123.fancybox .image-caption &#123;\tdisplay: none;&#125;\n\n\n\n开启阅读进度修改 next 配置：\n123456reading_progress:  enable: true  # Available values: top | bottom  position: top  color: &quot;#37c6c0&quot;  height: 3px\n\n\n\n开启页面加载进度获取 theme-next-pace 主题插件：\n1git clone https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace\n\n开启 next 配置:\n12345678910111213141516171819# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pace 插件地址 直接clone到lib中# For more information: https://github.com/HubSpot/pacepace:  enable: true  # Themes list:  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal  theme: flash  # 需要使用cdn的可以配置vendors:  # Internal version: 1.0.2  # pace: //cdn.jsdelivr.net/npm/pace-js@1/pace.min.js  # pace: //cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js  # pace_css: //cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css  # pace_css: //cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css  pace:  pace_css:\n\n\n\n开启几何动效背景获取 canvas-nest 主题插件：\n1git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest\n\n在 next 配置文件中添加：\n12345678910# 设置几何动效背景# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest:  enable: true  onmobile: true # display on mobile or not  color: &quot;0,0,255&quot; # RGB values, use `,` to separate  opacity: 0.5 # the opacity of line: 0~1  zIndex: -1 # z-index property of the background  count: 170 # the number of lines\n\n\n\n开启自动摘录注意 NexT 7.6.0 及更高版本需要安装 hexo-excerpt 插件, 安装完毕需要重启 hexo 才会生效\n安装 hexo-excerpt: \n1npm install hexo-excerpt --save\n\n修改 hexo 配置:\n12345excerpt:  depth: 3 # 摘录深度  excerpt_excludes: []  more_excludes: []  hideWholePostExcerpts: true\n\n另外：在文章内部加入 &lt;!--more--&gt; ，可以精确控制要显示的内容, hexo 会自动提供 阅读全文的按钮\n记住位置修改 next 配置文件：\n12bookmark:  enable: true\n\n刷新后浏览位置不会变化\n代码块设置修改 next 配置文件：\n123456789101112codeblock:  # Code Highlight theme  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic  # See: https://github.com/chriskempson/tomorrow-theme  highlight_theme: night eighties #代码高亮主题设置 设置喜欢的模式，默认：normal  # Add copy button on codeblock  copy_button:    enable: true #是否添加复制按钮    # Show text copy result.    show_result: true #是否显示文本复制结果    # Available values: default | flat | mac    style: mac # 代码块样式\n\n开启访问计数修改 next 配置文件：\n1234567891011# Show Views / Visitors of the website / page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi# 网站计数器busuanzi_count:  enable: true  total_visitors: true  total_visitors_icon: fa fa-user  total_views: true  total_views_icon: fa fa-eye  post_views: true  post_views_icon: fa fa-eye\n\n\n\n底部设置修改 next 配置文件：\n1234567footer:  icon:    name: user  #设置图标，想修改图标从https://fontawesome.com/v4.7.0/icons获取    animated: true  #红心是否要为图标设置动画，默认为false     color: &quot;#66CDAA&quot;  #图标颜色  beian:    enable: false # 备案设置, 没有就不填吧\n\n标签页图标修改 next 配置文件：\n12345favicon:  small: /images/favicon-16x16-next.png   #小图标 默认的NexT  medium: /images/favicon-32x32-next.png  #中图标 默认NexT  apple_touch_icon: /images/apple-touch-icon-next.png #苹果触摸图标  safari_pinned_tab: /images/logo.svg   #safari固定标签\n\n主题样式优化需在 next 配置文件中开启, 注意这个是项目为根目录的, 并不是主题的根目录:\n1234567891011custom_file_path:  #head: source/_data/head.swig  #header: source/_data/header.swig  #sidebar: source/_data/sidebar.swig  #postMeta: source/_data/post-meta.swig  #postBodyEnd: source/_data/post-body-end.swig  #footer: source/_data/footer.swig  #bodyEnd: source/_data/body-end.swig  #variable: source/_data/variables.styl  #mixin: source/_data/mixins.styl  style: source/_data/styles.styl # 样式\n\n主页文章添加阴影效果和圆角打开 source/_data/styles.styl 向里面添加:\n1234567891011121314151617181920212223242526// 文章添加圆角.post-block &#123;  padding: 40px;  background: #fff;  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);  border-radius: 0.5rem;&#125;.post-block + .post-block &#123;  border-radius: 0.5rem;&#125;// 文章下移10像素.main-inner &#123;  margin-top: 10px;&#125;// 导航栏 圆角 + 下移.header-inner &#123;  border-radius: 0.5rem;  margin-top: 10px;&#125;// 个人信息圆角.sidebar-inner &#123;  border-radius: 0.5rem;&#125;\n\nTravis-CI 脚本修改如有使用 Travis-CI , 需要重写下脚本~~\n12345678910111213141516171819202122232425262728os: linuxlanguage: node_js node_js:  - 10  # 使用 nodejs LTS v10branches:  only:    - source # 只监控 source 的 branchbefore_script: ## 根据你所用的主题和自定义的不同，这里会有所不同  - npm install -g hexo-cli # 在 CI 环境内安装 Hexo  - npm install # 安装 hexo 依赖  - git clone https://github.com/theme-next/hexo-theme-next themes/next # 安装 next 主题  - cp -rf next_tage_cloud_sidebar.swig themes/next/layout/_macro/sidebar.swig # 添加标签云 layout  - git clone https://github.com/theme-next/theme-next-pjax themes/next/source/lib/pjax # 安装 pjax 插件  - git clone https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace # 安装阅读进度  - git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest # 安装几何动效插件  - cp -rf _config.theme.next.yml themes/next/_config.yml # 设置 next 主题配置script:   - hexo generate # generate static filesdeploy: # 根据个人情况，这里会有所不同  provider: pages  skip_cleanup: true # 构建完成后不清除  token: $GH_TOKEN # 你刚刚设置的 Token  keep_history: true # 保存历史  #fqdn: blog.haukeng.me # 自定义域名，使用 username.github.io 可删除  on:    branch: source # hexo 站点源文件所在的 branch  local_dir: public   target_branch: master # 存放生成站点文件的 branch，使用 username.github.io 必须是 master\n\n\n\n","slug":"Hexo-Next-主题设置优化","date":"2020-09-25T06:36:48.000Z","categories_index":"Hexo,Next","tags_index":"Hexo,Next主题","author_index":"Weiba"},{"id":"ea18f9c4585d03ac6c16d38226c09c97","title":"Hexo + Typora Markdown 图片路径设置","content":"\n\n\n\n\n\n\n\n\n看了一圈图床,  貌似七牛最方便, 准备用的时候发现要绑定域名, 而且必须是备案过的, 暂时手头没有, 先存到本地吧…\n修改 Hexo 和 Typora 的配置首先修改 hexo 全局配置文件 _config.yml 中的配置：\n1post_asset_folder: true\n\n这样在我们每次新建Markdown文件的时候，都会创建一个与文件同名的文件夹用于存放图片。\n123456789xweiba.github.io/source/_posts (source)$ ll -atotal 13drwxr-xr-x 1 xiaow 197121    0 9月  25 13:53 ./drwxr-xr-x 1 xiaow 197121    0 9月  25 12:59 ../drwxr-xr-x 1 xiaow 197121    0 9月  25 13:46 Hexo-Typora-Markdown-图片路径设置/-rw-r--r-- 1 xiaow 197121  502 9月  25 13:53 Hexo-Typora-Markdown-图片路径设置.mddrwxr-xr-x 1 xiaow 197121    0 9月  25 13:03 Travis-CI-Hexo-实现自动构建部署GitHub-Pages/-rw-r--r-- 1 xiaow 197121 6757 9月  25 13:04 Travis-CI-Hexo-实现自动构建部署GitHub-Pages.md\n\n修改  Typora 图像配置: 文件-偏好设置-图像\n\n\n安装图片插件在项目目录下安装 hexo-image-link 图片插件(其他插件都有问题):\n1nom install hexo-image-link --save\n\n启动Hexo看看有木有问题吧~~1hexo s\n\n首页:\n详情页:\n都是木有问题的啦, 提交 git 自动部署啦~~ \n网上的教程可能是老版本的, 配置后图片一直会报404, &#x3D;.&#x3D; \n","slug":"Hexo-Typora-Markdown-图片路径设置","date":"2020-09-25T05:46:43.000Z","categories_index":"Hexo,Typora","tags_index":"Hexo,Typora","author_index":"Weiba"},{"id":"f49cb178e3bae0ae46b3c73082926679","title":"Travis CI + Hexo 实现自动构建部署GitHub Pages","content":"\n\n\n\n\n\n\n\n\n参考Travis CI 加 Hexo 实现自动构建部署 Github Pages 博客 配置\n需要的工具: \n\nGit 客户端\nnode npm\n\n请先 cd 至创建项目的目录\n安装 Hexo1npm install -g hexo-cli\n\nHexo 配置初始化 Hexo 站点1hexo init username.github.io\nusername 为你的github账号名\nHexo 必要的一些修改\n用编辑器打开站点根目录的 _config.yml\n修改下面这些项目\n\n\n\n\n项目\n解释\n建议值\n\n\n\ntitle\n网站的标题\n站点名, 可以例如 Weiba’s Blog\n\n\nauthor\n你的名字\nxweiba\n\n\nlanguage\n网站的语言\nzh-CN 按地区\n\n\ntimezone\n网站的时区\nAsia&#x2F;Shanghai 按地区\n\n\nurl\n网站的链接\n如果你没有域名的话，就填 username.github.io\n\n\npretty_urls.trailing_html\n尾随.html，设置为false将其删除（不适用于尾随index.html）\nfalse\n\n\n其他的修改可以参考 Hexo 的文档: Configuration | Hexo Doc\n修改主题\n安装主题\n12345cd themesgit clone https://github.com/SukkaW/hexo-theme-suka.git sukacd sukanpm install --productioncp -i _config.example.yml _config.yml\n\n\n\n\n\n\n\n\n\n本文以 suka 为例\n\n启用主题\n12cd ..        # 回到站点的根目录cat themes/suka/site_config.yml &gt;&gt; _config.yml # 将主题配置追加至Hexo配置文件\n打开站点根目录的 _config.yml, 将 theme: landscape 改为 theme: suka\n\n\n改好之后，你站点的 _config.yml 大概是这样\n1234567891011121314151617181920# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: suka# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: &#x27;&#x27;# Suka-themesuka_theme:  search:    enable: true    path: search.json    field: post # Page | Post | All. Default post  prism:    enable: false    line_number: true    theme: default\n\n本地调试1hexo s --debug\n\n将 Hexo 文件同步至 Github初始化 Git由于我是在 CI 阶段从网络直接 clone 整个主题，所以我就将 themes/ 加入了 .gitignore，所以这里你还要将主题的配置文件复制到站点根目录内，之后 CI 阶段再将其放回原位置。(如果你用的主题有其他的配置文件时应该一并复制到站点根目录)\n\n复制一份主题的配置文件\n1cp themes/suka/_config.yml  _config.theme.yml\n\n初始化 git\n1git init\n\n确保 .gitignore 内有下面的内容 (如果没有这个文件的话可以自己创建)\n12345678.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/themes/\n\n\n在 Github 新建一个命名为 username.github.io 的 repository (username 是你的 Github 账户名称)\n\n将 Hexo 推送至 Github 仓库\n1234567891011121314# 添加 Github 仓库到本地git remote add origin https://github.com/xweiba/xweiba.github.io.git# 新建一个名为 source 的分支git checkout -b source# 将所有文件添加到 gitgit add .# 添加 commitgit commit -m &quot;initial&quot;# 将本地的文件推送到 Github 上的 source 分支git push -u origin source\n\n如果操作上没有问题你上传之后 repository 里面的文件应该差不多是这样的\n12345678.├── _config.theme.yml├── _config.yml├── .gitignore├── package.json├── package-lock.json├── scaffolds└── source\n\n配置 Travis CI\n将 Travis CI 添加到你的 Github 账户\n\n前往 Github 的 Applications settings， 配置 Travis CI 的权限使其能够访问你的 repository\n\n前往 Github 的 Personal Access Tokens 为 Travis CI 生成一个 Token ( 只需要 repo 这个权限(scopes) )，然后把 Token 的值记录下来\n\n前往 Travis CI，在你的 repository 页面下点击 More Options 找到 Settings， 然后找到 Environment Variables，建立一个名( NAME )为 GH_TOKEN, 值( VALUE )为你上一步记录的 Token，最后保存(确保 DISPLAY VALUE IN BUILD LOG 保持 关闭 避免你的 Token 泄漏\n\n\n在你的 Github 的项目 source 分支内新建一个名为 .travis.yml 的文件，参考以下内容进行填入。\n1234567891011121314151617181920212223242526272829os: linuxlanguage: node_js node_js:  - 10  # 使用 nodejs LTS v10branches:  only:    - source # 只监控 source 的 branchbefore_script: ## 根据你所用的主题和自定义的不同，这里会有所不同  - npm install -g hexo-cli # 在 CI 环境内安装 Hexo  - mkdir themes # 由于我们没有将 themes/ 上传，所以我们需要新建一个  - cd themes   - git clone https://github.com/SukkaW/hexo-theme-suka.git suka #从 Github 上拉取 Suka 主题  - cd suka  - npm install --production # 安装 Suka 主题的依赖  - cd ../.. # 返回站点根目录  - cp _config.theme.yml themes/suka/_config.yml # 将主题的配置文件放回原处      - npm install # 在根目录安装站点需要的依赖 script:   - hexo generate # generate static filesdeploy: # 根据个人情况，这里会有所不同  provider: pages  skip_cleanup: true # 构建完成后不清除  token: $GH_TOKEN # 你刚刚设置的 Token  keep_history: true # 保存历史  fqdn: blog.haukeng.me # 自定义域名，使用 username.github.io 可删除  on:    branch: source # hexo 站点源文件所在的 branch  local_dir: public   target_branch: master # 存放生成站点文件的 branch，使用 username.github.io 必须是 master\n\n\n当你保存之后， Travis CI 便会开始部署， 它完成之后，你就可以在你的 repo 里 master 分支查看到生成的站点文件\n\n这时你应该就可以访问 https://username.github.io 查看你的站点了.\n\n\n","slug":"Travis-CI-Hexo-实现自动构建部署GitHub-Pages","date":"2020-09-25T02:22:02.000Z","categories_index":"Hexo,Travis CI","tags_index":"Hexo,Typora,Travis CI","author_index":"Weiba"},{"id":"b27121b4fe504bb1cc2cc95693f47297","title":"Anacoda 常用命令","content":"\nactivate xxx 激活环境\nconda info –envs 查看所有环境\nconda create -n tensorflow pip 创建一个 tensorflow 环境\nconda remove -n tensorflow –all  删除环境\nconda env create -f  d:\\python36_20190106.yml 从配置文件导入环境\nconda env export –file python36_20190106.yml 导出环境 到yml文件\npip install matplotlib 安装模块\nconda create -n py27 python&#x3D;2.7 创建一个py2.7\nconda clean –packages –tarballs | conda clean -a 清除缓存, 安装出错时可使用\n\n","slug":"Anacoda 常用命令","date":"2020-09-09T06:03:40.000Z","categories_index":"Python","tags_index":"Anacoda,常用命令","author_index":"Weiba"},{"id":"fdd954ec5bfb8f467c03ee2275680518","title":"Redis RDB 分析工具 rdbtools 的安装及使用","content":"安装 rdbtools该工具需要python支持, 2.7 或 3.4+ 都可以.\n1pip install rdbtools\n\n安装相关依赖在解析redis的rbd文件时, 需要安装 python-lzf, 否则解析会非常慢.\n在Windows环境下, 使用pip安装python-lzf时, 需要安装 VC++ 依赖对源码进行编译, 而这个依赖极其难装… \n\n\n\n\n\n\n\n\n\nps: python 2.7 需要VC++ 9, python 3 需要VC++ 14.\n为避免浪费时间, 直接下载编译好的 whl 文件.\nwhl下载站: Python Extension Packages for Windows - Christoph Gohlke, 打开后浏览器搜索 python-lzf, 定位到下载位置. \n根据你的系统版本和python版本下载对应的whl文件. pytho3.7 64位Windows下载 python_lzf‑0.2.4‑cp37‑cp37m‑win_amd64.whl .\n下载完成后直接安装: pip install python_lzf‑0.2.4‑cp37‑cp37m‑win_amd64.whl\n下载rdb打开redis的配置文件, 搜索dbfilename, 查看rdb文件位置.\n如没有自动生成的话, 通过redis-cli登陆到redis终端执行bgsave, 会在后台异步保存当前数据库的数据到rdb文件.\n下载rdb文件至本地dump.rdb.\n生成rdb的内存报告将rdb内容解析到csv表格中: rdb -c memory dump.rdb -b 10240 -f dump_memory_v2.csv.\n参数含义:-c: 该rdb保存的数据格式, memory 标识内存镜像, 还有json等等..-b: 使用多大的内存来缓冲解析数据, 分片的解析rdb数据, 防止内存占用过高.-f: 解析数据存放的文件位置\n生成完毕后可通过表格的排序找出内存占用比较大的key.\n解析单个 key 值解析单个key的value到文件:rdb --command json dump.rdb -k &quot;dataenable:router:push&quot; -b 1024 -f dump.json\n想命令行直接输出不要后面的 -f dump.json 就行了.\n当前这个key会生成9G左右的文件, 没一个编辑器打的开…\n这种情况咱们可以在运行命令后一两秒后 ctrl + c 就结束命令, 生成一个10M左右的文件. \n我们只需要看看数据结构就行了. \n","slug":"Redis RDB 分析工具 rdbtools 的安装及使用","date":"2020-08-21T05:17:02.000Z","categories_index":"Redis","tags_index":"Redis,rdbtools,RDB","author_index":"Weiba"},{"id":"e1e6120a76350081feccd71d083f287c","title":"快速搭建 Python 3.6.2 + Keras 2.3.1 + Tensorflow 1.15 + OpenCV 环境","content":"快速搭建环境\n\n\n\n\n\n\n\n\n使用 Anacoda, 初始化环境Keras 与 Tensorflow 版本依赖关系: List of Available Environments - FloydHub Documentation\n\n创建环境并激活: 12cnoda create -n keras_2.3.1 python=3.6conda activate keras_2.3.1\n安装2.3.1版本keras:1pip install keras==2.3.1\n安装1.15版本tensorflow:12pip install --upgrade setuptools #先升级一下setuptools 不然装tensorflow会报缺少依赖错误pip install tensorflow==1.15\n因为版权问题, OpenCV 后期版本移除了一些算法, 安装算法比较完整的OpenCV版本: 12pip install opencv-contrib-python==3.4.1.15pip install opencv-python==3.4.1.15\n常用依赖: Pillow matplotlib numpy\n\n","slug":"快速搭建 Python 3.6.2 + Keras 2.3.1 + Tensorflow 1.15 + OpenCV 环境","date":"2020-08-20T06:04:29.000Z","categories_index":"Python","tags_index":"OpenCV,Python,环境,Keras,Tensorflow","author_index":"Weiba"},{"id":"3a9c7aad8a4f765ed782ed4abcdc87aa","title":"SpringBoot 1.5.xx 升级至 2.xx","content":"升级依赖调整记录一. Maven 调整redis:升级前:\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n升级后:\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\nthymeleaf-extras-springsecurity:升级前:\n1234&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt;&lt;/dependency&gt;\n升级后\n1234&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt;\n\nFeign Options 找不到构造方法:Maven 搜索 feign-core 依赖, 升级或排除 netflix.feign 包的模块.\n二. yml 配置文件调整redis:升级前:\n12345678910spring:    redis:        host: 192.168.116.190        password: ischool20        port: 9779        pool:          max-idle: 100          min-idle: 1          max-active: 100          max-wait: -1\n升级后:\n1234567891011spring:    redis:        host: 192.168.116.190        password: ischool20        port: 9779        lettuce:          pool:            max-idle: 8            min-idle: 0            max-active: 8            max-wait: -1\nfeign 重复注入feign升级后默认要求每一个 @FeignClient 都要有单独的实例名称，可添加配置允许覆盖，如下\n123spring:    main:     allow-bean-definition-overriding: true\n\n三. 代码变更SDK 包名修改.redis:升级前\n1234567@Beanpublic CacheManager cacheManager(RedisTemplate redisTemplate) &#123;    RedisCacheManager cacheManager= new RedisCacheManager(redisTemplate);    cacheManager.setDefaultExpiration(30 * 60L);    cacheManager.setUsePrefix(true);    return cacheManager;&#125;\n升级后:\n12345678@Beanpublic CacheManager cacheManager(RedisConnectionFactory factory) &#123;\tRedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()\t\t\t.entryTtl(Duration.ofMillis(30)); // UsePrefix默认为true    return RedisCacheManager\t\t\t.builder(RedisCacheWriter.nonLockingRedisCacheWriter(factory))\t\t\t.cacheDefaults(redisCacheConfiguration).build();&#125;\njunit:org.junit.Assert 包更名为: org.junit.jupiter.api.Assertions, 部分参数需要修改, 变化不大. message 统一调至最后一个参数.\nEasyPoi 升&#x2F;降级 对应变化常量参数:\n\n\n属性\n3.9 版本\n3.15 版本\n\n\n\n填充模式\nCellStyle.SOLID_FOREGROUND\nFillPatternType.SOLID_FOREGROUND\n\n\n边框间距\nHSSFCellStyle.BORDER_THIN\nBorderStyle.THIN\n\n\n居中\nXSSFCellStyle.ALIGN_CENTER\nHorizontalAlignment.CENTER\n\n\n垂直\nXSSFCellStyle.VERTICAL_CENTER\nVerticalAlignment.CENTER\n\n\n字体加粗\nfont.setBoldweight(Font.BOLDWEIGHT_BOLD)\nfont.setBold(true)\n\n\n字体不加粗\nfont.setBoldweight(Font.BOLDWEIGHT_NORMAL)\nfont.setBold(false)\n\n\n是否验证\nsetNeedVerify\nsetNeedVerfiy\n\n\nes jestspringBoot 2.3.0版本及以后版本不支持es查询工具jestClient自动注入, 手动注入\n12345678910111213@Repositorypublic class JestInit &#123;    @Bean(&quot;jestClient&quot;)    public JestClient getJestCline()&#123;        JestClientFactory factory = new JestClientFactory();        factory.setHttpClientConfig(new HttpClientConfig                .Builder(&quot;http://localhost:9200&quot;)                .multiThreaded(true)                .build());        return  factory.getObject();    &#125;&#125;\n\n报错Caused by: java.lang.NoClassDefFoundError: Could not initialize class org.hibernate.validator.internal.engine.ConfigurationImpl 错误, 这是springboot2.3以上自带的, 手动导入hibernate 依赖:\n123456&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;6.1.5.Final&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;\n\nswagger 无接口数据升级后需要在配置文件中开启swagger, 默认是关闭的.\n123application:  swagger:    enabled: true","slug":"SpringBoot 1.5.xx 升级至 2.xx","date":"2020-08-20T04:29:14.000Z","categories_index":"SpringBoot","tags_index":"升级,SpringBoot","author_index":"Weiba"},{"id":"499f3275389b1629fafd79bc25c802a1","title":"Anacoda 更新库时候出现失败 HTTP 404 NOT FOUND for url 解决方法","content":"[toc]\n\n\n\n\n\n\n\n\n\nwin10 &amp; Anacoda\n原来使用的清华源, 当不久前被关闭了…\n一. 更换Anacoda源打开 Anacoda Prompt 重新设置源即可. 这是上海交大的, 暂时还可以用, 好像没更新了.\n123conda config --add channels https://mirrors.sjtug.sjtu.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.sjtug.sjtu.edu.cn/anaconda/cloud/conda-forge/conda config --set show_channel_urls yes\n\n再次下载即可~.\n","slug":"Anacoda 更新库时候出现失败 HTTP 404 NOT FOUND for url 解决方法","date":"2020-07-29T06:06:29.000Z","categories_index":"Python","tags_index":"Anacoda,Python","author_index":"Weiba"},{"id":"85a376300278f665c1029a4b2a9d028f","title":"windows运行python无法传入argv参数","content":"\n\n\n\n\n\n\n\n\n来自: windows运行python无法传入argv参数\n解决方法:\n1234567用python temp.py hello试一下是不是正常了如果这样就可以了的话那就是设置映射的时候没带参数虽然我也不理解怎么会有这么奇怪的事情发生在注册表里搜索python.exe看看关联启动的命令是不是&quot;......\\python.exe &quot; &quot;%1&quot; %*后面的%*如果没有了那就是参数被忽略了\n\n默认是没有 %* 的.\n","slug":"windows运行python无法传入argv参数","date":"2020-07-29T06:05:30.000Z","categories_index":"python","tags_index":"错误记录,windows,python","author_index":"Weiba"},{"id":"95a848a4736b78d5e5ccde886b07a9ec","title":"Git 常用命令","content":"常用操作\ngit add . 添加更新文件\ngit push 提交文件\ngit pull 拉取文件\ngit commit -m &quot;提交说明&quot; 提交文件\n\nGit 版本回退\ngit log 查看提交 commit id, 按 q 退出\ngit reset --hard commitId  回退版本\ngit push -f 强制推送\n\n注意此操作会强制覆盖远程仓库.\n","slug":"Git 常用命令","date":"2020-02-08T03:35:17.000Z","categories_index":"Git","tags_index":"Git","author_index":"Weiba"},{"id":"c7d7a62d45beb14fc8e2d767dfbacb37","title":"Anacoda 修改 pip 源","content":"\n\n\n\n\n\n\n\n\n来源: 更改pip源&#x2F;anaconda源：windows与linux\nWindows在 c:\\user\\xxxName\\pip\\pip.ini 中加入\n1234567[global]# 清华源index-url=https://pypi.tuna.tsinghua.edu.cn/simple [install]  trusted-host=pypi.tuna.tsinghua.edu.cndisable-pip-version-check = true  timeout = 6000  \n需要 创建pip文件夹 与 pip.ini 文件。\nLinux123456789101112cd $HOME  mkdir .pip  cd .pipsudo vim pip.conf  在里面添加  [global]  index-url=https://pypi.tuna.tsinghua.edu.cn/simple[install]  trusted-host=pypi.tuna.tsinghua.edu.cn disable-pip-version-check = true  timeout = 6000 ","slug":"Anacoda 修改 pip 源","date":"2019-11-29T06:08:16.000Z","categories_index":"Python","tags_index":"Anacoda,Python,Pip,配置","author_index":"Weiba"},{"id":"0e77e0ee88b96a8849dd4e1112190086","title":"JupyterNotebook 配置","content":"修改 JupyterNotebook 根目录\nwindows下设置JupyterNotebook默认目录\n\n安装扩展conda install -c conda-forge jupyter_nbextensions_configurator\n新增Python环境notebook 添加 3.6 环境, 在 py36 环境下运行:\n12pip install ipykernel  # 可能会报错, No module named &#x27;setuptools._deprecation_warning`, 重新安装一下pip install -U setuptools 再执行.python -m ipykernel install --name python3.6 # 安装kernel, 再次打开notebook, 新建即可看到python3.6","slug":"JupyterNotebook 配置","date":"2019-11-29T06:07:21.000Z","categories_index":"Python","tags_index":"Python,配置,JupyterNotebook","author_index":"Weiba"},{"id":"bb713e563f3a2c167b539d21a3789cfa","title":"OpenCV 环境准备","content":"\n\n\n\n\n\n\n\n\n3.4.2 以后因部分算法被申请专利, 在开源版本中已移除, 推荐使用 3.4.1.15版本, 所有算法均可使用.\n3.4.1.15 依赖下载地址:\n\nopencv_contrib_python-3.4.1.15-cp36-cp36m-win_amd64\nopencv_python-3.4.1.15-cp36-cp36m-win_amd64.whl\n\n3.4.1.15 只有Python3.6版本的whl, Anaconda 默认 3.7, 将Python切换至3.6. \n12conda create -n py36 python=3.6activate py36\n\nnotebook 添加 3.6 环境, 在 py36 环境下运行:\n12pip install ipykernel  # 可能会报错, No module named &#x27;setuptools._deprecation_warning`, 重新安装一下pip install -U setuptools 再执行.python -m ipykernel install --name python3.6 # 安装kernel, 再次打开notebook, 新建即可看到python3.6\n\n修改 JupyterNotebook 根目录请看: windows下设置JupyterNotebook默认目录\n","slug":"OpenCV 环境准备","date":"2019-11-29T05:39:55.000Z","categories_index":"OpenCV","tags_index":"OpenCV,环境","author_index":"Weiba"},{"id":"fc57b6cde20fd0085bf42f81e31fec6d","title":"Linux 安装 OpenCV 4.1.0 支持","content":"[TOC]\nOpenCV 简介OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉库，它提供了很多函数，这些函数非常高效地实现了计算机视觉算法（最基本的滤波到高级的物体检测皆有涵盖）。\nOpenCV 是跨平台的，可以在  Windows、Linux、Mac OS、Android、iOS 等操作系统上运行。\nOpenCV 的应用领域非常广泛，包括图像拼接、图像降噪、产品质检、人机交互、人脸识别、动作识别、动作跟踪、无人驾驶等。\nOpenCV 还提供了机器学习模块，你可以使用正态贝叶斯、K最近邻、支持向量机、决策树、随机森林、人工神经网络等机器学习算法。\n更多 OpenCV 介绍请参考百度百科：https://baike.baidu.com/item/opencv/10320623\n编译环境要求\n\n\n\n\n\n\n\n\n本次编译安装基于 CentOS release 6.5 (Final).  建议开始之前查看各个依赖版本是否符合要求, 下列是主要的依赖: \n\nGCC 4.8.x or higher - GCC 升级\nCMake 3.5.x or higher  - CMake 升级\nPython 2.7.x or higher  -  Python 升级\n注意JDK版本要与运行的 jar 包版本一致! - 设置临时JAVA环境变量\n\n一. 下载 opencv 源码1git clone https://github.com/opencv/opencv\n\n二. 编译及依赖安装1. 安装依赖项目1yum install cmake gcc gcc-c++ gtk+-devel gimp-devel gimp-devel-tools gimp-help-browser zlib-devel libtiff-devel libjpeg-devel libpng-devel gstreamer-devel libavc1394-devel libraw1394-devel libdc1394-devel jasper-devel jasper-utils swig python libtool nasm build-essential ant\n\n其中需要注意的是 build-essential 在 centOS 通过下面的方式来安装 yum groupinstall &quot;Development Tools&quot;\n\n2. 配置 opencv 编译选项123456789cd opencvmkdir build &amp;&amp; cd buildcmake -DCMAKE_BUILD_TYPE=RELEASE -DBUILD_TESTS=OFF -DBUILD_TIFF=ON -DCMAKE_INSTALL_PREFIX=/usr/local/opencv/4.1.0 ..    - 注意`-D`后不留空格    - /usr/local/xxx 为安装目录    - 最后两点是源码目录    - -DBUILD_TESTS=OFF 关闭测试, 编译时比较耗时间    - -DBUILD_TIFF=ON 报 error: ‘tmsize_t’ 错误时添加, centOS6 特有.    - -DWITH_V4L=OFF 报 error: ‘V4L2_CID_ISO_SENSITIVITY’ 错误时添加, 在 centOS6 上编译 3.4.3 以上版本才需要加这个.\n\ncmake 完成后注意查看报告中的 To be built:  行后有无 java 支持, 没有的话排查报告中的排查 python 与 java 项目是否正常,  ant 建议 1.9.* 版本, python 必须 2.7 或以上版本.\n\n3. 编译 opencv\n编译, 需要半小时左右 1make -j2\n\n-j2 同时使用 2 个线程编译, 可以自己测试用几个线程, 单核服务器开两个刚好把 cpu 跑满.\n在 centos6 上编译, gcc 版本得在 4.8.5 或以上.\n在 centos6 上编译 opencv 3.4.4 以上版本时会出现 opencv error: ‘V4L2_CID_ISO_SENSITIVITY’ was not declared in this scope 这类错误，在 centos6 暂时上无法解决只能在 cmake 时加入 -D WITH_V4L=OFF 命令在编译时关掉 v4l2 功能或者尝试编译 3.4.3 版本,原因见 issue\n\n\n安装 1sudo make install\n依赖配置 123# 复制 `so` 文件, 一定要把 `so` 文件复制过去, 不然 `jar` 找不到依赖, 类似 `windows` 下的 `dll`, 也可以把该目录加到环境变量中cd /usr/local/opencv/4.1.0/share/java/opencv4cp libopencv_java410.so /usr/lib \n\n三. 测试运行1. 下载依赖 jar 至本地\n将 /usr/local/opencv/4.1.0/share/java/opencv4 下的 opencv-410.jar 下载到本地.\n\n2. 将依赖 jar 安装至本地 maven 仓库:12# 已添加到公司私有 Maven 仓库mvn install:install-file -Dfile=opencv-410.jar -DgroupId=org.bytedeco.javacpp-presets -DartifactId=opencv-linux -Dversion=4.1.0 -Dpackaging=jar\n\n3. 新建一个测试 demo 项目\n添加依赖 123456&lt;!-- 添加 opencv 依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt;    &lt;artifactId&gt;opencv-linux&lt;/artifactId&gt;    &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;\njaca 测试代码: 123456789101112131415161718192021public class OpenCvDemo &#123;    static &#123;         System.loadLibrary(Core.NATIVE_LIBRARY_NAME);     &#125;    public static void main(String[] args) &#123;        if ((1==args.length) &amp;&amp; (0==args[0].compareTo(&quot;--build&quot;))) &#123;            System.out.println(Core.getBuildInformation());        &#125; else        if ((1==args.length) &amp;&amp; (0==args[0].compareTo(&quot;--help&quot;))) &#123;            System.out.println(&quot;\\t--build\\n\\t\\tprint complete build info&quot;);            System.out.println(&quot;\\t--help\\n\\t\\tprint this help&quot;);        &#125; else &#123;            System.out.println(&quot;Welcome to OpenCV &quot; + Core.VERSION);        &#125;    &#125;&#125;\n打包时把依赖jar加进去 12345678910111213141516171819202122232425262728&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;configuration&gt;                &lt;archive&gt;                    &lt;manifest&gt;                        &lt;mainClass&gt;com.xweba.opencv.OpenCvDemo&lt;/mainClass&gt;                    &lt;/manifest&gt;                &lt;/archive&gt;                &lt;descriptorRefs&gt;                    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;                &lt;/descriptorRefs&gt;            &lt;/configuration&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;id&gt;make-assembly&lt;/id&gt; &lt;!-- this is used for inheritance merges --&gt;                    &lt;phase&gt;package&lt;/phase&gt; &lt;!-- 指定在打包节点执行jar包合并操作 --&gt;                    &lt;goals&gt;                        &lt;goal&gt;single&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n4. 将 demo 包上传至服务器运行测试:12345[root@host opencv4]# cd ~/opencv/samples/java/[root@host java]# java -jar opencv-demo-0.0.1-jar-with-dependencies.jarWelcome to OpenCV 4.1.0-dev// --buidl 查看OpenCV环境信息[root@host java]#java -jar opencv-demo-0.0.1-jar-with-dependencies.jar --build\n\n[注] 可能会遇到的报错及解决方法1. cmake 相关a. cmake 配置命令报错\n错误信息:  12CMake Error: The source directory &quot;/root/opencv/build/CMAKE_INSTALL_PREFIX=/usr/local/opencv/4.1.0&quot; does not exist.Specify --help for usage, or press the help button on the CMake GUI.\n解决方法:  12把`-D` 后的空格都去掉cmake -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_INSTALL_PREFIX=/usr/local/opencv/4.1.0 ..\n  \n\nb. cmake 版本过低\n错误信息:  1234[root@host build]# cmake -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_INSTALL_PREFIX=/usr/local/opencv/4.1.0 ..CMake Error at CMakeLists.txt:29 (cmake_minimum_required):CMake 3.5.1 or higher is required.  You are running version 2.8.12.2-- Configuring incomplete, errors occurred!\n解决方法升级cmake : cmake 升级到 cmake-3.9.2 版本\n\nc. cmake 时 ant 启动报错\n错误信息:  1Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/tools/ant/launch/Launcher\n解决方法:  12345#添加 ant 环境变量vim /etc/profileexport ANT_HOME=/usr/share/ant/export CLASSPATH=$CLASSPATH:$CLASSPATH:$ANT_HOME/libsource /etc/profile\n\nd. cmake 时卡在 download ippicv_2019_lnx_intel64_general_20180723.tgz由于它资源是在github 上的, 可能有点慢, 可以自行去  github 上下载至本地, 然后:\n12vim ~/opencv/opencv-master/3rdparty/ippicv/ippicv.cmake &quot;file:///root/opencv/&quot; #47行修改为本地文件, 再次 cmake\n\n2. make 相关\na. gcc 无法识别命令行\n错误信息 :   123456cc1plus: 警告：命令行选项“-Wmissing-prototypes”对 Ada/C/ObjC 是有效的，但对 C++ 无效cc1plus: 警告：命令行选项“-Wstrict-prototypes”对 Ada/C/ObjC 是有效的，但对 C++ 无效cc1: 警告：无法识别的命令行选项“-Wno-implicit-fallthrough”cc1: 警告：无法识别的命令行选项“-Wno-maybe-uninitialized”cc1: 警告：无法识别的命令行选项“-Wno-unnamed-type-template-args”cc1: 警告：无法识别的命令行选项“-Wno-delete-non-virtual-dtor”\n解决办法 : gcc 版本过低, 至少 4.8.x 或以上: \nGCC 升级至6.X\n\n\n升级 gcc 报错:  123Error: Protected multilib versions: libgcc-4.8.2-8.el6.x86_64 != libgcc-4.4.7-23.el6.i686 You could try using --skip-broken to work around the problem** Found 34 pre-existing rpmdb problem(s), &#x27;yum check&#x27; output follows:\n  原因是多个库不能共存\n解决方法:  \n来源: https://blog.csdn.net/chenxin2tj/article/details/79950904  1yum install gcc gcc-g++ -y --setopt=protected_multilib=false\n\n\n\nb. 编译 cpp 时错误\nerror: ‘Z_FIXED’\n解决方法: 在 grfmt_png.cpp 中添加 #define Z_FIXED 4 . 来源: Python3 opencv3编译\n\n\nerror: ‘tmsize_t’\n解决方法一: 在 cmake 时添加 -DBUILD_TIFF=ON. 来源: Python3 opencv3编译\n解决方法二: yum remove libtiff-dev 把libtiff-dev依赖卸载，让opencv使用3rdparty内的libtiff去编译, 来源: CentOS 6.9 安装OpenCV 3.4.4\n\n\nerror: ‘V4L2_CID_ISO_SENSITIVITY’\n解决方法: 在 cmake 时添加 -DWITH_V4L=OFF. 来源: CentOS 6.9 安装OpenCV 3.4.4\n\n\n\nc. make 编译时内存不够\n错误信息:  123456c++: internal compiler error: Killed (program cc1plus)Please submit a full bug report,with preprocessed source if appropriate.See &lt;http://bugzilla.redhat.com/bugzilla&gt; for instructions.make[2]: *** [modules/CMakeFiles/ade.dir/__/3rdparty/ade/ade-0.1.1d/sources/ade/source/passes/communications.cpp.o] Error 4make[2]: *** Waiting for unfinished jobs....\n解决方法开启 swap 交换空间 :  linux 创建 swap 交换空间\n\n3. make 后a. 无 java 模块\n检查 cmake 结果中 python 与 java 项是否正常  1234567--   Python (for build):            NO----   Java:--     ant:                         /usr/share/ant/bin/ant (ver 1.9.13)--     JNI:                         /usr/local/jdk1.8/jdk1.8.0_91/include /usr/local/jdk1.8/jdk1.8.0_91/include/linux /usr/local/jdk1.8/jdk1.8.0_91/include--     Java wrappers:               NO--     Java tests:                  NO\n检查 python 版本, 需要 python2.7 及以上版本 \n升级 python : Linux Python 2.6 升级至 2.7\n\n\n\n\n4. 执行出错OpenCV的编译 JDK 版本与运行 jar 包的编译版本不一致会导致执行出错， 错误日志：\n1java.lang.UnsatisfiedLinkError: org.opencv.imgcodecs.Imgcodecs.imread_1(Ljava/lang/String;)J\n\n1Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: org/opencv/core/Core : Unsupported major.minor version 52.0\n\n此时需要更改环境变量后重新编译 OpenCV.\n将下列环境变量写入 /etc/profile 永久生效，直接在 shell 中执行临时生效 , 操作完后重新 make : \n1234567JAVA_HOME=/home/icampus3.0/jdk8JAVA_BINDIR=$JAVA_HOME/binJAVA_ROOT=$JAVA_HOMEJRE_ROOT=$JAVA_HOME/jreCLASSPATH=$CLASSPATH:$JAVA_HOME/lib/rt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_BINDIR:$PATHexport PATH JAVA_HOME JAVA_BINDIR JAVA_ROOT CLASSPATH\n\nps: windows 端启动配置指定 dll 位置 -Djava.library.path=D:\\OpenOCR\\4.1.0\\build\\java\\x64 或将该路径加入环境变量\n","slug":"Linux 安装 OpenCV 4.1.0 支持","date":"2019-11-15T05:18:12.000Z","categories_index":"Linux","tags_index":"OpenCV,Linux","author_index":"Weiba"},{"id":"fbc6ad4990d68b98c82bd7ba19e4ee89","title":"make 报错记录","content":"\nc++: internal compiler error: Killed (program cc1plus)网上说是内存原因, 一般云主机都是1G左右内存, 没开启swap, 我make 时开启了多线程处理, 非常有可能是这个原因\n错误提示 123456c++: internal compiler error: Killed (program cc1plus)Please submit a full bug report,with preprocessed source if appropriate.See &lt;http://bugzilla.redhat.com/bugzilla&gt; for instructions.make[2]: *** [modules/CMakeFiles/ade.dir/__/3rdparty/ade/ade-0.1.1d/sources/ade/source/passes/communications.cpp.o] Error 4make[2]: *** Waiting for unfinished jobs....\n解决方法, 启用swap: linux 创建 swap 交换空间\n\n\n\n","slug":"make 报错记录","date":"2019-11-13T05:20:10.000Z","categories_index":"make","tags_index":"错误记录,经验,make","author_index":"Weiba"},{"id":"962aae778a6cc57574cfe7bd171e7d85","title":"docker opencv java","content":"Dockerfile:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263FROM centos:7.4.1708MAINTAINER noasking# 更换阿里源RUN yum install -y wgetRUN cd /etc/yum.repos.d \\    &amp;&amp; mv CentOS-Base.repo CentOS-Base.repo.bak \\    &amp;&amp; wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo \\    &amp;&amp; yum clean all \\    &amp;&amp; yum makecache# 必要なパッケージインストール################################################################################RUN yum update -y \\        &amp;&amp; yum install -y git gcc gcc-c++ autoconf automake cmake \\                          freetype-devel libtool make mercurial nasm \\                          pkgconfig zlib-devel \\                          bzip2-devel hostname \\                          openssl \\                          openssl-devel \\                          wget \\                          which \\                          boost* \\                          ant \\        &amp;&amp; yum clean all# Java 安装ADD jdk-8u131-linux-x64.tar.gz /# 配置环境变量ENV JAVA_HOME /jdk1.8.0_131ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH .:$JAVA_HOME/lib:$JRE_HOME/libENV PATH $PATH:$JAVA_HOME/bin# OpenCV 配置################################################################################COPY opencv-3.4.0.tar.gz /RUN cd \\    &amp;&amp; mkdir opencv &amp;&amp; tar xvzf /opencv-3.4.0.tar.gz -C opencv --strip-components 1 \\    &amp;&amp; cd opencv \\    &amp;&amp; mkdir build \\    &amp;&amp; cd build \\    &amp;&amp; cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/opencv/release -D BUILD_TESTS=OFF ..\\    &amp;&amp; make -j8 \\    &amp;&amp; make install \\    &amp;&amp; cp /opencv/release/share/OpenCV/java/libopencv_java340.so /usr/local/lib/ \\    &amp;&amp; cd \\    &amp;&amp; rm -f /opencv-3.4.0.tar.gz# Boostのパス設定ENV BOOST_ROOT /usr/lib64/ENV Boost_INCLUDE_DIR /usr/include/boost/# LD_LIBRARY_PATH設定ENV LD_LIBRARY_PATH $LD_LIBRARY_PATH:/usr/local/lib# WORK_DIRECTORY設定WORKDIR /app# CMD設定(BASH)CMD [&quot;/bin/bash&quot;]\n\njava8 ：下载地址\nopencv : 下载地址\ndocker build -t xiaoweiba1028&#x2F;opencv-java . \n","slug":"docker opencv java","date":"2019-11-13T03:01:47.000Z","categories_index":"docker","tags_index":"docker,opencv","author_index":"Weiba"},{"id":"0506587fbaa1eab77bb8eb284177e762","title":"linux 创建 swap 交换分区","content":"\n\n\n\n\n\n\n\n\n大部分云主机都是没有开启 swap 交换分区的, 且内存都在 1-2G 左右, 在编译源码时可能会因为内存不足而编译失败.\n1. 创建一个空文件\nsudo dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;swapfile bs&#x3D;1M count&#x3D;2048\n\n2. Bake swap file:\nsudo mkswap &#x2F;swapfile\n\n3. 开机时启动:12# 把下面这行加到 /etc/fstab/media/fasthdd/swapfile.img swap swap sw 0 0\n4. 激活:\nswapon &#x2F;swapfile\n\n5. 验证是否成功\ncat &#x2F;proc&#x2F;swaps  12345[root@host build]# cat /proc/swapsFilename                                Type            Size    Used    Priority/swap                                   file            135164  135112  -2/var/swapfile                           file            524284  491508  -3/swapfile                               file            2097148 31916   -4\ngrep ‘Swap’ &#x2F;proc&#x2F;meminfo  1234[root@host build]# grep &#x27;Swap&#x27; /proc/meminfoSwapCached:        32752 kBSwapTotal:       2756596 kBSwapFree:        2098060 kB\n\n","slug":"linux 创建 swap 交换分区","date":"2019-11-07T05:21:12.000Z","categories_index":"Linux","tags_index":"Linux,Swap","author_index":"Weiba"},{"id":"f320592293c9a5b6cd2058e0782dac6f","title":"Shell-抽取Jar包中的静态文件","content":"抽取Jar包中的静态文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#!/bin/bash######################## created by code on 2019/11/06 15:56:14#######################function setVars()&#123;       basepath=/home/icampus3.0       jdkHome=$&#123;basepath&#125;/jdk8       servHome=$&#123;basepath&#125;/pkgs/paper-manager       start=$&#123;servHome&#125;/start.sh       log=$&#123;basepath&#125;/logs/paper-manager.log       java=$&#123;jdkHome&#125;/bin/java       servFile=$&#123;servHome&#125;/paper-manager.jar       option=&quot;-server -Xms180m -Xmx200m -Dfile.encoding=utf-8 -Dspring.config.location=bootstrap.yml -Darchaius.configurationSource.additionalUrls=file:///home/icampus3.0/pkgs/config/conf_prod/globalconfig.properties -jar $&#123;servFile&#125; &quot;       # manager unzip config       servName=paper       jarPath=BOOT-INF/classes       # 静态文件配置       servJsPath=$&#123;jarPath&#125;/static/custom/$&#123;servName&#125;       JsHome=$&#123;basepath&#125;/icampus-static/custom/$&#123;servName&#125;       # templates 文件配置       servHtmlPath=$&#123;jarPath&#125;/templates       HtmlHome=$&#123;servHome&#125;/templates&#125;function start()&#123;       cd $servHome       sh stop.sh       echo -e &quot;  Start to start up paper-manager : &quot;       $java $option &gt; $log 2&gt;&amp;1 &amp;       echo $! &gt; pid       if [[ -z $(cat pid) ]]; then           echo -e &quot;  Failed to start up paper-manager&quot;           return 1       else           echo -e &quot;  Successful to start up paper-manager&quot;           return 0       fi&#125;# $1:处理类型 $2:jar包中的相对路径 $3:部署的绝对路径, 会自动在部署路径添加_bak后缀生成上一次的备份文件夹function unzipStaticFile() &#123;      echo -e &quot;  &quot;      echo -e &quot;  ---------UnzipStaticFile start---------&quot;      cd $servHome      if [ ! -n &quot;$1&quot; -o ! -n &quot;$2&quot; -o ! -n &quot;$3&quot; ]         then           echo -e &quot;  Unzip params is Not Full!&quot;           echo -e &quot;  Params: typeName:$1, unzipTempPath:$2, dstPath:$3&quot;           exit 1      fi      echo -e &quot;  Start unZip paper-manager $1 file...&quot;      echo -e &quot;  Params: typeName:$1, unzipTempPath:$2, dstPath:$3&quot;      echo &quot;  Clean unzip temp path: $&#123;servHome&#125;/temp/$2&quot;      rm -rf $&#123;servHome&#125;/temp/$2  &gt;/dev/null 2&gt;&amp;1      echo &quot;  Unzip ...&quot;      unzip $&#123;servFile&#125; $2/* -d $&#123;servHome&#125;/temp &gt;/dev/null 2&gt;&amp;1      # wait 1s unzip Successful      sleep 1      if [ $? -ne 0 ]        then            echo -e &quot;  paper-manager unzip Failed!&quot;            exit 1      fi      echo -e &quot;  Unzip Successful!\\n&quot;      echo -e &quot;  Start Deploy paper-manager $1 file...&quot;      # 判断备份文件夹是否存在      if [ -d &quot;$3_bak&quot; ]        then        echo &quot;  Clean paper-manager $1 file old backup path: $3_bak&quot;        rm -rf &quot;$3_bak&quot; &gt;/dev/null 2&gt;&amp;1      fi      # 备份一份      echo &quot;  Backup now paper-manager $1 file path: $3_bak&quot;      mv $3 &quot;$3_bak&quot; &gt;/dev/null 2&gt;&amp;1      # 将新的静态文件移动过来      echo &quot;  Move new paper-manager $1 file path:$3&quot;      mv $&#123;servHome&#125;/temp/$2 $3 &gt;/dev/null 2&gt;&amp;1      echo -e &quot;  Deploy paper-manager $1 file Successful!&quot;      echo -e &quot;  ---------UnzipStaticFile end---------&quot;      echo -e &quot;  &quot;&#125;setVarsstartunzipStaticFile JS $&#123;servJsPath&#125; $&#123;JsHome&#125;# html 可选部署#if [ $1 -a $1 = 1 ]# then# unzipStaticFile Html $&#123;servHtmlPath&#125; $&#123;HtmlHome&#125;#fi","slug":"Shell-抽取Jar包中的静态文件","date":"2019-11-06T07:56:14.000Z","categories_index":"Shell","tags_index":"Shell","author_index":"Weiba"},{"id":"ce9bd1d7d396ea011c453913a42cce54","title":"Mybatis 自动代码生成","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration       PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;       &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;   &lt;!--加载配置文件，为下面读取数据库信息准备--&gt;   &lt;properties resource=&quot;application.properties&quot;/&gt;   &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;       &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;           &lt;property name=&quot;mappers&quot; value=&quot;com.jnshu.util.MyMapper&quot; /&gt;           &lt;!--caseSensitive默认false，当数据库表名区分大小写时，可以将该属性设置为true--&gt;           &lt;property name=&quot;caseSensitive&quot; value=&quot;true&quot;/&gt;       &lt;/plugin&gt;       &lt;!-- 阻止生成自动注释 --&gt;       &lt;commentGenerator&gt;           &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;           &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;           &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;       &lt;/commentGenerator&gt;       &lt;!--数据库链接地址账号密码--&gt;       &lt;jdbcConnection driverClass=&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;                       connectionURL=&quot;$&#123;spring.datasource.url&#125;&quot;                       userId=&quot;$&#123;spring.datasource.username&#125;&quot;                       password=&quot;$&#123;spring.datasource.password&#125;&quot;&gt;       &lt;/jdbcConnection&gt;       &lt;javaTypeResolver&gt;           &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;       &lt;/javaTypeResolver&gt;       &lt;!--生成Model类存放位置--&gt;       &lt;javaModelGenerator targetPackage=&quot;com.jnshu.domain&quot; targetProject=&quot;src/main/java&quot;&gt;           &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;           &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;       &lt;/javaModelGenerator&gt;       &lt;!--生成映射文件存放位置--&gt;       &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;           &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;       &lt;/sqlMapGenerator&gt;       &lt;!--生成Dao类存放位置--&gt;       &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码               type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和基于注解的Mapper对象               type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口       --&gt;       &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.jnshu.dao&quot; targetProject=&quot;src/main/java&quot;&gt;           &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;       &lt;/javaClientGenerator&gt;       &lt;!--生成对应表及类名       去掉Mybatis Generator生成的一堆 example       --&gt;       &lt;table tableName=&quot;student_info&quot; domainObjectName=&quot;StudentInfo&quot; enableCountByExample=&quot;false&quot;              enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;           &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt;       &lt;/table&gt;   &lt;/context&gt;&lt;/generatorConfiguration&gt;","slug":"Mybatis 自动代码生成","date":"2019-10-23T04:51:57.000Z","categories_index":"Mybatis","tags_index":"Mybatis,代码生成","author_index":"Weiba"},{"id":"619b29b0467237f89e1c762af113868c","title":"CentOS7 忘记密码后修改","content":"\n\n\n\n\n\n\n\n\n网上的大部分教程都是坑。。\n按这个教程来ok了： CentOS7 忘记密码\n大致不走如下：\n修改引导修改这两处即可:\n\n按 Ctrl+X 启动系统\n进入shell首先切换至 root 用户， 网上教程大多没有\n1chroot /sysroot\n\n再使用 passwd root 修改密码。\n最后 touch /.autorelabel, 在&#x2F;目录下创建一个.autorelabel文件，有这个文件存在，系统在重启时就会对整个文件系统进行relabeling。\nexit&amp;&amp;reboot\n","slug":"CentOS7 忘记密码后修改","date":"2019-10-11T05:22:02.000Z","categories_index":"CentOS7","tags_index":"CentOS7,忘记密码,经验","author_index":"Weiba"},{"id":"d29e64cf6771700eaa47facdb4bd1625","title":"Chrome WebView Debug","content":"PC 端调试 Android Web View 注意事项~\n\n必须翻墙， 因为他需要连接Google的两个域名， 暂不知道是干什么的。\n\n相关域名：chrome-devtools-frontend.appspot.com, chrometophone.appspot.com,\n也可以添加 hosts 来实现\n12172.217.14.116\tchrome-devtools-frontend.appspot.com172.217.14.116\tchrometophone.appspot.com","slug":"Android-Chrome WebView Debug","date":"2019-09-10T05:45:38.000Z","categories_index":"Android","tags_index":"Chrome,WebView,Debug","author_index":"Weiba"},{"id":"dbfd3e1a17b7ff22880d08acb8468aa7","title":"Docker 安装 Nexus3 docker仓库","content":"使用容器安装Nexus3 仓库，真的非常方便\n下载镜像nexus3 的镜像名称为 sonatype&#x2F;nexus3 我们直接用 docker 工具下载即可：\n1docker pull sonatype/nexus3\n\n运行镜像注意这里需要开启后面docker仓库的端口，不然连不上，不知道为啥教程都没说\n1docker run -d -p 8081:8081 -p 8082:8082 --name nexus3 sonatype/nexus3\n\n可以使用logs看日志\n1docker logs -f nexus3\n\n显示到如图所示，即运行成功， 浏览器打开 http://localhost:8081\n默认账号&#x2F;密码： admin/admin123\n创建 docker 仓库登录后在repositories - Create repository 创建仓库，类型选择docker(hosted), 名字随便取，主要是这个api端口一定要与映射的一致。\n\n注意如不勾选兼容v1 API 将无法支持docker search 127.0.0.1:8082/weiba 搜索\nv2 API\ncurl 127.0.0.1:8082/v2/_catalog - 查看仓库镜像列表\ncurl 127.0.0.1:8082/v2/ubuntu/tags/list - 查看镜像tag列表\n\n创建安全规则在 security - Roles - Create role ， 在privlleges上输入docker全选到右侧\n创建账号在 security - Users Create user ， 在available中选择docker\ndocker 登录仓库使用下面的命令登录：\n1docker login 127.0.0.1:8082\n\n登录一次后会保存密码，下次不用再输入。\n退出登录\n1docker logout\n\n推送镜像到仓库首先给镜像打标签\n1sudo docker tag ubuntu:latest 127.0.0.1:8082/ubuntu:weiba   \n看看是否存在：\n推送镜像：\n1sudo docker push 127.0.0.1:8082/ubuntu\n\n删除本地镜像，再从本地仓库获取测试：\n1234567891011weiba@weiba-PC:~$ sudo docker rmi -f 127.0.0.1:8082/ubuntu:weibaUntagged: 127.0.0.1:8082/ubuntu:weibaUntagged: 127.0.0.1:8082/ubuntu@sha256:acd85db6e4b18aafa7fcde5480872909bd8e6d5fbd4e5e790ecc09acc06a8b78weiba@weiba-PC:~$ sudo docker rmi -f ubuntu:latestUntagged: ubuntu:latestUntagged: ubuntu@sha256:6d0e0c26489e33f5a6f0020edface2727db9489744ecc9b4f50c7fa671f23c49Deleted: sha256:93fd78260bd1495afb484371928661f63e64be306b7ac48e2d13ce9422dfee26Deleted: sha256:1c8cd755b52d6656df927bc8716ee0905853fada7ca200e4e6954bd010e792bbDeleted: sha256:9203aabb0b583c3cf927d2caf6ba5b11124b0a23f8d19afadb7b071049c3cf26Deleted: sha256:32f84095aed5a2e947b12a3813f019fc69f159cb5c7eae5dad69b2d98ffbeca4Deleted: sha256:bc7f4b25d0ae3524466891c41cefc7c6833c533e00ba80f8063c68da9a8b65fe\n\n从本地仓库下载镜像：\n12345678weiba@weiba-PC:~$ sudo docker pull 127.0.0.1:8082/ubuntu:weibaweiba: Pulling from ubuntu32802c0cfa4d: Pull complete da1315cffa03: Pull complete fa83472a3562: Pull complete f85999a86bef: Pull complete Digest: sha256:acd85db6e4b18aafa7fcde5480872909bd8e6d5fbd4e5e790ecc09acc06a8b78Status: Downloaded newer image for 127.0.0.1:8082/ubuntu:weiba\n查看镜像列表：\nweb端查看：\n扩展资料：\n\n更改仓库镜像地址为阿里云\n持久化数据，优化配置\n\n注意事项如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。\n这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。\nUbuntu 14.04, Debian 7 Wheezy对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中增加如下内容：\n1DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000&quot;\n重新启动服务。\n1sudo service docker restart\n\nUbuntu 16.04+, Debian 8+, centos 7对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）\n12345678&#123;  &quot;registry-mirror&quot;: [    &quot;https://registry.docker-cn.com&quot;  ],  &quot;insecure-registries&quot;: [    &quot;192.168.199.100:5000&quot;  ]&#125;\n注意：该文件必须符合 json 规范，否则 Docker 将不能启动。\nNGINX 加密代理证书的生成请参见 私有仓库高级配置 里面证书生成一节。\nNGINX 示例配置如下\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546upstream register&#123;    server &quot;YourHostName OR IP&quot;:5001; #端口为上面添加的私有镜像仓库是设置的 HTTP 选项的端口号    check interval=3000 rise=2 fall=10 timeout=1000 type=http;    check_http_send &quot;HEAD / HTTP/1.0\\r\\n\\r\\n&quot;;    check_http_expect_alive http_4xx;&#125;server &#123;    server_name YourDomainName;#如果没有 DNS 服务器做解析，请删除此选项使用本机 IP 地址访问    listen       443 ssl;    ssl_certificate key/example.crt;    ssl_certificate_key key/example.key;    ssl_session_timeout  5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers  HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers   on;    large_client_header_buffers 4 32k;    client_max_body_size 300m;    client_body_buffer_size 512k;    proxy_connect_timeout 600;    proxy_read_timeout   600;    proxy_send_timeout   600;    proxy_buffer_size    128k;    proxy_buffers       4 64k;    proxy_busy_buffers_size 128k;    proxy_temp_file_write_size 512k;    location / &#123;        proxy_set_header Host $host;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Forwarded-Port $server_port;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection $connection_upgrade;        proxy_redirect off;        proxy_set_header X-Real-IP $remote_addr;        proxy_pass http://register;        proxy_read_timeout 900s;    &#125;    error_page   500 502 503 504  /50x.html;&#125;\n\nDocker 主机访问镜像仓库如果不启用 SSL 加密可以通过前面章节的方法添加信任地址到 Docker 的配置文件中然后重启 Docker\n使用 SSL 加密以后程序需要访问就不能采用修改配置的访问了。具体方法如下：\n123$ openssl s_client -showcerts -connect YourDomainName OR HostIP:443 &lt;/dev/null 2&gt;/dev/null|openssl x509 -outform PEM &gt;ca.crt$ cat ca.crt | sudo tee -a /etc/ssl/certs/ca-certificates.crt$ systemctl restart docker\n\n使用 docker login YourDomainName OR HostIP 进行测试，用户名密码填写上面 Nexus 中生成的。\n","slug":"Docker 安装 Nexus3 docker仓库","date":"2019-09-10T03:30:54.000Z","categories_index":"Docker","tags_index":"docker,nexus3","author_index":"Weiba"},{"id":"e204c405c9b2a43359c6fc61df69c066","title":"记一次 SpringBoot 项目内存不断上涨的问题解决过程","content":"\n\n\n\n\n\n\n\n\n最近刚使用上 opencv 做图像处理, 部署后发现每次调完业务代码 RES 都会上涨近 300M, 测试环境测了两天, RES 已经到 11G 了, 开始以为是内存泄露, 各种释放对象, 然而没卵用…\n一. 开始排查一开始以为是内存泄露了, 各种 google 查看怎么排查,学到了不少, 之前都没怎么看过..\n查看内存占用比较高的前20个 (不知道为啥只有17个), 而且最高的是个 [C 对象, 看了一下没看出来啥.\n1jmap -histo 32382 | head -20\n\n导出堆内存, 可以下载下来用 JDK 自带的工具 jvisualvm 查看, 也可以直接在服务器上起服务查看, 占用最高的是 char[], 还有一个 HashMap, 代码中查了一圈, 没发现问题..\n1234# 导出堆内存jmap -dump:format=b,file=dump.bin 32382# 起服务, 直接web访问 ip:4000jhat -port 4000 dump.bin\n\n二. 确认问题最后转念一想, 会不会不是堆的问题, 做了三次测试, 每次调用业务接口内存都会上涨. 但是堆内存占用都没有什么变化, 这是当时的三次堆内存信息:\n1jmap -heap 32382 \n\n查看堆使用情况, 发现只有 850M 左右, 基本确定了不是堆的问题. \n1jmap -histo:live 32382\n\n三. 解决方法想着 opencv 使用 JNI 方式做的, 会不会是 Native Memory, 继续google.. 终于找到了一片文章: Java堆外内存增长问题排查Case, 用里面介绍的查看物理内存分配, 看到了大量的 anon 内存块, 不过我的都是1024的, 跟文章中有所不同. \n1pmap -d 32382\n\n文章中还提供了一个链接: 当Java虚拟机遇上Linux Arena内存池, 第二个例子跟我差不多, 都是 1024 的, 原因文章中也有介绍 : \n查看 glibc 版本: \n1/lib64/libc.so.6\n\n因为要部署到线上环境耗时耗力, 所以我没有更换 tcmalloc , 在启动脚本中加了一下环境变量: \n1export MALLOC_ARENA_MAX=4\n测试了一下, RES 始终稳定在 1.3g 左右, 已经很满意了. export MALLOC_ARENA_MAX 设置为 1 时内存在 1g 左右, 但文章中说可能对性能有损耗, 所以我还是设置为 4 了, 持续观察~\n看着不多, 但是这一块相当不熟悉, 所以花了很久才找到解决方法, 继续学习啊~\n","slug":"记一次 SpringBoot 项目内存不断上涨的问题解决过程","date":"2019-08-30T05:22:51.000Z","categories_index":"SpringBoot","tags_index":"经验,SpringBoot","author_index":"Weiba"},{"id":"4f5020ab021f9f69bb62bb39309d5485","title":"Thymeleaf 调用java方法","content":"Thymeleaf 调用java方法创建对象调用:\n1&lt;td th:text=&quot;$&#123;new java.text.DecimalFormat(&#x27;#00%&#x27;).format(student.scoringRate)&#125; &quot;&gt;100%&lt;/td&gt;\n\n静态方法调用:\n1$&#123;T(java.lang.Math).abs(student.classRankChangeSum)&#125;\n\n调用springbean:\n1$&#123;@beanName.getStudents()&#125;\n\n","slug":"Thymeleaf 调用java方法","date":"2019-08-23T04:52:34.000Z","categories_index":"Thymeleaf","tags_index":"Thymeleaf","author_index":"Weiba"},{"id":"3e69cc03e036568c897eea1884180a7b","title":"Mybatis mapper中的小技巧","content":"小技巧当只传入一个变量时, 可以使用_parameter来指代它这里的_parameter就代表传入的parameterType的值\n123456&lt;select id=&quot;queryWork&quot; parameterType=&quot;int&quot; resultType=&quot;int&quot;&gt;   SELECT COUNT(isWork) FROM student&lt;if test=&quot;_parameter!=0&quot;&gt;       where isWork=#&#123;isWork&#125;;&lt;/if&gt;&lt;/select&gt;\n\n传入对象中有Integ[]数组时, 通过 ${par[0]} 下标取值\n添加 sql 日志配置文件添加\n12mybatis:  config-location: classpath:mybatis-config.xml\n\nmybatis-config.xml 添加\n123&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;\n\n不显示的话直接在logback.xml中添加:\n1&lt;logger name=&quot;xxx.dao&quot; level=&quot;debug&quot;/&gt;","slug":"Mybatis mapper中的小技巧","date":"2019-08-23T04:51:02.000Z","categories_index":"Mybatis","tags_index":"经验,Mybatis","author_index":"Weiba"},{"id":"899eecff22fb67a409c8e8dd7bf92429","title":"使用RamDisk加速Idea","content":"E盘为 RamDisk虚拟磁盘。\n剪切 idea 主要的工作目录C:\\Users\\用户名.IntelliJIdea2019.2 文件夹到 E:\\Users\\用户名.IntelliJIdea2019.2 \nmklink 创建文件夹软链接mklink &#x2F;J C:\\Users\\用户名.IntelliJIdea2019.2 E:\\Users\\用户名.IntelliJIdea2019.2 \n注意 C 盘的 .IntelliJIdea2019.2 创建软连接时必须不存在， 所以第一步需要剪切， 或者复制后删除\n","slug":"使用RamDisk加速Idea","date":"2019-08-19T04:23:13.000Z","categories_index":"RamDisk","tags_index":"idea,Ramdisk","author_index":"Weiba"},{"id":"a465c4657a75baece0af2cd4f6ae40c5","title":"Docker 常用命令","content":"#shell\n\nsystemctl start docker - 启动\nservice docker restart - 重启\ndocker version - 查看运行状态\n/etc/docker/daemon.json - 镜像源文件1234`vim /etc/docker/daemon.json` &#123;  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125;\n\n镜像相关\ndocker image ls - 列出已下载的镜像\n\ndocker image ls -f dangling=true - 查看虚悬镜像， 有的镜像更新后可能会出现既没有仓库名，也没有标签，均为 ，称为虚悬镜像，可用此命令查看\n\ndocker image prune - 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用此命令删除。\n\ndocker rm $(docker ps -aq) - 删除所有镜像\n\ndocker rm -v - 删除镜像时同事删除其数据卷\n\ndocker rmi $(docker images -q) - 删除所有镜像\n\ndocker rmi -f 127.0.0.1:8082/weiba/nginx:weiba - 删除指定tag容器\n\ndocker save 镜像id &gt; tomcat8-apr.tar - 导出镜像\n\ndocker load &lt; tomcat8-apr.tar - 导入镜像\n\ndocker rmi docker images | grep  &quot;&lt;none&gt;&quot; | awk &#39;&#123;print $3&#125;&#39; 删除所有none镜像\n\ndocker rmi -f docker images | grep  &quot;&lt;none&gt;&quot; | awk &#39;&#123;print $3&#125;&#39; 强制删除所有none镜像\n  1234567镜像和容器 导出和导入的区别镜像导入和容器导入的区别：1）容器导入 是将当前容器 变成一个新的镜像2）镜像导入 是复制的过程save 和 export区别：1）save 保存镜像所有的信息-包含历史2）export 只导出当前的信息\n\ndocker history 90457edaf6ff - 查看镜像&#x2F;容器历史操作记录\n\n\n容器相关\ndocker container rm  trusting_newton - 清理指定的处于终止状态的容器\n\ndocker container prune - 清理所有处于终止状态的容器\n\ndocker container start xxx - 重新启动终止的容器\n\ndocker ps - 查看运行中的容器\n\ndocker container ls - 查看运行的容器状态\n\ndocker container ls -a - 查看所有已经创建的包括终止状态的容器\n\ndocker inspect web - 查看web容器的信息\n\ndocker stop 容器id&amp;&amp;docker container stop xxx - 停止指定容器, 在docker stop命令执行的时候，会先向容器中PID为1的进程发送系统信号SIGTERM，然后等待容器中的应用程序终止执行，如果等待时间达到设定的超时时间，或者默认的10秒，会继续发送SIGKILL的系统信号强行kill掉进程。\n\ndocker kill xxx&amp;&amp;docker container kill xxx - 立刻停止容器，该命令不会等待容器中的应用终止。\n\ndocker stop $(docker ps -aq) - 停止所有容器\n\ndocker restart 容器id - 重启指定容器\n\ndocker export b91d9ad83efa &gt; tomcat80824.tar - 导入容器\n\ndocker import tomcat80824.tar - 导入容器\n\ndocker import http://example.com/exampleimage.tgz example/imagerepo - 从网络导入\n  1注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。\n\n容器运行相关\ndocker exec -i -t 0a4f bash - 运行&#x2F;进入 容器，使用exec方式运行容器内的bash，在其中exit容器不会停止，使用run方式运行的容器，exit后容器会停止\n\ndocker inspect --format  &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; nexus3 - 查看容器pid\n\nnsenter --target PID --mount --uts --ipc --net --pid - 根据pid进入容器\n\ndocker run hello-world - 使用docker运行hello-world, 如果运行的image不存在会自动从仓库下载并运行。\n\ndocker run -p 22:22 -p 1080:1080 nginx - 给容器映射多个端口 \n\ndocker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; - \n1-d 守护状态运行容器，此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。**容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。**\ndocker run -it ubuntu - 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 &#x2F;bin&#x2F;bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。\n\ndocker run -it ubuntu bash - 使用docker运行Ubuntu并执行bash命令： \n\n\n\n\n\n\n\n\n\n-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。ubuntu：这是指用 ubuntu 镜像为基础来启动容器。bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。\n\ndocker run -it ubuntu cat /etc/os-release - 我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat &#x2F;etc&#x2F;os-release。这就是用 cat &#x2F;etc&#x2F;os-release 命令替换了默认的 &#x2F;bin&#x2F;bash 命令了，输出了系统版本信息。\n\ndocker run -it --rm --name test centos /bin/bash - 退出后自己删除\n\n\n日志相关\ndocker logs xxx - 查看容器运行时输出日志\ndocker logs -f xxx - 滚动查看日志\n\n仓库相关\ndocker login 127.0.0.1:8082 - 登录仓库\ndocker pull 127.0.0.1:8082/weiba/nginx:weiba - 下载镜像到本地\ndocker pull 127.0.0.1:8082/weiba/nginx:weiba - - 推送镜像到127.0.0.1:8082 仓库\ndocker search 127.0.0.1:8082/weiba - v1 API 直接docker搜索私有仓库镜像，v2 API 不支持搜索\ncurl 127.0.0.1:8082/v2/_catalog - v2 API 查看私有Nexus3 Docker仓库镜像列表\ncurl 127.0.0.1:8082/v2/ubuntu/tags/list - v2 API Nexus3 Docker 查看ubuntu镜像标签列表\n\n数据卷相关\ndocker volume ls - 查看数据卷\n\ndocker volume create my-vol - 创建一个my-vol数据卷\n\ndocker volume rm my-vol - 删除数据卷\n\ndocker volume inspect my-vol - 查看数据卷信息\n\ndocker volume prune - 删除无主数据卷\n\ndocker run -d -P --name web --mount type=bind,source=/src/webapp,target=/opt/webapp training/webapp python app.py\n\n使用–mount将主机&#x2F;src&#x2F;webapp目录挂载到容器的&#x2F;opt&#x2F;webapp目录。主机目录不存在时会报错,可以使用-v /src/webapp:/opt/webapp替换--mount type=bind,source=/src/webapp,target=/opt/webapp参数，如果本地目录不存在 Docker 会自动为你创建一个文件夹\n\nDocker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读\n  1--mount type=bind,source=/src/webapp,target=/opt/webapp,readonly\n\n\ndocker run --rm -it --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history ubuntu:18.04 bash - 挂载单个文件到容器，这是历史记录文件，创建后可以记录在容器中的操作哦\n\n-v $HOME/.bash_history:/root/.bash_history  - 文件不存在时自动创建文件\n\n\n宿主机与容器拷贝文件\n  12341.docker ps -a  查看对应容器的ID2.docker inspect -f &quot;&#123;&#123;.Id&#125;&#125;&quot; d4f6bfca36fa   查到容器的存储ID值3.接下来直接cp就行cp elasticsearch-5.2.1.rpm /software/data/docker/devicemapper/mnt/d4f6bfca36faa70276a40dd560d8a0d29b2fa5f3f8d6acc2189d185ac1f5b1c3/rootfs/root/\n\nTag 相关\ndocker tag nginx:latest 127.0.0.1:8082/weiba/nginx:weiba - 生成tag\n\n网络相关\ndocker run -d -P(大写) training/webapp python app.py - 随机映射一个 49000~49900 的端口到内部容器开放的网络端口\n\n-p(小写) 参数格式 - ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort， 该标记可以多次使用来绑定多个端口\n\ndocker run -d -p 5000:5000 training/webapp python app.py - 使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口\n\ndocker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py - 使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1\n\ndocker run -d -p 127.0.0.1::5000 training/webapp python app.py - 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。\n\ndocker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py - 还可以使用 udp 标记来指定 udp 端口\n\ndocker port 8a256 - 根据镜像名称或id查看映射的端口配置\n\n&#96;docker port 8a256 8081 - 查看8081端口绑定的地址\n\n\n容器互联\ndocker network create -d bridge my-net - 创建一个新的 Docker 网络。\n-d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 Swarm mode。\ndocker run -it --rm --name busybox1 --network my-net busybox sh - 运行一个容器并连接到新建的 my-net 网络\ndocker run -it --rm --name busybox2 --network my-net busybox sh - 打开新的终端，再运行一个容器并加入到 my-net 网络\n在 busybox1 容器输入以下 ping busybox2\n在 busybox2 容器执行 ping busybox1\n即可发现已可以互相通过内网地址通信\n\n\n\n##配置DNS如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。\n在容器中使用 mount 命令可以看到挂载信息：\n1234$ mount/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 .../dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...tmpfs on /etc/resolv.conf type tmpfs ...\n这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 &#x2F;etc&#x2F;resolv.conf 文件立刻得到更新。\n配置全部容器的 DNS ，也可以在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件中增加以下内容来设置。\n123456&#123;  &quot;dns&quot; : [    &quot;114.114.114.114&quot;,    &quot;8.8.8.8&quot;  ]&#125;\n这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。使用以下命令来证明其已经生效。\n1234$ docker run -it --rm ubuntu:18.04  cat etc/resolv.confnameserver 114.114.114.114nameserver 8.8.8.8\n\n如果用户想要手动指定容器的配置，可以在使用 docker run 命令启动容器时加入如下参数：\n-h HOSTNAME 或者 –hostname&#x3D;HOSTNAME 设定容器的主机名，它会被写到容器内的 &#x2F;etc&#x2F;hostname 和 &#x2F;etc&#x2F;hosts。但它在容器外部看不到，既不会在 docker container ls 中显示，也不会在其他的容器的 &#x2F;etc&#x2F;hosts 看到。\n–dns&#x3D;IP_ADDRESS 添加 DNS 服务器到容器的 &#x2F;etc&#x2F;resolv.conf 中，让容器用这个服务器来解析所有不在 &#x2F;etc&#x2F;hosts 中的主机名。\n–dns-search&#x3D;DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。\n注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 &#x2F;etc&#x2F;resolv.conf 来配置容器。\n列出镜像\ndocker image ls - 列出已下载的镜像\n\ndocker system df - 查看镜像、容器、数据卷所占用的空间\n\ndocker image ls -f dangling=true - 查看虚悬镜像， 有的镜像更新后可能会出现既没有仓库名，也没有标签，均为 ，称为虚悬镜像，可用此命令查看\n\ndocker image prune - 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。\n\ndocker image ls -a - 中间层镜像，为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。\n\n\n不加任何参数的情况下，docker image ls 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。\n\ndocker image ls ubuntu - 根据仓库名列出镜像\ndocker image ls ubuntu:18.04 - 列出特定的某个镜像，也就是说指定仓库名和标签\ndocker image ls -f since=mongo:3.2 - 除此以外，docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。\ndocker image ls -f label=com.example.version=0.1 - 如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。\n\n以特定格式显示默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 docker image ls 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。\n\ndocker image ls -q - 列出镜像id\ndocker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot; - 列出镜像，只包含镜像ID和仓库名\nsudo docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;:&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Size&#125;&#125;&quot;\ndocker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot; - 以表格等距显示，并且有标题行，和默认一样，不过自己定义列\n\n删除本地镜像\ndocker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] - 删除本地的镜像\ndocker image rm $(docker image ls -q redis) - 删除所有名为redis的镜像\ndocker image rm $(docker image ls -q -f before=mongo:3.2) - 删除所有在 mongo:3.2 之前的镜像\n\ncommit 修改镜像， 一般不使用commit修改镜像\n运行nginx镜像\n\n\ndocker run --name webserver -d -p 80:80 nginx\n\n\n修改nginx启动页面\n\n\ndocker exec -it webserver bash - 进入webserver镜像\necho &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html - 修改启动页面，刷新即可看到。\n修改后的镜像不commit，镜像重启后会恢复原样。\n\n\n\n\n查看镜像修改内容\n\n\ndocker diff webserver - 退出镜像后可以查看修改的记录\n\n\n保存修改生成新的镜像\n\n\ndocker commit --author &quot;weiba &lt;test@gmail.com&gt;&quot; --message &quot;修改nginx默 认网页&quot; webserver nginx:v2 – 生成新的镜像，–author 是指定修改的作者，而 –message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。\n\n\n查看镜像操作记录，可以查看刚刚的commit\n\n\ndocker history nginx:v2 - 查看镜像的操作记录\n\n\n启动刚刚修改的镜像\n\n\ndocker run --name web2 -d -p 81:80 nginx:v2 - 启动镜像\n\n慎用 docker commit使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。\n首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。\n此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。\n而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。\n使用 Dockerfile 定制镜像在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：\n123$ mkdir mynginx$ cd mynginx$ touch Dockerfile\n其内容为：\n12FROM nginxRUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html\n\n这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。\nFROM 指定基础镜像所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。\n除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。\n12FROM scratch...\n如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。\nRUN 执行命令RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：\n\nshell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。1RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html\nexec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。\n\n既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：\n123456789FROM debian:jessieRUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install\n之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。\nUnion FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。\n上面的 Dockerfile 正确的写法应该是这样：\n1234567891011121314FROM debian:jessieRUN buildDeps=&#x27;gcc libc6-dev make&#x27; \\    &amp;&amp; apt-get update \\    &amp;&amp; apt-get install -y $buildDeps \\    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \\    &amp;&amp; mkdir -p /usr/src/redis \\    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\    &amp;&amp; make -C /usr/src/redis \\    &amp;&amp; make -C /usr/src/redis install \\    &amp;&amp; rm -rf /var/lib/apt/lists/* \\    &amp;&amp; rm redis.tar.gz \\    &amp;&amp; rm -r /usr/src/redis \\    &amp;&amp; apt-get purge -y --auto-remove $buildDeps\n\n首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。\n并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。\n此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n构建镜像在 Dockerfile 文件所在目录执行: $ docker build -t nginx:v3 ., 注意后面的一个点，代表当前文件夹，这是在指定上下文路径启动测试：docker run --name webserver -d -p 80:80 nginx:v3\n什么是上下文？首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。\n当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？\n这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。\n如果在 Dockerfile 中这么写：\n1COPY ./package.json /app/\n这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。\n因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ..&#x2F;package.json &#x2F;app 或者 COPY &#x2F;opt&#x2F;xxxx &#x2F;app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。\n一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来. 如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用.gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。\n那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。\n这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ..&#x2F;Dockerfile.php 参数指定某个文件作为 Dockerfile： docker build -t nginx:v4 -f test .\n当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。\n其它 docker build 的用法\n直接用 Git repo 进行构建docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建：\n12345678$ docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14docker build https://github.com/twang2218/gitlab-ce-zh.git\\#:8.14Sending build context to Docker daemon 2.048 kBStep 1 : FROM gitlab/gitlab-ce:8.14.0-ce.08.14.0-ce.0: Pulling from gitlab/gitlab-ceaed15891ba52: Already exists773ae8583d14: Already exists...\n这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 &#x2F;8.14&#x2F;，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。\n\n用给定的 tar 压缩包构建\n1$ docker build http://server/context.tar.gz\n\n从标准输入中读取 Dockerfile 进行构建\n1docker build - &lt; Dockerfile\n或\n1cat Dockerfile | docker build -\n如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。\n\n从标准输入中读取上下文压缩包进行构建\n1$ docker build - &lt; context.tar.gz\n如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。\n\n\ndocker save 和 docker load\n保存镜像使用 docker save 命令可以将镜像保存为归档文件。比如我们希望保存这个 alpine 镜像。1$ docker save alpine | gzip &gt; alpine-latest.tar.gz\n然后我们将 alpine-latest.tar.gz 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：12$ docker load -i alpine-latest.tar.gzLoaded image: alpine:latest\n如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：1docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; &#x27;cat | docker load&#x27;\n\n进入容器在使用 -d 参数时，容器启动后会进入后台。\n某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。\n\nattach 命令docker attach 是 Docker 自带的命令。下面示例如何使用该命令。\n12345678910root@weiba-PC:/home/weiba/mynginx# docker run -dit ubuntu02d28e91c81bbd565942c1cc7ec17d9fc46265c47c0e82a78df6e465cdcf77b8root@weiba-PC:/home/weiba/mynginx# docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES02d28e91c81b        ubuntu              &quot;/bin/bash&quot;         14 seconds ago      Up 12 seconds                           wonderful_torvaldsroot@weiba-PC:/home/weiba/mynginx# docker attach 02droot@02d28e91c81b:/# exitexitroot@weiba-PC:/home/weiba/mynginx# docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n注意： 如果从这个 stdin 中 exit，会导致容器的停止。\n\nexec 命令-i -t 参数docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。\n\n\n只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。\n当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。\n12345678910111213141516171819202122232425262728293031323334root@weiba-PC:/home/weiba/mynginx# docker run -dit ubuntu0a4f6cf3ef619bfa82d0671defed695a305653ce10ec347c9551fc062dbcf6e4root@weiba-PC:/home/weiba/mynginx# docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES0a4f6cf3ef61        ubuntu              &quot;/bin/bash&quot;         11 seconds ago      Up 10 seconds                           fervent_minskyroot@weiba-PC:/home/weiba/mynginx# docker exec -i 0a4f bashlsbinbootdevetchomeliblib64mediamntoptprocrootrunsbinsrvsystmpusrvarexitroot@weiba-PC:/home/weiba/mynginx# docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES0a4f6cf3ef61        ubuntu              &quot;/bin/bash&quot;         54 seconds ago      Up 53 seconds                           fervent_minskyroot@weiba-PC:/home/weiba/mynginx# docker exec -i -t 0a4f bashroot@0a4f6cf3ef61:/# lsbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n如果从这个 stdin 中 exit，不会导致容器的停止。推荐大家使用 docker exec\n安装 Nexus3 私有仓库1234docker run -d --name nexus3 --restart=always \\    -p 8081:8081 \\    --mount src=nexus-data,target=/nexus-data \\    sonatype/nexus3\n等待 3-5 分钟，如果 nexus3 容器没有异常退出，那么你可以使用浏览器打开 http://YourIP:8081 访问 Nexus 了。\n第一次启动 Nexus 的默认帐号是 admin 密码是 admin123 登录以后点击页面上方的齿轮按钮进行设置。\n第一次启动 Nexus 的默认帐号是 admin 密码是 admin123 登录以后点击页面上方的齿轮按钮进行设置。\n","slug":"Docker 常用命令","date":"2019-08-12T03:35:42.000Z","categories_index":"Docker","tags_index":"docker","author_index":"Weiba"},{"id":"abb7b100693f257cce1f4583ac951898","title":"Deepin 安装 Docker","content":"\n\n\n\n\n\n\n\n\n最近公司发布会由于是异地举行，被部署搞的很伤，连续加了几天班，大多都是因为运行环境问题，所以这次会后，领导准备全面使用docker，将整体服务容器化，后期使用自动部署解决这个问题。我们现在使用的是Spring Cloud，比较容易迁移，自己也一直想看看docker，在deepin上测试一下。\n安装Docker根据deepin官方wiki安装即可： Deepin安装Docker教程\nDocker 详细文档：Docker文档\nDocker 仓库：https://store.docker.com/要注意的地方：\n\n添加docker仓库的时候，注意更换版本代号，因为deepin是基于debian的，所以改成debian的即可。我的deepin是15.8，debian版为8.0，版本号改为jessie即可。 相关命令：\n\n123lsb_release -cscat /etc/debian_versionsudo add-apt-repository  &quot;deb [arch=amd64] https://download.docker.com/linux/debian jessie stable&quot;\n\n之后就是更新仓库 sudo apt-get update， 安装sudo apt-get install docker-ce 。\n我没有按文档更改docker.service的unit文件，直接启动成功～\n\nsystemctl start docker - 开启docker\n\ndocker version - 查看docker版本\n\n提示没有权限读取服务端信息使用sudo docker version 即可\n\n\n运行测试\nsudo docker run hello-world 下载镜像并运行\n\nCentOS&#x2F;RHEL 的用户需要注意的事项在 Ubuntu&#x2F;Debian 上有 UnionFS 可以使用，如 aufs 或者 overlay2，而 CentOS 和 RHEL 的内核中没有相关驱动。因此对于这类系统，一般使用 devicemapper 驱动利用 LVM 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。Docker 安装在 CentOS&#x2F;RHEL 上后，会默认选择 devicemapper，但是为了简化配置，其 devicemapper 是跑在一个稀疏文件模拟的块设备上，也被称为 loop-lvm。这样的选择是因为不需要额外配置就可以运行 Docker，这是自动配置唯一能做到的事情。但是 loop-lvm 的做法非常不好，其稳定性、性能更差，无论是日志还是 docker info 中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给 devicemapper 驱动做存储层的做法，这类做法也被称为配置 direct-lvm。\n除了前面说到的问题外，devicemapper + loop-lvm 还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;devicemapper&#x2F;data 不断增长，而且无法控制。很多人会希望删除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，随着使用这个稀疏文件一直在不断增长。\n所以对于 CentOS&#x2F;RHEL 的用户来说，在没有办法使用 UnionFS 的情况下，一定要配置 direct-lvm 给 devicemapper，无论是为了性能、稳定性还是空间利用率。\n或许有人注意到了 CentOS 7 中存在被 backports 回来的 overlay 驱动，不过 CentOS 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。\n","slug":"Deepin 安装 Docker","date":"2019-08-12T03:34:46.000Z","categories_index":"Docker","tags_index":"docker,deepin","author_index":"Weiba"},{"id":"01b31d33e59784cdd89994ca196501a5","title":"Docker 容器的底层实现（转载资料）","content":"写的非常详细，可以直接去原文看： Docker(1)底层实现\n以下存档防止丢失～～\nDocker底层实现Docker并没有传统虚拟化的Hypervisor层,因为dokcer是基于容器技术的轻量级虚拟化,相对于传统的虚拟化，省去了Hypervisor层的开销,而且其虚拟化技术是基于内核的Cgroup和Namespace技术,处理逻辑与内核深度融合,所以在很多方面,docker的性能与物理机非常接近\n在通信上,Docker并不会直接与内核交互,它是通过一个更底层的工具Libcontainer与内核交互的,Libcontainer 是真正意义上的容器引擎,它通过clone系统调用直接创建容器,通过pivot_root系统调用进入容器,且通过直接操作cgroupfs文件实现对资源的管控\nDocker本身则侧重于处理更上层的业务\n容器&#x3D;cgroup+namespace+rootfs+容器引擎(用户态工具LXC)　　.Cgroup　　资源控制　　.Namespace　　访问隔离　　.rootfs　　文件系统隔离　　.容器引擎　　生命周期控制\nDocker底层的核心技术包括,linux上的名称空间(Namesaces),控制组(Contorl groups)，Union文件系统,和容器格式(Container format)\nCgroup是什么它是control groups 的简写,属于linux内核的一个特性,用于限制和隔离一组进程对系统资源的使用\n资源:CPU,内存,block I&#x2F;O 网络带宽\ndevices:设备权限控制\ncpuset:分配指定cpu和内存节点\ncpu：控制cpu占用率\ncpuacct:统计CPU使用情况\nmemory:限制内存的使用上限\nfreezer:冻结(暂停) Cgroup中的进程\nnet_cls:配合tc(traffic controller) 限制网络带宽\nnet_prio:设置进程的网络流量优先级\nhuge_tlb:限制HugeTLB的使用\nperf_event:允许Perf工具基于Cgroup分组做性能检测\n容器机制:让某些进程在彼此隔离的名字空间运行,大家虽然都共用一个内核和某些运行时的环境(例如一些系统命令和库)，但是彼此都看不到，都以为系统中只有自己存在\n\n名字空间来做权限的隔离控制\n利用cgroups来做资源分配\n\n__Cgroup__的接口和使用\n挂载cgroupfs\n1mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/\n\n查看cgroupfs\n 1234567891011121314151617181920212223[root@linux-node2 cgroup]# ll /sys/fs/cgroup/总用量 0-rw-r--r-- 1 root root 0 5月  18 14:08 cgroup.clone_children--w--w--w- 1 root root 0 5月  18 14:08 cgroup.event_control-rw-r--r-- 1 root root 0 5月  18 14:08 cgroup.procs-r--r--r-- 1 root root 0 5月  18 14:08 cgroup.sane_behavior-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.cpu_exclusive-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.cpus-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.mem_exclusive-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.mem_hardwall-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_migrate-r--r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_pressure-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_pressure_enabled-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_spread_page-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_spread_slab-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.mems-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.sched_load_balance-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.sched_relax_domain_leveldrwxr-xr-x 2 root root 0 7月   4 15:26 dockerdrwxr-xr-x 4 root root 0 5月  18 14:09 libvirt-rw-r--r-- 1 root root 0 5月  18 14:08 notify_on_release-rw-r--r-- 1 root root 0 5月  18 14:08 release_agent-rw-r--r-- 1 root root 0 5月  18 14:08 tasks\n 可以看到这里有很多的控制文件,其中以cpuset开头的控制文件,都是由cpuset子系统产生的,其他文件则是由Cgroup产生, 这里的tasks文件记录了这个Cgroup的所有进程，包括线程，在系统启动后,默认没有对Cgroup做任何配置的情况下,cgroupfs只有一个根目录,并且系统所有进程都在这个根目录中，既进程pid都在根目录tasks文件中\n\n创建Cgroup\n 1mkdir /sys/fs/cgroup/child\n 这样就创建了一个新的Cgroup\n\n配置Cgroup\n 12[root@linux-node2 cgroup]# echo 0 &gt; child/cpuset.cpus[root@linux-node2 cgroup]# echo 0 &gt; child/cpuset.mems\n 这样就可以限制这个Cgroup的进程只能在0号CPU上运行,并且只会从0号内存节点分配内存\n\n使能Cgroup\n 1234567891011[root@linux-node2 child]# echo 2487 &gt; /sys/fs/cgroup/child/tasks 这里2487代表进程的pid号[root@linux-node2 child]# echo $$ &gt; /sys/fs/cgroup/child/tasks 也是可以的这里$$代表当前进程-----------------写入task只会把制定的进程加到child中.写入cgroup.procs则会把这个进程所属的整个线程都加到child中\n\nCgroup子系统介绍\ncpuet子系统 cpuset可以为一组进程分配指定的CPU和内存节点,cpuset一开始用在高性能计算(HPC)行的.在NUMA架构的服务器上,通过将进程绑定到固定的CPU和内存节点上 来避免进程在运行时因跨节点内存访问而导致的性能下降,当然,现在cpuset也广泛的用在了kvm和容器上\n\ncpuset主要接口: 12cpuset.cpus: 允许进程使用的CPU列表 (例如:0-4,9)cpuset.mems: 允许进程使用的内存节点列表 (例如0-1)\n\n\nCPU子系统  cpu子系统用于限制进程的CPU占用率,实际上它有三个功能,分别通过不同的接口来提供\n 12345CPU比重分配: 这个特性使用的接口是cpu.shares .如果cgroupfs目录下创建了2个Cgroup，分别是C1和C2,并且将cpu.shares分别设置为512和1024,那么当C1和C2争用CPU时,C2将会得到比C1 多一倍的CPU占用率,要值得注意的是,只有当它们争用CPU时,cpu.share才会起作用,如果C2是空闲的,那么C1可以得到全部的CPU资源CPU带宽限制:这个特性使用的接口是cpu.cfs_period_us和cpu.cfs_quota_us 。这2个接口单位是微秒实时进程的CPU带宽限制: 使用的是cpu.rt_period_us和cpu.rt__runtime_us\n\ncpuacct子系统 用来统计个Cgroup的CPU使用情况\n\nmemory子系统 限制Cgroup所能使用的内存上限,有如下接口\n\nmemory.limit_in_bytes: 设定内存上限,单位是字节,也可以使用k&#x2F;K，m&#x2F;M或者g&#x2F;G 表示要设置数值单位 123echo 1G &gt; memory.limit_in——bytes  如果Cgroup使用的内存超过上限,linux内核会尝试回收内存,如果仍然无法将内存使用量控制在上限之内,系统将会触发OOM，选择并杀死该Cgroup中的某个进程\nmemory.memsw.limit__in_bytes:设定内存加上交换分区的使用量,通过设置这个值,可以防止进程把交换分区用光\nmemory.oom_control: 如果设置为0，那么在内存使用量超过上限时,系统不会’杀死’ 进程,而是阻塞进程直到有内存被释放可供使用时: 另一方面,系统会向用户态发送事件通知,用户态的监控程序可以根据该事件来做相应的处理,例如提高内存上限等\n\n\nblkio子系统用来限制Cgroup的block I&#x2F;O带宽\n\ndevices子系统控制Cgroup的进程对那些设备有访问权限\n\n\n基本架构Docker采用了C&#x2F;S架构客户端和服务端可以运行在一个机器上,也可以通过socket或者RESTful API 来进行通信Docker  daemon 一般在宿主机后台运行,等待接收客户端的消息Docker客户端则为客户提供一系列可执行的命令, 用户使用这些命令跟docker daemon交互\n剖析名字空间　　名字空间是linux内核一个强大的特性，每个容器都有自己单独的名字空间,运行在其中的应用都像是在独立的操作系统一样。名字空间保证了各容器之前互不影响\npid名字空间　　不同用户的进程就是通过pid名字空间隔离开来的,且不同名字空间中可以有相同的pid。所有的LXC进程在Dokcer中的父进程为dokcer进程\n每个LXC(基于容器的操作系统层级的虚拟化技术)进程具有不同的名字空间,同时由于永许嵌套,因此可以很方便的实现嵌套的Docker容器\nnet名字空间　　网络端口还是共享的host端口 ，网络隔离是通过net名字空间实现的, 每个net名字空间有独立的网络设置,IP地址,路由表,&#x2F;proc&#x2F;net 目录(proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口)。这样每个容器就隔离开来。Docker默认采用veth方式(成对出现的点对点网络设置)【&#x3D;&#x3D;懵逼状态。。】 将容器中的虚拟网卡同host上的一个Dokcer网桥docker0连接在一起\n软连：http://www.open-open.com/lib/view/open1488423458438.html\nipc名字空间　　容器中进程交互还是采用了linux常见的进程交互方法，包括信号量，消息队列,共享内存等，容器的进程间交互实际上还是host上具有相同pid名字空间中的进程间交互,因此需要在ipc资源申请时加入名字空间信息,每个IPC资源有一个唯一的32位ID\nmnt名字空间　　类似chroot，将一个进程放到一个特定的目录执行,mnt名字空间允许不同名字空间的进程看到文件结构，这样每个名字空间中的进程所看到的文件目录就被隔离开来了。每个名字空间中的容器在 &#x2F;proc&#x2F;mounts的信息只包含所在名字空间的mount point\nuts名字空间　　UTS名字空间允许每个容器拥有独立的hostname和domain name 使其在网络上可以被视作一个独立的节点而非主机上的一个进程\nUSER 名字空间　　每个容器可以有不同的用户和组ID，也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户\n控制组　　控制组(cgroups)是linux内核的一个特性，主要用来对共享资源进行隔离,限制,审计等.只有能控制分配到容器的资源,才能避免当多个容器同时运行时对系统资源的竞争\nlinux内核2.6.24开始支持\n控制组可以提供对容器内的 内存，CPU,磁盘IO等资源的限制和计费管理\nUnion文件系统　　union文件系统(unionFS)是一种分层，轻量级并且高性能的文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下\n　　union文件系统是docker镜像的基础,镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具有应用镜像\n另外，不同docker容器就可以共享一些基础的文件系统层,同时再加上自己独有的改动层，大大提高了存储的效率\nDocker中使用的AUFS 就是一种union FS。 AUFS支持为每一个成员目录（类似git的分支）设定 只读，读写，写出 权限，同时AUFS里有一个类似分层的概念，对只读权限的分支可以逻辑上进行增量的修改(不影响只读部分)\nDocker目前支持的union文件系统种类包括 AUFS,btrfs，vfs和DeviceMapper\n容器格式最初，docker采用了LXC中的容器格式，自1.20版本开始,Docker也开始支持新的libcontainer格式，并作业默认选项\nDocker网络实现Docker 的网络实现其实就是利用了 Linux 上的网络名字空间和虚拟网络设备（特别是 veth pair）。建议先熟恲了解返两部分的基本概念再阅读本章。基本原理首先，要实现网络通信，机器需要至少一个网络接口（物理接口戒虚拟接口）来收发数据包；此外，如果丌同子网乀间要迕行通信，需要路由机制。Docker 中的网络接口默讣都是虚拟的接口。虚拟接口的优势乀一是转发效率较高。 Linux 通过在内核中迕行数据复制来实现虚拟接口乀间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对亍本地系统和容器内系统看来就像是一个正常的以太网卡，叧是它丌需要真正同外部网络设备通信，速度要徆快。Docker 容器网络就利用了返项技术。它在本地主机和容器内分别创建一个虚拟接口，幵讥它们彼此连通（返样的一对接口叨做 veth pair ）。\nveth pair\n镜像的实现原理Docker 镜像是怎举实现增量的修改和维护的？ 每个镜像都由徆多层次极成，Docker 使用 Union FS 将返些丌同的层结合到一个镜像中去。通常 Union FS 有两个用途, 一方面可以实现丌借劣 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个叧读的分支和一个可写的分支联合在一起，Live CD 正是基亍此方法可以允许在镜像丌变的基础上允许用户在其上迕行一些写操作。 Docker 在 AUFS 上极建的容器也是利用了类似的原理。\nDocker 容器容器是 Docker 又一核心概念。简单的说，容器是独立运行的一个戒一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。\n当操作docker run 内部实现docker run 来创建容器时，Docker 在后台运行的标准操作包括：检查本地是否存在指定的镜像，不存在就从公有仓库下载利用镜像创建并启动一个容器分配一个文件系统，并在叧读的镜像层外面挂载一层可读写层从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去从地址池配置一个 ip 地址给容器执行用户挃定的应用程序执行完毕后容器被终止\n数据卷数据卷是一个可供一个戒多个容器使用的特殊目录，它绕过 UFS，可以提供徆多有用的特性：数据卷可以在容器之间共享和重用对数据卷的修改会立马生效对数据卷的更新，不会影响镜像卷会一直存在，直到没有容器使用\n—数据卷的使用。类似于linux下对目录的mount\n使用 -v 标记来创建一个数据卷幵挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。\n1docker run -d -P --name web -v /webapp training/webapp python app.py\n使用 -v 标记也可以挃定挂载一个本地主机的目录到容器中去。\n1docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py\n加载主机的 &#x2F;src&#x2F;webapp 目录到容器的 &#x2F;opt&#x2F;webapp 目录，\n本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。\nDocker 挂载数据卷的默讣权限是读写，用户也可以通过 :ro 指定为只读\n1docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py","slug":"Docker 容器的底层实现（转载资料）","date":"2019-08-12T03:32:47.000Z","categories_index":"Docker","tags_index":"docker","author_index":"Weiba"},{"id":"70f3dc3b65ff84d1ff3522c18e25ad00","title":"JS工具集","content":"CommUtils.jsjs 工具集合: \n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353/** * 工具类 */&quot;use strict&quot;;var CommUtils = window.CommUtils = &#123;    //字符串动态替换     // CommUtils.formatStr(&quot;&#123;0&#125;不能为&#123;1&#125;&quot;, &quot;分数&quot;, &quot;0&quot; -&gt; &quot;分数不能为0&quot;\tformatStr : function()&#123; \t\tvar args = Array.prototype.slice.apply(arguments);\t\tvar that = this;\t\tif (args.length == 0) &#123;\t\t\treturn null;\t\t&#125; else if (args.length == 1) &#123;\t\t\treturn args[0];\t\t&#125; else &#123;\t\t\tvar template = args[0];\t\t\targs.splice(0,1);\t\t\tif (typeof args[0] == &#x27;object&#x27;) &#123;\t\t\t\t$.each(args[0], function(key, value) &#123;\t\t\t\t\ttemplate = template.replace(new RegExp(&quot;&#123;&quot; + key + &quot;&#125;&quot;, &quot;g&quot;), that.isEmpty(value) ? &#x27;&#x27; : value);\t\t\t\t&#125;)\t\t\t&#125; else &#123;\t\t\t\t$.each(args, function(key, value) &#123;\t\t\t\t\ttemplate = template.replace(eval(&quot;/(&#123;)&quot; + key + &quot;(&#125;)/g&quot;), that.isEmpty(value) ? &#x27;&#x27; : value);\t\t\t\t&#125;)\t\t\t&#125;\t\t\treturn template;\t\t&#125;\t&#125;,\t// layer tip 封装\t// CommUtils.initTip(); // 先载入jq扩展\t// $(&quot;#id&quot;).tip(&quot;提示信息&quot;, top, 12000)\tinitTip : function() &#123;\t\t$.fn.tip = function(content, direct, time) &#123;\t\t\tif (direct == undefined) direct = &#x27;bottom&#x27;;\t\t\tdirect = [&#x27;top&#x27;, &#x27;right&#x27;, &#x27;bottom&#x27;, &#x27;left&#x27;].indexOf(direct) + 1;\t\t\tvar index = layer.tips(content, this, &#123;\t\t\t\ttips : [direct, &#x27;#f5c564&#x27;],\t\t\t\ttime : time ? time : 2000,\t\t\t\tanim : 6,\t\t\t\ttipsMore : true\t\t\t&#125;);\t\t\tif (direct == 3) &#123;\t\t\t\t$(&#x27;.layui-layer-tips[times=&quot;&#x27; + index + &#x27;&quot;] .layui-layer-content&#x27;).css(&#x27;top&#x27;, &#x27;-8px&#x27;);\t\t\t&#125; else if (direct == 2) &#123;\t\t\t\t$(&#x27;.layui-layer-tips[times=&quot;&#x27; + index + &#x27;&quot;] .layui-layer-content&#x27;).css(&#x27;left&#x27;, &#x27;-8px&#x27;);\t\t\t&#125; else if (direct == 1) &#123;\t\t\t\t$(&#x27;.layui-layer-tips[times=&quot;&#x27; + index + &#x27;&quot;] .layui-layer-content&#x27;).css(&#x27;top&#x27;, &#x27;8px&#x27;);\t\t\t&#125; else if (direct == 4) &#123;\t\t\t\t$(&#x27;.layui-layer-tips[times=&quot;&#x27; + index + &#x27;&quot;] .layui-layer-content&#x27;).css(&#x27;left&#x27;, &#x27;8px&#x27;);\t\t\t&#125;\t\t&#125;\t&#125;,\t// layer 弹出层    openFrame : function(title, url, width, height) &#123; //layer frame窗口        this.layerWindow = layer.open(&#123;            type: 2,            anim: -1,            resize: false,            title: title,            shadeClose: false,            maxmin: true,            shade: 0.6,            area: [width || &#x27;90%&#x27;, height || &#x27;90%&#x27;],            content: url //iframe的url        &#125;);    &#125;,    // 对象判空并初始化\tifEmpty : function(obj, defaultValue) &#123;\t\treturn this.isEmpty(obj) ? this.isEmpty(defaultValue) ? &#x27;&#x27; : defaultValue : obj;\t&#125;,\t// 对象判空\tisEmpty : function(arg) &#123;\t\tif (arg == undefined || arg == null) &#123;\t\t\treturn true;\t\t&#125;\t\tif (typeof arg == &#x27;string&#x27;) &#123;\t\t\treturn arg == &#x27;&#x27; ? true : false;\t\t&#125; else if (typeof arg == &#x27;object&#x27;) &#123;\t\t\tif (arg instanceof Array &amp;&amp; arg.length == 0) &#123;\t\t\t\treturn true;\t\t\t&#125; else &#123;\t\t\t\treturn false;\t\t\t&#125;\t\t&#125; else if (typeof arg == &#x27;number&#x27;) &#123;\t\t\treturn false;\t\t&#125; else&#123;\t\t\treturn !!arg;\t\t&#125;\t&#125;,\t// 对象不为空\tisNotEmpty: function(arg) &#123;\t\treturn !this.isEmpty(arg);\t&#125;,\t// 计算文件大小\tgetFileSize : function(size)&#123; //根据大小计算文件大小\t\tvar unit = [&quot;B&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;];\t\tvar result = size,i = 0;\t\tfor (; i &lt;= 4; i++) &#123;\t\t\tif (result &gt; 1024) &#123;\t\t\t\tresult = result / 1024;\t\t\t\tresult = result.toFixed(2);\t\t\t&#125; else &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tif (i &gt; 4) &#123; i= 4;&#125;\t\treturn result + unit[i];\t&#125;,\t// 格式化时间\tformatDate : function (date, fmt) &#123; //author: meizz \t    var o = &#123;\t        &quot;M+&quot;: date.getMonth() + 1, //月份 \t        &quot;d+&quot;: date.getDate(), //日 \t        &quot;h+&quot;: date.getHours(), //小时 \t        &quot;m+&quot;: date.getMinutes(), //分 \t        &quot;s+&quot;: date.getSeconds(), //秒 \t        &quot;q+&quot;: Math.floor((date.getMonth() + 3) / 3), //季度 \t        &quot;S&quot;: date.getMilliseconds() //毫秒 \t    &#125;;\t    if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));\t    for (var k in o)\t    if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));\t    return fmt;\t&#125;,\t// ajax 封装\tajax : function(url, param, success, method, async) &#123; //异步请求\t\tvar _this = this;\t\tif (async == undefined) &#123;\t\t\tasync = true;\t\t&#125;\t\t$.ajax(&#123;\t\t\turl : url,\t\t\tdata : param,\t\t\ttype : method || &quot;get&quot;,\t\t\tasync : async,\t\t\tsuccess : function(data) &#123;\t\t\t\tif (data.status == 1) &#123;\t\t\t\t\tsuccess &amp;&amp; success(data.data);\t\t\t\t\treturn ;\t\t\t\t&#125;\t\t\t\tif (data.message) &#123;\t\t\t\t\t_this.tipBox(data.message);\t\t\t\t&#125; else &#123;\t\t\t\t\t_this.tipBox(i18n[&#x27;systemErr&#x27;]);\t\t\t\t&#125;\t\t\t&#125;,\t\t\terror : function(data) &#123;\t\t\t\t_this.tipBox(i18n[&#x27;systemErr&#x27;]);\t\t\t&#125;\t\t&#125;);\t&#125;,\t// 对象深拷贝\tclone : function(data)&#123; \t\tif (data == null) return null;\t\tvar newData = null, _this = this;\t\tif (typeof data == &#x27;object&#x27;) &#123;\t\t\tif (data.length != undefined) &#123;\t\t\t\tnewData = [];\t\t\t\t$.each(data, function(i, value) &#123;\t\t\t\t\tnewData.push(_this.clone(value));\t\t\t\t&#125;);\t\t\t&#125; else &#123;\t\t\t\tnewData = &#123;&#125;;\t\t\t\t$.each(data, function(key, value) &#123;\t\t\t\t\tnewData[key] = _this.clone(value);\t\t\t\t&#125;);\t\t\t&#125;\t\t&#125; else &#123;\t\t\tnewData = data;\t\t&#125;\t\treturn newData;\t&#125;,\t// map转list\tmapTranList: function(mapTemp) &#123;\t\tvar listTemp = [];\t\tfor(var key in mapTemp)&#123;\t\t\tlistTemp.push(mapTemp[key]);\t\t&#125;\t\treturn listTemp;\t&#125;,\t// jq 文件上传封装, verificationImageFileMap: 文件校验map, 重复文件不再上传\tuploadFile: function(event, uploadFileUrl, verificationImageFileMap) &#123;\t\tvar response = &#123;\t\t\t&#x27;successFiles&#x27; : [],\t\t\t&#x27;errorFiles&#x27;: []\t\t&#125;;\t\tvar tempFileName = &#x27;&#x27;;\t\tfor (var i = 0; i &lt; event.target.files.length; i++) &#123;\t\t\tvar formData = new FormData();\t\t\tvar file = event.target.files[i];\t\t\ttempFileName = file.name;\t\t\tvar fileKey = tempFileName + file.size;\t\t\tif (this.isEmpty(verificationImageFileMap) || this.isEmpty(verificationImageFileMap[fileKey])) &#123;\t\t\t\tformData.append(&#x27;file&#x27;, file);\t\t\t\tformData.append(&quot;name&quot;, tempFileName);\t\t\t\t$.ajax(&#123;\t\t\t\t\turl : uploadFileUrl,\t\t\t\t\ttype : &#x27;POST&#x27;,\t\t\t\t\tdata : formData,\t\t\t\t\t// 告诉jQuery不要去处理发送的数据\t\t\t\t\tprocessData : false,\t\t\t\t\t// 告诉jQuery不要去设置Content-Type请求头\t\t\t\t\tcontentType : false,\t\t\t\t\tasync: false,\t\t\t\t\tbeforeSend:function()&#123;\t\t\t\t\t&#125;,\t\t\t\t\tsuccess : function(responseStr) &#123;\t\t\t\t\t\tresponse.successFiles.push(responseStr);\t\t\t\t\t&#125;,\t\t\t\t\terror : function(responseStr) &#123;\t\t\t\t\t\tconsole.log(&quot;文件上传失败!&quot; + responseStr);\t\t\t\t\t\tresponse.errorFiles.push(&#123;\t\t\t\t\t\t\t&#x27;fileName&#x27;: tempFileName\t\t\t\t\t\t&#125;);\t\t\t\t\t&#125;\t\t\t\t&#125;);\t\t\t&#125;\t\t&#125;\t\te.target.value=&#x27;&#x27;;\t\treturn response;\t&#125;,\t/* layui 等待 */    showLoad: function (msg) &#123;        return layer.msg(msg, &#123;            icon: 16,            shade: [0.5, &#x27;#f5f5f5&#x27;],            scrollbar: false,            offset: &#x27;auto&#x27;,            time: 100000        &#125;);    &#125;,    closeLoad: function (index) &#123;        layer.close(index);    &#125;,    showSuccess: function (msg) &#123;        layer.msg(msg, &#123;time: 1500, offset: &#x27;auto&#x27;, icon: 1&#125;);    &#125;,    showFail: function (msg) &#123;        layer.msg(msg, &#123;time: 1500, offset: &#x27;auto&#x27;, icon: 2&#125;);    &#125;,    closeLayer : function() &#123;        if (!!this.layerWindow) &#123;            layer.close(this.layerWindow);        &#125; else &#123;\t\t\tvar index= window.parent.layer.getFrameIndex(window.name)\t\t\twindow.parent.layer.close(index);\t\t&#125;    &#125;,    // 页面间传递数据 parent.postMessage(data);\tonMessage : function(callback) &#123; //监听发送到本窗口的消息\t\tif (window.addEventListener)&#123;\t\t\twindow.addEventListener(&#x27;message&#x27;,function(event)&#123;\t\t\t\tcallback &amp;&amp; callback(event);\t\t\t&#125;, false);\t\t&#125; else if(window.attachEvent) &#123;\t\t\twindow.attachEvent(&quot;onmessage&quot;, function (event) &#123;\t\t\t\tcallback &amp;&amp; callback(event);\t\t\t&#125;);\t\t&#125;\t&#125;,\t// 字符串处理\tfilterString: function(content, type) &#123;    \tvar _this = this;    \t// 过滤中文    \tif (type === 1) &#123;\t\t\treturn content.replace(/[\\u4e00-\\u9fa5]/g,&#x27;&#x27;)\t\t&#125; else if (type === 2) &#123; // 数字转中文    \t\tif (isNaN(Number(node.points))) &#123;    \t\t\treturn;\t\t\t&#125;\t\t\treturn _this.numberToChinese(content);\t\t&#125;\t&#125;,\t// 数字转中文    numberToChinese : function(number) &#123;        if (isNaN(Number(number))) &#123;\t\t\tconsole.error(&quot;this is not number!&quot;);\t\t\treturn number;\t\t&#125;        var chnNumChar = [&quot;零&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;七&quot;,&quot;八&quot;,&quot;九&quot;];        var chnUnitChar = [&quot;&quot;,&quot;十&quot;,&quot;百&quot;,&quot;千&quot;,&quot;万&quot;,&quot;亿&quot;,&quot;万亿&quot;,&quot;亿亿&quot;];        var strIns = &#x27;&#x27;, chnStr = &#x27;&#x27;;        var unitPos = 0;        var zero = true;        while(number &gt; 0)&#123;            var v = number % 10;            if(v === 0)&#123;                if(!zero)&#123;                    zero = true;                    chnStr = chnNumChar[v] + chnStr;                &#125;            &#125;else&#123;                zero = false;                strIns = chnNumChar[v];                // 10-19不要前缀                if (unitPos === 1 &amp;&amp; v === 1) &#123;                    strIns = chnUnitChar[unitPos];                &#125; else &#123;                    strIns += chnUnitChar[unitPos]                &#125;                chnStr = strIns + chnStr;            &#125;            unitPos++;            number = Math.floor(number / 10);        &#125;    \treturn chnStr;\t&#125;,\t// 修改编辑字符后光标移动至末尾\tmoveCursorEnd : function(obj) &#123;\t\tobj.focus(); //解决ff不获取焦点无法定位问题\t\tvar range = window.getSelection();//创建range\t\trange.selectAllChildren(obj);//range 选择obj下所有子内容\t\trange.collapseToEnd();//光标移至最后\t&#125;&#125;;// web localStorage 存储工具类var StorageOperation = CommUtils.StorageOp = &#123;\tget : function (key) &#123;\t\tif (window.localStorage) &#123;\t\t\tvar prefix = this.getPrefix();\t\t\tvar item = window.localStorage.getItem(prefix + key);\t\t\tif (item == undefined || item == undefined || item.trim() == &#x27;&#x27;) &#123;\t\t\t\treturn null;\t\t\t&#125;\t\t\titem = JSON.parse(item);\t\t\tif (item.end &lt; new Date().getMilliseconds()) &#123;\t\t\t\twindow.localStorage.removeItem(prefix + key);\t\t\t\treturn null;\t\t\t&#125;\t\t\treturn item.data;\t\t&#125;\t&#125;,\tset : function(key, value, timeoutMills) &#123;\t\tif (CommUtils.isEmpty(timeoutMills)) &#123;\t\t\ttimeoutMills = 604800000;\t\t&#125;\t\tif (window.localStorage) &#123;\t\t\tvar prefix = this.getPrefix();\t\t\tvar data = &#123;\t\t\t\t&#x27;end&#x27; : new Date().getMilliseconds() + timeoutMills,\t\t\t\t&#x27;data&#x27; : value\t\t\t&#125;\t\t\twindow.localStorage.setItem(prefix + key, JSON.stringify(data));\t\t&#125;\t&#125;,\tgetPrefix : function() &#123;\t\treturn &#x27;timeout_storage_&#x27;;\t&#125;&#125;","slug":"JS 工具集","date":"2019-08-08T05:47:41.000Z","categories_index":"JS","tags_index":"JS,工具","author_index":"Weiba"},{"id":"473446b30e00b79edab02d113b4cd921","title":"Thymeleaf - 注入自定义变量解决国际化及静态文件缓存问题(添加版本号)","content":"后端spring boot 添加配置: \n123456# 国际化i18n:  locale: zh_TW# 静态资源版本build:  version: 010-0.0.2 #项目版本-静态资源版本\n启动类中使用增强器为每个Controller注入变量\n123456789101112131415161718@Value(&quot;$&#123;i18n.locale&#125;&quot;)protected String locale;@ControllerAdvicepublic static class GlobalVariableController &#123;    @Value(&quot;$&#123;build.version:0.0.1&#125;&quot;)    private String buildVersion;    public GlobalVariableController() &#123;    &#125;    @ModelAttribute    public void getLocale(Model model) &#123;        Locale _locale = ((LocaleResolver)SpringBeanUtils.getBean(LocaleResolver.class)).resolveLocale((HttpServletRequest)null);        model.addAttribute(&quot;_locale&quot;, _locale.toString());        model.addAttribute(&quot;_v&quot;, this.buildVersion);    &#125;&#125;\n\n前端thymeleaf: \n123&lt;script th:src=&quot;@&#123;/js/jQuery/jquery-3.0.0.min.js(v=$&#123;_v&#125;)&#125;&quot;&gt;&lt;/script&gt;&lt;!-- 加载国际化js静态文件 --&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;|/js/publicFile_$&#123;_locale&#125;.js|(v=$&#123;_v&#125;)&#125;&quot;&gt;&lt;/script&gt;","slug":"Thymeleaf - 注入自定义变量解决国际化及静态文件缓存问题","date":"2019-08-08T04:55:49.000Z","categories_index":"Thymeleaf","tags_index":"Thymeleaf,国际化,web缓存","author_index":"Weiba"},{"id":"84714c780858e0d1bf03e058f223b43c","title":"Thymeleaf VUE 混用奇葩语法","content":"th中使用vue变量\n123456&lt;span th:text=&quot;&#x27;&#123;&#123;questionResourceType.count&#125;&#125;&#x27; + #&#123;UI_38_02_016&#125;&quot;&gt;2653道题&lt;/span&gt;&lt;!-- vue th变量混输--&gt;&lt;span class=&quot;lt_1&quot; th:utext=&quot;$&#123;#messages.msg(&#x27;UI_38_06_023&#x27;, &#x27;&amp;lt;em&amp;gt;&#123;&#123;questionCount&#125;&#125;&amp;lt;/em&amp;gt;&#x27;)&#125; + &#x27;&amp;lt;em&amp;gt;&#123;&#123;paper.totalPoints&#125;&#125;&amp;lt;/em&amp;gt;&#x27; + #&#123;UI_38_01_025&#125;&quot;&gt;共20道题 20分&lt;/span&gt;&lt;!-- 渲染后--&gt;&lt;span class=&quot;lt_1&quot;&gt;共&lt;em&gt;20&lt;/em&gt;道題&lt;em&gt;20&lt;/em&gt;分&lt;/span&gt;\n\n\n\n常用语法判断条件123456gt：great than（大于）&gt;ge：great equal（大于等于）&gt;=eq：equal（等于）==lt：less than（小于）&lt;le：less equal（小于等于）&lt;=ne：not equal（不等于）!=","slug":"Thymeleaf VUE 混用奇葩语法","date":"2019-08-08T04:54:19.000Z","categories_index":"Thymeleaf","tags_index":"Thymeleaf,VUE","author_index":"Weiba"},{"id":"e540997bda9599822ca628bcc4397326","title":"cmake 升级到cmake-3.9.2版本","content":"一. 查看当前版本\ncmake -version 12[root@host ~]# cmake -versioncmake version 2.8.12.2\n\n二. 安装新版本cmake1. 在官网下载需要的新版本cmake源码\nftp地址: https://cmake.org/files/\n3.9.2 地址: https://cmake.org/files/v3.9/cmake-3.9.2.tar.gz\n\n2. 下载编译\n下载解压 12wget https://cmake.org/files/v3.9/cmake-3.9.2.tar.gztar -xvf cmake-3.9.2.tar.gz\n编译, 花了我二十分钟左右.. 123cd cmake-3.9.2./configuresudo make &amp;&amp; make install\n\n3. 注意事项\n安装完后，执行cmake --version会报如下错误 123456[root@host cmake-3.9.2]# cmake -versionCMake Error: Could not find CMAKE_ROOT !!!CMake has most likely not been installed correctly.Modules directory not found in/usr/local/binSegmentation fault\n\n\n解决方法, 暂时不知道啥意思.. 像是是执行了一下cmake下的hash命令, 刷新了cmake的环境变量  12345[root@host cmake-3.9.2]# hash -r[root@host cmake-3.9.2]# cmake --versioncmake version 3.9.2CMake suite maintained and supported by Kitware (kitware.com/cmake).\n\n","slug":"cmake 升级到cmake-3.9.2版本","date":"2019-07-29T05:24:48.000Z","categories_index":"cmake","tags_index":"升级,cmake","author_index":"Weiba"},{"id":"09f59e5fce202be3798507faef5e8740","title":"L2TP 一键安装","content":"使用他的一键脚本 https://teddysun.com/448.html/comment-page-6#comments\n如果你要想对用户进行操作，可以使用如下命令：\n12345l2tp -a 新增用户l2tp -d 删除用户l2tp -m 修改现有的用户的密码l2tp -l 列出所有用户名和密码l2tp -h 列出帮助信息\n\n其他事项：\n1231、脚本在安装完成后，已自动启动进程，并加入了开机自启动。2、脚本会改写 iptables 或 firewalld 的规则。3、脚本安装时，会即时将安装日志写到 /root/l2tp.log 文件里，如果你安装失败，可以通过此文件来寻找错误信息。\n\n使用命令：\n12345678ipsec status （查看 IPSec 运行状态）ipsec verify （查看 IPSec 检查结果）/etc/init.d/ipsec start|stop|restart|status （CentOS6 下使用）/etc/init.d/xl2tpd start|stop|restart （CentOS6 下使用）systemctl start|stop|restart|status ipsec （CentOS7 下使用）systemctl start|stop|restart xl2tpd （CentOS7 下使用）service ipsec start|stop|restart|status （Debian/Ubuntu 下使用）service xl2tpd start|stop|restart （Debian/Ubuntu 下使用）\n\nL2TP debug 模式: \n12先关闭 L2TP : systemctl stop xl2tpd已Debug模式启动 : /usr/sbin/xl2tpd -D\n\n\n一键脚本\n123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/across/master/l2tp.shchmod +x l2tp.sh./l2tp.sh\n\noptions.xl2tpd 配置\n12345678910111213141516171819202122[root@host xl2tpd]# cat /etc/ppp/options.xl2tpd ipcp-accept-localipcp-accept-remoterequire-mschap-v2ms-dns 8.8.8.8ms-dns 8.8.4.4noccpauthhide-passwordidle 1800mtu 1410mru 1410nodefaultroutedebugproxyarpconnect-delay 5000#防止两分钟掉线lcp-echo-interval 0lcp-echo-failure 0[root@host xl2tpd]# \n\n/etc/ipsec.conf 配置\n123456789101112131415161718192021222324252627282930313233343536[root@host xl2tpd]# cat /etc/ipsec.confversion 2.0config setup    protostack=netkey    nhelpers=0    uniqueids=no    interfaces=%defaultroute    virtual_private=%v4:10.0.0.0/8,%v4:192.168.0.0/16,%v4:172.16.0.0/12,%v4:!192.168.18.0/24conn l2tp-psk    rightsubnet=vhost:%priv    also=l2tp-psk-nonatconn l2tp-psk-nonat    authby=secret    pfs=no    auto=add    keyingtries=3    rekey=no    ikelifetime=8h    keylife=1h    type=transport    left=%defaultroute    leftid=93.179.100.194    leftnexthop=%defaultroute    leftprotoport=17/1701    right=%any    rightprotoport=17/%any    dpddelay=40    dpdtimeout=130    dpdaction=clear    sha2-truncbug=yes    rightnexthop=%defaultroute    forceencaps=yes[root@host xl2tpd]# ","slug":"L2TP 一键安装","date":"2019-07-26T05:32:05.000Z","categories_index":"L2TP","tags_index":"L2TP","author_index":"Weiba"},{"id":"36fe1cc5933b149cb221b036d350eb16","title":"firewall 防火墙常用命令","content":"安装 firewalldyum install firewalld firewall-config\n你也可以关闭目前还不熟悉的FirewallD防火墙，而使用iptables，命令如下：12345systemctl stop firewalldsystemctl disable firewalldyum install iptables-servicessystemctl start iptablessystemctl enable iptables\n常用命令\n启动 systemctl start  firewalld\n禁用 systemctl stop firewalld\n开机启动 systemctl enable firewalld\n关闭开机自启 systemctl disable firewalld\n状态 systemctl status firewalld | systemctl status firewalld.service | firewall-cmd --state\n查看版本 firewall-cmd --version\n查看公开域开放端口 firewall-cmd --zone=public --list-ports\n查看公开域开放的服务 firewall-cmd --zone=public --list-service\n添加端口, 添加后需要重载firewall才会生效, --perament 设置为永久生效firewall-cmd --zone=public --add-port=9080/tcp --permanent\n删除端口 firewall-cmd --zone=public --remove-port=9080/tcp --permanent\n重新载入 firewall-cmd --reload\n查看指定端口 firewall-cmd --zone=public --query-port=9080/tcp\n查看当前允许的端口及服务 firewall-cmd --list-all\n\n服务相关\n查看所有服务 firewall-cmd --get-service\n允许服务 firewall-cmd --add-service=mysql --permanent\n\n","slug":"firewall 防火墙常用命令","date":"2019-07-26T05:29:59.000Z","categories_index":"firewall","tags_index":"常用命令,firewall","author_index":"Weiba"},{"id":"f5262033f512fa97b6db8c912ead2732","title":"iptables 常用操作","content":"添加端口123iptables -A INPUT -p tcp --dport 9115 -j ACCEPTiptables -A OUTPUT -p tcp --sport 9115 -j ACCEPTservice iptables save\n\n添加到指定位置123456# 查看所有行iptables -L -n --line-number # 插入到第三行iptables -I INPUT 4 -p tcp -m tcp --dport 9115 -j ACCEPT iptables -I OUTPUT 1 -p tcp --sport 9115 -j ACCEPTservice iptables save\n\n\n删除规则1234iptables -D INPUT -p tcp --dport 9115 -j ACCEPTiptables -D OUTPUT -p tcp --sport 9115 -j ACCEPTservice iptables save","slug":"iptables 常用操作","date":"2019-07-26T05:29:10.000Z","categories_index":"iptables","tags_index":"常用命令,iptables","author_index":"Weiba"},{"id":"c55adf8f2f7ba25675bdc074d37b636d","title":"Thymeleaf + Vue 踩坑日记","content":"接收后端传过来的值: \n1234567891011121314// 类型切换var opTypes = new Vue(&#123;    el: &#x27;#select_type_area&#x27;,    data: &#123;        // JSON.parse() 转换一下        types: JSON.parse([[$&#123;contentTypes&#125;]]),        activeType: &#x27;&#x27;    &#125;,    methods: &#123;        selected: function(type) &#123;            this.activeType = type        &#125;    &#125;&#125;);\n\nThymeleaf 不支持 Vue 简写语法, 因为他默认使用的HTML严格检查, 下面的缩写都会报错: \n1234567891011121314&lt;!-- 缩写 --&gt;  &lt;div id=&quot;app-11&quot;&gt;    &lt;!-- 完整语法 --&gt;    &lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;    &lt;!-- 缩写 --&gt;    &lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;    &lt;!-- 完整语法 --&gt;    &lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;    &lt;!-- 缩写 --&gt;    &lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;  &lt;/div&gt;\n\n取消严格检查:\n123456&lt;!-- thymeleaf模板对html5标签不使严格检查 --&gt;&lt;dependency&gt;\t&lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;\t&lt;artifactId&gt;nekohtml&lt;/artifactId&gt;\t&lt;version&gt;1.9.22&lt;/version&gt;&lt;/dependency&gt;\n添加配置: \n1234#默认严格检查#spring.thymeleaf.mode=HTML5#非严格检查spring.thymeleaf.mode=LEGACYHTML5\n\nVue v-for 使用时必须符合语义,\n1234567891011121314&lt;!-- 此写法, todo.contentName 不会被解析--&gt;&lt;table class=&quot;table01&quot; id=&quot;tableList&quot;&gt;\t&lt;tr v-for=&quot;todo in todos&quot;&gt;&#123;&#123; todo.contentName &#125;&#125;&lt;/tr&gt;&lt;/table&gt;&lt;!-- 正确写法, 加上td标签--&gt;&lt;table class=&quot;table01&quot; id=&quot;tableList&quot;&gt;\t&lt;tr v-for=&quot;todo in todos&quot;&gt;&lt;td&gt;&#123;&#123; todo.contentName &#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;!-- 兼容合法 --&gt;&lt;table class=&quot;table01&quot; id=&quot;tableList&quot;&gt;\t&lt;tbody is=&quot;button-counter&quot; v-for=&quot;item in todos&quot; v-bind:todo=&quot;item&quot; v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/tbody&gt;&lt;/table&gt;","slug":"Thymeleaf + Vue 踩坑日记","date":"2019-07-25T05:48:43.000Z","categories_index":"Thymeleaf","tags_index":"Thymeleaf,Vue","author_index":"Weiba"},{"id":"64bee59488fa8f8fe8a78dfe76c62f5e","title":"Vue 初始化时隐藏{{xxx}} 框","content":"添加样式:\n123[v-cloak] &#123;    display: none!important;&#125;\n\n在标签上加上 v-cloak \n1&lt;div class=&quot;topic-page&quot; id=&quot;paper_list&quot; v-cloak=&quot;&quot;&gt;","slug":"Vue 初始化时隐藏{{xxx}} 框","date":"2019-07-23T05:49:20.000Z","categories_index":"Vue","tags_index":"经验,Vue","author_index":"Weiba"},{"id":"f3945c47ed9bacce2551eb9a5718948e","title":"Java 命令行相关命令","content":"\n启动时给其设置环境变量. java -Djava.rmi.server.hostname=45.76.214.173 -jar SSM_WEB_SERVER-1.0-SNAPSHOT.jar \njdk自带的几个小工具的使用:  jmap,jstack,jstat,jconsole,jvisualvm\n\n\njmap查看内存情况；\njstack查看线程的堆栈情况；\njstat查看gc的情况；\njconsole，jvisualvm综合查看内存，cpu,线程，类的信息；\n\n\n守护进程运行:123nohup java -jar ~/web/academy-tails.jar &gt;/var/log/academy-tails.log 2&gt;&amp;1 &amp;# 或者java -jar JrebelLicenseServer.jar -p 12820 &amp;\n\n更新JAR包中的依赖\n\n\n\n\n\n\n\n\n参考资料: 使用命令动态更新JAR包中的文件\n\n创建要更新的jar包目录: \n\n使用不压缩命令替换文件内容:\n1jar -uvf0 content-microservice.jar BOOT-INF\\lib\\content-framework-0.0.1.jar\n\n开启远程服务器jstatd1/home/icampus3.0/jdk8/bin/jstatd -J-Djava.rmi.server.hostname=192.168.116.190  -J-Djava.security.policy=/home/icampus3.0/jdk8/bin/jstatd.all.policy -p 2099\n\njstatd.all.policy 内容\n12345grant codebase &quot;file:$&#123;java.home&#125;/../lib/tools.jar&quot; &#123;   permission java.security.AllPermission;&#125;;","slug":"Java 命令行相关命令","date":"2019-07-22T04:18:59.000Z","categories_index":"Java","tags_index":"cmd,Java","author_index":"Weiba"},{"id":"dcb51bfbced27e98f05ddd8da866c4f9","title":"SpringCloud Zuul 连接超时","content":"错误异常:\n1&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;com.netflix.zuul.exception.ZuulException&quot;,&quot;message&quot;:&quot;GENERAL&quot;\n\nzuul 服务添加配置: \n123456789101112131415161718# 负载均衡配置ribbon:  # 25 秒超时  ReadTimeout: 25000  ConnectTimeout: 6000  MaxAutoRetries: 0  MaxAutoRetriesNextServer: 1  eureka:    enabled: true# 熔断器配置hystrix:  command:    default:      execution:        isolation:          thread:            timeoutInMilliseconds: 60000","slug":"Spring Cloud Zuul 连接超时","date":"2019-07-12T04:41:55.000Z","categories_index":"SpringCloud","tags_index":"SpringCloud,Zuul","author_index":"Weiba"},{"id":"785defa2f7a5facf91a39c104f1b5364","title":"HTML 转 PDF 工具 wkhtmltopdf","content":"使用方法HTML转换pdfwkhtmltopdf --window-status completed  --debug-javascript &quot;http://localhost:9137/manager/assessment/report/v2/class?testId=791078347730882560&amp;classId=hpjrblnxkdv2qx9u941qfm3vwplpmhpr&amp;printPdf=true&quot; -\n\nwindow-status completed: 读取网页参数, 当页面 window.status =  &quot;completed&quot; 时, 才算页面渲染完成, 解决异步js页面无法正常渲染的问题.\ndebug-javascript: 开启js debug\n\n特定页面样式\nchart 图表必须设置高宽, 不然不显示.\n不希望被切分的div 如图表, 添加样式: page-break-inside:avoid;\n将表格分页切分页后加头  123456table tr &#123;    word-break: break-all;    page-break-before: always;    page-break-after: always;    page-break-inside: avoid;&#125;\n\n错误解决方法已知问题\nwkhtmltopdf 不支持ES6语法\n\n:47 SyntaxError: Parse error定位到页面第 47 行位置, 可能有wkhtmltopdf无法解析的属性, 如 let. \nwkhtmltopdf 转换字体导致样式异常保证环境语言字体正常\n安装字体, 设置语言:\n12yum install wqy-zenhei-fontslocalectl set-locale  LANG=zh_CN.utf8","slug":"HTML 转 PDF 工具 wkhtmltopdf","date":"2019-04-23T05:44:31.000Z","categories_index":"wkhtmltopdf","tags_index":"wkhtmltopdf,WEB,PDF","author_index":"Weiba"},{"id":"f4d9d535b95b7c98512b783e9f6ac61a","title":"Idea 初始化配置","content":"编码\nSetting-Editor-File Encodings- UTF-8\n\n自动生成注释生成类&#x2F;接口注释\nSetting-Editor-File and Code Templates-Class|Interface12345678/**** $&#123;Todo&#125;** @author wb** @create $&#123;DATE&#125;**/\n\n生成方法注释\nSetting-Editor-Live Templates12345678** * $TODO$$params$ * @return $return$ * @throws * @Date $date$ $time$ * @Author wb */\n主要是生成参数的脚本:1groovyScript(&quot;def result=&#x27;&#x27;; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&#x27; * param &#x27; + params[i] + ((i &lt; params.size() - 1) ? &#x27;\\\\r\\\\n    &#x27; : &#x27;&#x27;)&#125;; return result&quot;, methodParameters())\n\n","slug":"Idea 初始化配置","date":"2019-03-22T04:21:56.000Z","categories_index":"Idea","tags_index":"Idea,设置","author_index":"Weiba"},{"id":"40e664b7dd736f520a8b3fc9bd732751","title":"Idea Live Templates 配置","content":"自定义实时模板\n\n\n\n\n\n\n\n\nIdea 有很多如 psvm iter 的实时模板, 我们也可以自定义一些自己常用的.设置路径: Setting-Editor-Live Templates\n首先点击右边的 + 号创建一个Template Group分组, 然后再新建的分组中添加对应的实时捷模板\n自动生成方法说明注释\nAbbreviation: mdoc  设置指令, 在方法上方输入/mdoc会调用该模板, 注意不输入/无法取到参数与返回值\nTemplate Text: 模板  1234567/** * $description$ * @date $date$ $time$ * @since xxx@qq.com$params$$return$ */\n  Edit variables(编辑模板中的变量):\ndescription: 留空, 生成模板时留空的值会让你手动输入\ndate: date() \ntime: time()\nparams:  1groovyScript(&quot;if(\\&quot;$&#123;_1&#125;\\&quot;.length() == 2) &#123;return &#x27;&#x27;;&#125; else &#123;def result=&#x27;&#x27;; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList();for(i = 0; i &lt; params.size(); i++) &#123;if(i&lt;(params.size()-1))&#123;result+=&#x27; * @param &#x27; + params[i] + &#x27; : &#x27; + &#x27;\\\\n\t&#x27;&#125;else&#123;result+=&#x27; * @param &#x27; + params[i] + &#x27; : &#x27;&#125;&#125;; return result;&#125;&quot;, methodParameters()); \nreturn:   1groovyScript(&quot;def returnType = \\&quot;$&#123;_1&#125;\\&quot;; def result = &#x27; * @return &#x27; + returnType; return result;&quot;, methodReturnType());\n\n生成RequestMapping方法\nAbbreviation: mrqm  设置指令, 在代码中输入mrqm会生成生成RequestMapping方法\nTemplate Text: 模板, $END$ 设置光标最后的位置  123456/mdo$END$@RequestMapping(&quot;/$RequestMapping$&quot;)public String $method$($Params$) &#123;        return &quot;$returnObject$&quot;;&#125;\n\n生成ResponseBody方法\nAbbreviation: mrsb 设置指令, 在代码中输入mrsb会生成生成ResponseBody方法\nTemplate Text: 模板, $END$ 设置光标最后的位置  1234567/mdo$END$@RequestMapping(&quot;/$RequestMapping$&quot;)@ResponseBodypublic $returnType$ $method$($Params$) &#123;        return $returnObject$;&#125;\n\n生成私有方法\nAbbreviation: mpr 设置指令, 在代码中输入mpr会生成私有方法\nTemplate Text: 模板, $END$ 设置光标最后的位置  12345/mdo$END$private $returnType$ $method$($Params$) &#123;        return $returnObject$;&#125;\n\n生成无返回值的私有方法\nAbbreviation: mprv 设置指令, 在代码中输入mprv会生成无返回值的私有方法\nTemplate Text: 模板, $END$ 设置光标最后的位置  1234/mdo$END$private void $method$($Params$) &#123;&#125;\n\n生成公共方法\nAbbreviation: mpu 设置指令, 在代码中输入mpu会生成公共方法\nTemplate Text: 模板, $END$ 设置光标最后的位置  12345/mdo$END$public $returnType$ $method$($Params$) &#123;        return $returnObject$;&#125;\n\n生成无返回值的公共方法\nAbbreviation: mpuv 设置指令, 在代码中输入mpuv会生成无返回值的公共方法\nTemplate Text: 模板, $END$ 设置光标最后的位置  1234/mdo$END$public void $method$($Params$) &#123;    &#125;\n\n文件模板\n\n\n\n\n\n\n\n\nIdea 支持为所有文件创建&#x2F;修改模板.设置路径: Setting-Editor-File and Code Templates\n注意占位符需开启 Enable Live Templates 功能\nClass 文件模板根据文件名 VO, BO, DTO, Controller, Restful, Service 自动生成相关注解\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end#parse(&quot;File Header.java&quot;)#if ($&#123;NAME.endsWith(&quot;VO&quot;)&#125; || $&#123;NAME.endsWith(&quot;BO&quot;)&#125; || $&#123;NAME.endsWith(&quot;DTO&quot;)&#125;)import lombok.*;import lombok.experimental.Accessors;#end#if ($&#123;NAME.endsWith(&quot;VO&quot;)&#125;)import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;#end#if ($&#123;NAME.endsWith(&quot;Controller&quot;)&#125;)import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import com.enableets.edu.teachingassistant.manager.core.Constants;#end#if ($&#123;NAME.endsWith(&quot;Service&quot;)&#125;)import org.springframework.stereotype.Service;#end#if ($&#123;NAME.endsWith(&quot;Restful&quot;)&#125;)import io.swagger.annotations.Api;import org.springframework.web.bind.annotation.*;#end/**** $&#123;description&#125;** @author wb** @date $&#123;DATE&#125;**/#if ($&#123;NAME.endsWith(&quot;VO&quot;)&#125; || $&#123;NAME.endsWith(&quot;BO&quot;)&#125; || $&#123;NAME.endsWith(&quot;DTO&quot;)&#125;)@Accessors(chain = true)@AllArgsConstructor@NoArgsConstructor@Data#end#if ($&#123;NAME.endsWith(&quot;VO&quot;)&#125;)@ApiModel(value = &quot;#[[$value$]]#&quot;, description = &quot;#[[$description$]]#&quot;)#end#if ($&#123;NAME.endsWith(&quot;Controller&quot;)&#125;)@Controller@RequestMapping(value = Constants.CONTEXT_PATH + &quot;/#[[$REQUESTION$]]#&quot;)#end#if ($&#123;NAME.endsWith(&quot;Restful&quot;)&#125;)@Api(tags=&quot;#[[$tags$]]#&quot;, description=&quot;#[[$description$]]#&quot;)@RestController@RequestMapping(value = &quot;#[[$RequestMapping$]]#&quot;)@ResponseResult#end#if ($&#123;NAME.endsWith(&quot;Service&quot;)&#125;)@Service#endpublic class $&#123;NAME&#125; &#123;    #[[$END$]]#&#125;\n\nInterface 模板1234567891011121314151617181920212223242526272829#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end#parse(&quot;File Header.java&quot;)#if ($&#123;NAME.endsWith(&quot;DAO&quot;)&#125;)import org.springframework.stereotype.Component;import com.enableets.edu.framework.core.dao.BaseDao;#end#if ($&#123;NAME.endsWith(&quot;Client&quot;)&#125;)import org.springframework.cloud.openfeign.FeignClient;#end/**** $&#123;description&#125;** @author wb** @date $&#123;DATE&#125;**/#if ($&#123;NAME.endsWith(&quot;DAO&quot;)&#125;)@Component#end#if ($&#123;NAME.endsWith(&quot;Client&quot;)&#125;)@FeignClient(name = &quot;$&#123;#[[$microservice$]]#&#125;&quot;)#endpublic interface $&#123;NAME&#125; #if ($&#123;NAME.endsWith(&quot;DAO&quot;)&#125;)extends BaseDao&lt;#[[$DAOPO$]]#&gt; #end&#123;    #[[$END$]]#&#125;","slug":"Idea Live Templates 配置","date":"2019-03-22T04:20:03.000Z","categories_index":"Idea","tags_index":"Idea,template,设置","author_index":"Weiba"},{"id":"30d9f989f7c5ece7f14c8ad72bebe5dc","title":"Redis 常用命令","content":"Window 下安装\n下载地址：https://github.com/MSOpenTech/redis/releases\nRedis) 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。\n\n\n运行 \n开启服务器\n打开一个 cmd 窗口 使用cd命令切换目录到 C:\\redis 运行 redis-server.exe redis.windows.conf\n\n\n连接数据库\n这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了\n切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379\n\n\n\n\n\nLinux 下安装\n下载地址：http://redis.io/download，下载最新稳定版本。\n安装运行\n源码安装 1234567wegt http://download.redis.io/releases/redis-4.0.9.tar.gztar -zvxf redis-4.0.9.tar.gzcd redis/#编译make#编译完成文件生成到当前目录下的src下cd src\n启动redis\n./redis-server 注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。\n./redis-server redis.conf redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。\n\n\n运行 \n启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如： 12345./redis-cliredis&gt; set foo barOKredis&gt; get foo&quot;bar&quot;\n\n\n\n\n\nRedis 配置Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf.你可以通过 CONFIG 命令查看或设置配置项语法Redis CONFIG 命令格式如下：\n\n\n\n\n\n\n\n\nredis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME\n实例\n\n\n\n\n\n\n\n\nredis 127.0.0.1:6379&gt; CONFIG GET loglevel\n\n“loglevel”\n“notice”\n\n使用 * 号获取所有配置项：\n实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117redis 127.0.0.1:6379&gt; CONFIG GET *  1) &quot;dbfilename&quot;  2) &quot;dump.rdb&quot;  3) &quot;requirepass&quot;  4) &quot;&quot;  5) &quot;masterauth&quot;  6) &quot;&quot;  7) &quot;unixsocket&quot;  8) &quot;&quot;  9) &quot;logfile&quot; 10) &quot;&quot; 11) &quot;pidfile&quot; 12) &quot;/var/run/redis.pid&quot; 13) &quot;maxmemory&quot; 14) &quot;0&quot; 15) &quot;maxmemory-samples&quot; 16) &quot;3&quot; 17) &quot;timeout&quot; 18) &quot;0&quot; 19) &quot;tcp-keepalive&quot; 20) &quot;0&quot; 21) &quot;auto-aof-rewrite-percentage&quot; 22) &quot;100&quot; 23) &quot;auto-aof-rewrite-min-size&quot; 24) &quot;67108864&quot; 25) &quot;hash-max-ziplist-entries&quot; 26) &quot;512&quot; 27) &quot;hash-max-ziplist-value&quot; 28) &quot;64&quot; 29) &quot;list-max-ziplist-entries&quot; 30) &quot;512&quot; 31) &quot;list-max-ziplist-value&quot; 32) &quot;64&quot; 33) &quot;set-max-intset-entries&quot; 34) &quot;512&quot; 35) &quot;zset-max-ziplist-entries&quot; 36) &quot;128&quot; 37) &quot;zset-max-ziplist-value&quot; 38) &quot;64&quot; 39) &quot;hll-sparse-max-bytes&quot; 40) &quot;3000&quot; 41) &quot;lua-time-limit&quot; 42) &quot;5000&quot; 43) &quot;slowlog-log-slower-than&quot; 44) &quot;10000&quot; 45) &quot;latency-monitor-threshold&quot; 46) &quot;0&quot; 47) &quot;slowlog-max-len&quot; 48) &quot;128&quot; 49) &quot;port&quot; 50) &quot;6379&quot; 51) &quot;tcp-backlog&quot; 52) &quot;511&quot; 53) &quot;databases&quot; 54) &quot;16&quot; 55) &quot;repl-ping-slave-period&quot; 56) &quot;10&quot; 57) &quot;repl-timeout&quot; 58) &quot;60&quot; 59) &quot;repl-backlog-size&quot; 60) &quot;1048576&quot; 61) &quot;repl-backlog-ttl&quot; 62) &quot;3600&quot; 63) &quot;maxclients&quot; 64) &quot;4064&quot; 65) &quot;watchdog-period&quot; 66) &quot;0&quot; 67) &quot;slave-priority&quot; 68) &quot;100&quot; 69) &quot;min-slaves-to-write&quot; 70) &quot;0&quot; 71) &quot;min-slaves-max-lag&quot; 72) &quot;10&quot; 73) &quot;hz&quot; 74) &quot;10&quot; 75) &quot;no-appendfsync-on-rewrite&quot; 76) &quot;no&quot; 77) &quot;slave-serve-stale-data&quot; 78) &quot;yes&quot; 79) &quot;slave-read-only&quot; 80) &quot;yes&quot; 81) &quot;stop-writes-on-bgsave-error&quot; 82) &quot;yes&quot; 83) &quot;daemonize&quot; 84) &quot;no&quot; 85) &quot;rdbcompression&quot; 86) &quot;yes&quot; 87) &quot;rdbchecksum&quot; 88) &quot;yes&quot; 89) &quot;activerehashing&quot; 90) &quot;yes&quot; 91) &quot;repl-disable-tcp-nodelay&quot; 92) &quot;no&quot; 93) &quot;aof-rewrite-incremental-fsync&quot; 94) &quot;yes&quot; 95) &quot;appendonly&quot; 96) &quot;no&quot; 97) &quot;dir&quot; 98) &quot;/home/deepak/Downloads/redis-2.8.13/src&quot; 99) &quot;maxmemory-policy&quot;100) &quot;volatile-lru&quot;101) &quot;appendfsync&quot;102) &quot;everysec&quot;103) &quot;save&quot;104) &quot;3600 1 300 100 60 10000&quot;105) &quot;loglevel&quot;106) &quot;notice&quot;107) &quot;client-output-buffer-limit&quot;108) &quot;normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60&quot;109) &quot;unixsocketperm&quot;110) &quot;0&quot;111) &quot;slaveof&quot;112) &quot;&quot;113) &quot;notify-keyspace-events&quot;114) &quot;&quot;115) &quot;bind&quot;116) &quot;&quot; \n编辑配置你可以通过修改 redis.conf 文件或使用 CONFIG set 命令来修改配置。\n语法CONFIG SET 命令基本语法：\n\n\n\n\n\n\n\n\n\nredis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE\n实例123456redis 127.0.0.1:6379&gt; CONFIG SET loglevel &quot;notice&quot;OKredis 127.0.0.1:6379&gt; CONFIG GET loglevel1) &quot;loglevel&quot;2) &quot;notice&quot;\n\n参数说明redis.conf 配置项说明如下：\n\nRedis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\n\n\n\n\n\n\n\n\n\ndaemonize no\n\n当Redis以守护进程方式运行时，Redis默认会把pid写入&#x2F;var&#x2F;run&#x2F;redis.pid文件，可以通过pidfile指定\n\n\n\n\n\n\n\n\n\npidfile &#x2F;var&#x2F;run&#x2F;redis.pid\n\n指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\n\n\n\n\n\n\n\n\n\nport 6379\n\n绑定的主机地址\n\n\n\n\n\n\n\n\n\nbind 127.0.0.1\n\n当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能()\n\n\n\n\n\n\n\n\n\ntimeout 300\n\n指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n\n\n\n\n\n\n\n\n\nloglevel verbose\n\n日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给&#x2F;dev&#x2F;null\n\n\n\n\n\n\n\n\n\nlogfile stdout\n\n设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id \n\n\n\n\n\n\n\n\n\ndatabases 16\n\n指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n\n\n\n\n\n\n\n\n\nsave  Redis默认配置文件中提供了三个条件: save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。\n\n指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n\n\n\n\n\n\n\n\n\nrdbcompression yes\n\n指定本地数据库文件名，默认值为dump.rdb\n\n\n\n\n\n\n\n\n\ndbfilename dump.rdb\n\n指定本地数据库存放目录\n\n\n\n\n\n\n\n\n\ndir .&#x2F;\n\n设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n\n\n\n\n\n\n\n\n\n slaveof  \n\n当master服务设置了密码保护时，slav服务连接master的密码\n\n\n\n\n\n\n\n\n\nmasterauth \n\n设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭\n\n\n\n\n\n\n\n\n\nrequirepass foobared\n\n设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\n\n\n\n\n\n\n\n\n\nmaxclients 128\n\n指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\n\n\n\n\n\n\n\n\n\nmaxmemory \n\n指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\n\n\n\n\n\n\n\n\n\nappendonly no\n\n指定更新日志文件名，默认为appendonly.aof\n\n\n\n\n\n\n\n\n\nappendfilename appendonly.aof\n\n指定更新日志条件，共有3个可选值： \n\n\n\n\n\n\n\n\n\nno：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec\n\n指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）\n\n\n\n\n\n\n\n\n\nvm-enabled no\n\n虚拟内存文件路径，默认值为&#x2F;tmp&#x2F;redis.swap，不可多个Redis实例共享\n\n\n\n\n\n\n\n\n\nvm-swap-file &#x2F;tmp&#x2F;redis.swap\n\n将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0\n\n\n\n\n\n\n\n\n\nvm-max-memory 0\n\nRedis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值\n\n\n\n\n\n\n\n\n\nvm-page-size 32\n\n设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。\n\n\n\n\n\n\n\n\n\nvm-pages 134217728\n\n设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4\n\n\n\n\n\n\n\n\n\nvm-max-threads 4\n\n设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n\n\n\n\n\n\n\n\n\nglueoutputbuf yes\n\n指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n\n\n\n\n\n\n\n\n\nhash-max-zipmap-entries 64hash-max-zipmap-value 512\n\n指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）\n\n\n\n\n\n\n\n\n\nactiverehashing yes\n\n指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n\n\n\n\n\n\n\n\n\ninclude &#x2F;path&#x2F;to&#x2F;local.conf\n\n\n\nRedis 数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。\nString（字符串）string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个键最大能存储512MB。\n实例\n\n\n\n\n\n\n\n\nredis 127.0.0.1:6379&gt; SET name “runoob”OKredis 127.0.0.1:6379&gt; GET name“runoob”\n在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 name，对应的值为 runoob。注意：一个键最大能存储512MB。\n\nHash（哈希）Redis hash 是一个键值(key&#x3D;&gt;value)对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。\n实例\n\n\n\n\n\n\n\n\nredis&gt; HMSET myhash field1 “Hello” field2 “World”“OK”redis&gt; HGET myhash field1“Hello”redis&gt; HGET myhash field2“World”\n以上实例中 hash 数据类型存储了包含用户脚本信息的用户对象。实例中我们使用了 Redis HMSET, HGETALL 命令，user:1 为键值。每个 hash 可以存储 $&#123;2&#125;^&#123;32&#125;$-1 键值对（40多亿）。List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n实例\n\n\n\n\n\n\n\n\nredis 127.0.0.1:6379&gt; lpush runoob redis(integer) 1redis 127.0.0.1:6379&gt; lpush runoob mongodb(integer) 2redis 127.0.0.1:6379&gt; lpush runoob rabitmq(integer) 3redis 127.0.0.1:6379&gt; lrange runoob 0 101) “rabitmq”2) “mongodb”3) “redis”redis 127.0.0.1:6379&gt;\n\n列表最多可存储 $&#123;2&#125;^&#123;32&#125;$ - 1 元素 (4294967295, 每个列表可存储40多亿)。\n\n\nSet（集合）Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。\nsadd 命令添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。\n\n\n\n\n\n\n\n\n\nsadd key member\n实例\n\n\n\n\n\n\n\n\nredis 127.0.0.1:6379&gt; sadd runoob redis(integer) 1redis 127.0.0.1:6379&gt; sadd runoob mongodb(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabitmq(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabitmq(integer) 0redis 127.0.0.1:6379&gt; smembers runoob1) “redis”2) “rabitmq”3) “mongodb”  \n注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。集合中最大的成员数为 $2^&#123;32&#125;$ - 1(4294967295, 每个集合可存储40多亿个成员)。zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\nzadd 命令添加元素到集合，元素在集合中存在则更新对应score\n\n\n\n\n\n\n\n\n\nzadd key score member \n实例\n\n\n\n\n\n\n\n\nredis 127.0.0.1:6379&gt; zadd runoob 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq(integer) 0redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 10001) “mongodb”2) “rabitmq”3) “redis”\n\n命令\nping 连接到本地的 redis 服务并执行 PING 命令，该命令用于检测 redis 服务是否启动。\n\nredis-cli -h host -p port -a password 远程连接\n\n常用命令\n\nkey相关 \nDEL key : 删除key\nDUMP key : 返回序列化后的key value\nEXISTS key : 检查key是否存在\nEXPIRE key seconds : 给key设置过期时间, 单位为秒\nRERSIS key : 移除key的过期时间, key将持久保存\nRENAME key newKey : 修改key的名称\nRENAMENX key newKey : 仅当newkey不存在时,才将key改名为newkey\nTYPE key : 获取key所存储的值的类型\n\n\nString 相关\nSET key vlaue : 设定指定key的值\nGET key : 获取指定key的值\nGERTANGE key start end : 返回key中字符串的下标由start开始end结束的子字符\nGETSET key value : 设定key的新value并返回原value\nSETNX key vlaue: 只有当key不存在时才设置key的值\nSTRLEN key : 返回key所存储的字符串值的长度.\nAPPEND key value : 如果key已存在并且时一个字符串, 在原值后追加vlaue\n\n\n\n\n键(key)\n\nRedis 键命令用于管理 redis 的键。\n\nRedis 键命令的基本语法如下：\n\n\n\n\n\n\n\n\n\nredis 127.0.0.1:6379&gt; SET runoobkey redis\n\nkeys 命令\n\n\n\n\n\n\n\n\n\nDEL key : 删除keyDUMP key : 返回序列化后的key valueEXISTS key : 检测key是否存在EXPIRE key seconds : 给key设定过期时间, 单位为秒EXPIREAT key timestamp : EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)PEXPIRE key milliseconds : 设置 key 的过期时间以毫秒计PEXPIREAT key milliseconds-timestamp : 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计\n\n\n\n\n实现\n原生实现 详情连接\n\n登陆--raw: 显示中文redis-cil –raw -a password -h host -p port\n删除keydel xxx\n查看所有keykeys *;\n删除所有key.&#x2F;redis-cli -h 192.168.116.58 -p 9779 -a xxx keys “*”| xargs .&#x2F;redis-cli -h 192.168.116.58 -p 9779 -a xxx del\n查看redis内存占用,cpu等基础信息info\n删除指定testId报表缓存1/home/redis/redis-3.0.5/bin/redis-cli -h 127.0.0.1 -p 9779 -a password keys xxxx:testId:938254998368718848* | xargs /home/redis/redis-3.0.5/bin/redis-cli -h 127.0.0.1 -p 9779 -a password del\n\n清除所有数据: flushall\n遍历输出所有数据: keys * \n模糊遍历输出: keys *session*\nscan: \n12345678910111213141516KEYS命令一次性返回所有匹配的key，所以，当redis中的key非常多时，对于内存的消耗和redis服务器都是一个隐患，对于Redis 2.8以上版本给我们提供了一个更好的遍历key的命令 SCAN.SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程当SCAN命令的游标参数（即cursor）被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。看它 1)返回的游标. 127.0.0.1:6379&gt; scan 991) &quot;0&quot;2) 1) &quot;spring:session:sessions:expires:4c7067ad-7b2f-44ce-a661-44f7a78901d7&quot;127.0.0.1:6379&gt; scan 01) &quot;0&quot;2) 1) &quot;spring:session:sessions:4c7067ad-7b2f-44ce-a661-44f7a78901d7&quot;   2) &quot;spring:session:expirations:1532337660000&quot;   3) &quot;spring:session:sessions:expires:4c7067ad-7b2f-44ce-a661-44f7a78901d7&quot;\n\n\n获取key的类型: type key\n输出String key值: get key\n","slug":"Redis 常用命令","date":"2018-12-23T05:13:16.000Z","categories_index":"Redis","tags_index":"常用命令,Redis","author_index":"Weiba"},{"id":"8bb687a0cfcbb9d3221fc98ae3453fd0","title":"单台服务器开启多个tomcat容器","content":"复制一份 tomcat 作为备用容器\ncp -R tomcat/ tomcat_2\n\n设置环境变量\n编辑环境变量 vim /etc/profile, 最后一行添加:12345678910##########first tomcat###########CATALINA_BASE=/www/server/tomcatCATALINA_HOME=/www/server/tomcatTOMCAT_HOME=/www/server/tomcatexport CATALINA_BASE CATALINA_HOME TOMCAT_HOME##########second tomcat##########CATALINA_2_BASE=/www/server/tomcat_2CATALINA_2_HOME=/www/server/tomcat_2TOMCAT_2_HOME=/www/server/tomcat_2export CATALINA_2_BASE CATALINA_2_HOME TOMCAT_2_HOME\n更新环境变量 source /etc/profile\n\n配置 tomcat_2\n配置启动环境变量, 进入 tomcat_2 目录, 编辑其 bin/catalina.sh, 找到OS specific support.  $var _must_ be set to either true or false., 插入 tomcat2 的环境变量\n12345# OS specific support.  $var _must_ be set to either true or false.# 添加tomcat2 环境变量export CATALINA_BASE=$CATALINA_2_BASEexport CATALINA_HOME=$CATALINA_2_HOME...\n配置容器端口, 编辑 tomcat_2/conf/server.xml, 分别修改下列几个端口号, 与 tomcat1 的端口不同即可.\n12&lt;!-- 8005=&gt;9005 tomcat shutdown端口--&gt;&lt;Server port=&quot;9005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;\n1234&lt;!-- 8080=&gt;9080 tomcat web端口--&gt;&lt;Connector port=&quot;9080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;\n12&lt;!-- 8009=&gt;9009 AJP1.3端口 --&gt;&lt;Connector port=&quot;9009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;\n\n防火墙放通端口 8080 9080\n\n\n\nfirewall-cmd --zone=public --add-port=8080/tcp --permanent\nfirewall-cmd --zone=public --add-port=9080/tcp --permanent\nfirewall-cmd --reload\n\n\n启动容器\n\n\n分别运行对应目录启动脚本 bin/startup.sh\n\n\n通过服务器ip:端口号测试\n\n","slug":"单台服务器开启多个tomcat容器","date":"2018-09-23T05:23:54.000Z","categories_index":"Tomcat","tags_index":"Shell,Tomcat","author_index":"Weiba"},{"id":"ea02254a039ac79c314d2c9af30af5fa","title":"Memcached","content":"安装准备\nLinux系统安装memcached，首先要先安装libevent库。\n\n\nUbuntu&#x2F;Debian: sudo apt-get install libevent libevent-deve\nRedhat&#x2F;Fedora&#x2F;Centos yum install -y libevent libevent-deve\n\n安装\n仓库安装\n\n\nUbuntu&#x2F;Debian: sudo apt-get install memcached\nRedhat&#x2F;Fedora&#x2F;Centos: yum install -y memcached\n\n\n源码安装\n\n\n从其官方网站（http://memcached.org）下载memcached最新版本并编译.123456wget http://memcached.org/latest                    下载最新版本 tar -zxvf memcached-1.x.x.tar.gz                    解压源码cd memcached-1.x.x                                  进入目录./configure --prefix=/usr/local/memcached           配置make &amp;&amp; make test                                   编译sudo make install                                   安装\n\n运行\n仓库安装\n\n\n前台显示运行: memcached -p 11211 -m 64m -vv -u root\n后端守护进程运行: memcached -p 11211 -m 64m -u root -P /tmp/memcached.pid -d\n\n\n源码安装\n\n\n前端显示运行: /usr/local/memcached/bin/memcached -p 11211 -m 64m -vv\n后端守护进程运行: /usr/local/memcached/bin/memcached -p 11211 -m 64m -u root -P /tmp/memcached.pid -d\n\n\n启动选项详情:\n\n\n-h 命令帮助\n-d是启动一个守护进程；\n-m是分配给Memcache使用的内存数量，单位是MB;\n-u是运行Memcache的用户；\n-l是监听的服务器IP地址，可以有多个地址；\n-p是设置Memcache监听的端口，，最好是1024以上的端口；\n-c是最大运行的并发连接数，默认是1024；\n-P是设置保存Memcache的pid文件.\n-vv是显示详情\n\n常用命令\n连接\n\n\ntelnet HOST PORT\n\n\nMemcached 存储命令\n\n\nset 命令用于将 value(数据值) 存储在指定的 key(键) 中\n\n\n\n\n\n\n\n\n\nset key flags exptime bytes [noreply] ]\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\ntxt参数说明: \n- key：键值 key-value 结构中的 key，用于查找缓存值。\n- flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。\n- exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）\n- bytes：在缓存中存储的字节数\n- noreply（可选）： 该参数告知服务器不需要返回数据\n- value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）","slug":"Memcached","date":"2018-08-14T05:35:23.000Z","categories_index":"Memcached","tags_index":"Memcached","author_index":"Weiba"},{"id":"7625e53cbd55975ec0a2b49c3c2bb1f3","title":"Sping @RestController 返回Json格式数据时不序列化null属性","content":"直接看代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * @program: canary * @description: spring 内置的json处理框架是Jackson。我们可以对它配置达到不返回Null属性的json数据 * @author: wb * @create: 2018-07-26 17:39 **/@Configurationpublic class JacksonConfig&#123;    @Bean    @Primary    @ConditionalOnMissingBean(ObjectMapper.class)    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder)    &#123;        ObjectMapper objectMapper = builder.createXmlMapper(false).build();        // 通过该方法对mapper对象进行设置，所有序列化的对象都将按改规则进行系列化        // Include.Include.ALWAYS 默认        // Include.NON_DEFAULT 属性为默认值不序列化        // Include.NON_EMPTY 属性为 空（&quot;&quot;） 或者为 NULL 都不序列化，则返回的json是没有这个字段的。这样对移动端会更省流量        // Include.NON_NULL 属性为NULL 不序列化,就是为null的字段不参加序列化        //objectMapper.setSerializationInclusion(Include.NON_EMPTY);        /* 为空的不参加序列化 */        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);        // 字段保留，将null值转为&quot;&quot;        /*objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;()        &#123;            @Override            public void serialize(Object o, JsonGenerator jsonGenerator,                                  SerializerProvider serializerProvider)                    throws IOException, JsonProcessingException            &#123;                jsonGenerator.writeString(&quot;&quot;);            &#125;        &#125;);*/        return objectMapper;    &#125;&#125;","slug":"Sping @RestController 返回Json格式数据时不序列化null属性","date":"2018-07-26T09:39:57.000Z","categories_index":"Spring","tags_index":"Spring,Json序列化","author_index":"Weiba"},{"id":"5a722539163216f9e12fecfef2d10901","title":"通过 Memcached 解决多台tomcat session同步问题","content":"准备工作\nNginx 负载均衡已配置\nTomcat 已开启多个容器\nTomcat 8\n官方文档: https://github.com/magro/memcached-session-manager/wiki/SetupAndConfiguration\n参考资料: https://www.cnblogs.com/jsonhc/p/7344902.html\n\n\n下载所需jar包, 每个tomcat版本对应的包不同\nwget http://repo1.maven.org/maven2/de/javakaffee/msm/memcached-session-manager/2.1.1/memcached-session-manager-2.1.1.jar\nwget http://repo1.maven.org/maven2/de/javakaffee/msm/memcached-session-manager-tc8/2.1.1/memcached-session-manager-tc8-2.1.1.jar\nwget http://repo1.maven.org/maven2/net/spy/spymemcached/2.11.1/spymemcached-2.11.1.jar\n如果仅仅只是用java来做序列化器只需上面这三个包就ok\n下面两个包,配置后一直报错,未测试通过 \nwget http://repo1.maven.org/maven2/de/javakaffee/msm/msm-javolution-serializer/1.8.3/msm-javolution-serializer-1.8.3.jar\nwget http://repo1.maven.org/maven2/de/javakaffee/msm/msm-javolution-serializer/2.1.1/msm-javolution-serializer-2.1.1.jar\n下载完成后放入tomcat&#x2F;lib目录中\n\n修改两个tomcat配置文件\nvim &#123;tomcat&#125;/conf/context.xml\n  123456789101112131415&lt;Context&gt;    &lt;!-- web application will be reloaded.                                   --&gt;    &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt;    &lt;WatchedResource&gt;$&#123;catalina.base&#125;/conf/web.xml&lt;/WatchedResource&gt;    &lt;!-- Uncomment this to disable session persistence across Tomcat restarts --&gt;    &lt;!--    &lt;Manager pathname=&quot;&quot; /&gt;    --&gt;    &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;    memcachedNodes=&quot;n1:127.0.0.1:11211,n2:127.0.0.1:22122&quot;    failoverNodes=&quot;n1&quot;    requestUriIgnorePattern=&quot;.*\\.(ico|png|gif|jpg|css|js)$&quot;    /&gt;&lt;/Context&gt;\n\n","slug":"通过 Memcached 解决多台tomcat session同步问题","date":"2018-07-26T05:34:36.000Z","categories_index":"Memcached","tags_index":"session,tomcat","author_index":"Weiba"},{"id":"6aa8ceb80f4b9b7def699e1275eccff9","title":"Java 服务中文乱码","content":"\n\n\n\n\n\n\n\n\n最近发现运维大哥在新环境部署相关服务后生成的数据出现中文乱码的问题, 记录一下\n修改系统编码环境变量locale 查看当前系统编码:\n这是修改后正常状态, 如不是需修改 cat /etc/sysconfig/i18n 文件, 修改为:\n1LANG=&quot;zh_CN.UTF-8&quot;\n即可, 这是 centOS6.*, 其他发行版可能是别的文件.\n改完后刷新环境变重启服务即可生效\n1source /etc/sysconfig/i18n\n\nCentOS 7.91234vim /etc/profile# 最后一行添加export LC_ALL=&quot;zh_CN.UTF-8&quot;\n\nJava 服务启动12# 原来只有-Dfile.encoding=UTF-8， 加上后面的只要有中文环境，都没问题option=&quot;-server -Xms200m -Xmx350m -jar $&#123;servFile&#125; -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Duser.language=zh -Duser.country=CN -Dspring.config.location=bootstrap.yml&quot;","slug":"Java 服务中文乱码","date":"2018-07-26T04:58:33.000Z","categories_index":"Java","tags_index":"Java,乱码","author_index":"Weiba"},{"id":"752ca52abe96279b156b2c1db908bcf9","title":"微信公众号","content":"今天完成的事情：完成微信登陆认证流程, 通过opeonId 和 access_token 获取用户信息\n微信公众号获取用户信息1. 获取code, 必须在微信开发工具或者微信中打开才会跳转\nredirect_uri必须填写网页授权域名, 公众号设置&gt;功能设置&gt;网页授权域名https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx2750055a558bbe86&amp;redirect_uri=http://academy.home.canary.dounixue.net/&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect\n跳转后urlhttp://academy.home.canary.dounixue.net/?code=001oDwYl1bI7al0xsVXl1AqTYl1oDwYD&amp;state=STATE\n\n2. 通过code以及appid&#x2F;secret 获取 access_token\n通过code获取access_token, wx2750055a558bbe86&#x2F;fe33aae20890da44fc14c709468b7a91https://api.weixin.qq.com/sns/oauth2/access_token?appid=wx2750055a558bbe86&amp;secret=fe33aae20890da44fc14c709468b7a91&amp;code=0815xeel0JaaOl1HRxfl06bcel05xee7&amp;grant_type=authorization_code\n返回结果:1234567&#123;    &quot;access_token&quot;: &quot;12_Y7wwnaQ8VA5joJfIEcZSKtO8h5Omrvn80be6nb18jG_9Ad1YetJDEEwCLpnQqaNcq1JlUVuZoXvPsu0QPJ73TA&quot;,    &quot;expires_in&quot;: 7200,    &quot;refresh_token&quot;: &quot;12_4jUAxLbsJ-H_Tcu9A4EJr7CxNcvQZrMwbtokLVdfXUnionm9aRXdDY3fEX-ZkhfeTzQfl9rgt2kz3FbTefWV7g&quot;,    &quot;openid&quot;: &quot;oSV35t_fiRPKozt9JV4kQD-O5XMg&quot;,    &quot;scope&quot;: &quot;snsapi_userinfo&quot;&#125;\n\n3. 刷新access_token（如果需要）由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权。https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=wx2750055a558bbe86&amp;grant_type=refresh_token&amp;refresh_token=12_4jUAxLbsJ-H_Tcu9A4EJr7CxNcvQZrMwbtokLVdfXUnionm9aRXdDY3fEX-ZkhfeTzQfl9rgt2kz3FbTefWV7g\n\n返回结果:1234567&#123;    &quot;openid&quot;: &quot;oSV35t_fiRPKozt9JV4kQD-O5XMg&quot;,    &quot;access_token&quot;: &quot;12_Y7wwnaQ8VA5joJfIEcZSKtO8h5Omrvn80be6nb18jG_9Ad1YetJDEEwCLpnQqaNcq1JlUVuZoXvPsu0QPJ73TA&quot;,    &quot;expires_in&quot;: 7200,    &quot;refresh_token&quot;: &quot;12_4jUAxLbsJ-H_Tcu9A4EJr7CxNcvQZrMwbtokLVdfXUnionm9aRXdDY3fEX-ZkhfeTzQfl9rgt2kz3FbTefWV7g&quot;,    &quot;scope&quot;: &quot;snsapi_base,snsapi_userinfo,&quot;&#125;\n\n通过openid 和 access_token 获取用户基本信息https://api.weixin.qq.com/sns/userinfo?access_token=12_iMk8sNzOKW_jN6qpZrw8PwP4NKApKVaf40PojX_w7I49kqod3Eorwk0OhG-BDcow4d2a4wgtQAbcK5GDzhWd8Q&amp;lang=zh_CN\n\n返回结果:1234567891011&#123;&quot;openid&quot;: &quot;oSV35t_fiRPKozt9JV4kQD-O5XMg&quot;,&quot;nickname&quot;: &quot;.&quot;,&quot;sex&quot;: 1,&quot;language&quot;: &quot;zh_CN&quot;,&quot;city&quot;: &quot;&quot;,&quot;province&quot;: &quot;上海&quot;,&quot;country&quot;: &quot;中国&quot;,&quot;headimgurl&quot;: &quot;http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJibfyYTuSD3nIVDfhkyKHy4NdfrF5ibQDSicW4ocn3Jw8W8NkwLpcjpQWKZuV7YSMHtQGCCBOAeGXXg/132&quot;,&quot;privilege&quot;: []&#125;\n\n明天计划的事:完成微信demo, 完善方案设计https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CNhttps://api.weixin.qq.com/sns/userinfo?access_token=12_BKHVHYjgA18AawXYiPOzKwOR3ZGUBnsLmiUrPLbI9MePuPNw1b4NXSpt8qwIUTBxIiudSOjOme81qxABhXhUew&amp;openid=oSV35t_fiRPKozt9JV4kQD-O5XMg\n","slug":"微信公众号","date":"2018-07-15T05:01:28.000Z","categories_index":"微信公众号","tags_index":"微信公众号","author_index":"Weiba"},{"id":"1cb851a3d1c3d38a1164a75bed172ba4","title":"XML 转义字符","content":"xml 处理类\n在xml对象属性上添加注解: @XmlJavaTypeAdapter(CollapsedStringAdapter.class) 即可\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.enableets.edu.sdk.paper.util;import org.apache.commons.lang.StringEscapeUtils;import javax.xml.bind.annotation.adapters.XmlAdapter;/** * Html 转义字符处理, 并删除前后空格 */public class XMLUnescapeHtmlStringAdapter extends XmlAdapter&lt;String,String&gt; &#123;    /**     * Removes leading and trailing whitespaces of the string     * given as the parameter, then truncate any     * sequnce of tab, CR, LF, and SP by a single whitespace character &#x27; &#x27;.     */    public String unmarshal(String text) &#123;        if(text==null)  return null;        // be defensive        int len = text.length();        // most of the texts are already in the collapsed form.        // so look for the first whitespace in the hope that we will        // never see it.        int s=0;        while(s&lt;len) &#123;            if(isWhiteSpace(text.charAt(s)))                break;            s++;        &#125;        if(s==len)            // the input happens to be already collapsed.            return text;        // we now know that the input contains spaces.        // let&#x27;s sit down and do the collapsing normally.        StringBuilder result = new StringBuilder(len /*allocate enough size to avoid re-allocation*/ );        if(s!=0) &#123;            for( int i=0; i&lt;s; i++ )                result.append(text.charAt(i));            result.append(&#x27; &#x27;);        &#125;        boolean inStripMode = true;        for (int i = s+1; i &lt; len; i++) &#123;            char ch = text.charAt(i);            boolean b = isWhiteSpace(ch);            if (inStripMode &amp;&amp; b)                continue; // skip this character            inStripMode = b;            if (inStripMode)                result.append(&#x27; &#x27;);            else                result.append(ch);        &#125;        // remove trailing whitespaces        len = result.length();        if (len &gt; 0 &amp;&amp; result.charAt(len - 1) == &#x27; &#x27;)            result.setLength(len - 1);        // whitespaces are already collapsed,        // so all we have to do is to remove the last one character        // if it&#x27;s a whitespace.        // tran html encoding        String s1 = result.toString();        return StringEscapeUtils.unescapeHtml(s1);    &#125;    /**     * No-op.     *     * Just return the same string given as the parameter.     */    public String marshal(String s) &#123;        return s;    &#125;    /** returns true if the specified char is a white space character. */    protected static boolean isWhiteSpace(char ch) &#123;        // most of the characters are non-control characters.        // so check that first to quickly return false for most of the cases.        if( ch&gt;0x20 )   return false;        // other than we have to do four comparisons.        return ch == 0x9 || ch == 0xA || ch == 0xD || ch == 0x20;    &#125;&#125;","slug":"XML 转义字符","date":"2018-07-13T05:03:35.000Z","categories_index":"XML","tags_index":"XML,转义","author_index":"Weiba"},{"id":"9c5670394144325fc272e44ad7adacbe","title":"静态文件国际化","content":"创建静态文件publicFile_zh_CN.jspublicFile_zh_TW.js\n123456789101112131415161718192021questionTypeListDefault = [&#123;    &quot;code&quot;: &quot;01&quot;,    &quot;name&quot;: &quot;单选题&quot;,    &quot;relationCode&quot;: &quot;12&quot;&#125;, &#123;    &quot;code&quot;: &quot;02&quot;,    &quot;name&quot;: &quot;多选题&quot;,    &quot;relationCode&quot;: &quot;12&quot;&#125;, &#123;    &quot;code&quot;: &quot;03&quot;,    &quot;name&quot;: &quot;填空题&quot;,    &quot;relationCode&quot;: &quot;12&quot;&#125;, &#123;    &quot;code&quot;: &quot;04&quot;,    &quot;name&quot;: &quot;判断题&quot;,    &quot;relationCode&quot;: &quot;12&quot;&#125;,&#123;    &quot;code&quot;: &quot;05&quot;,    &quot;name&quot;: &quot;简答题&quot;,    &quot;relationCode&quot;: &quot;12&quot;&#125;];\n\n引入静态文件","slug":"静态文件国际化","date":"2018-07-13T05:03:35.000Z","categories_index":"国际化","tags_index":"国际化,静态文件","author_index":"Weiba"},{"id":"167e398dc9356c908cbd9b43da1d5230","title":"SpringBoot 整合 Dubbo","content":"今天完成的事Spring Boot 整合 Dubbo \nDubooDuboo 总结, 之前服务端一直无法找到服务提供者, 初步判断是包的兼容性问题, 每个版本示例用的都不一样, 索性换了一个完整的示例. 先运行再看, 大概理解了Dubbo的意思.\n\n服务提供者根据配置文件将要对外发布的 组件服务(跟SCA的另一种实现, 对我来说用起来比Tuscany舒服多了)的配置注册到注册中心供服务消费者使用.\n服务消费者根据配置文件在注册中心获取 服务提供者提供的服务信息(服务提供者的服务器ip地址及端口号, 服务的具体名称及包含的方法), 再去连接服务器提供者, 调用提供的远程服务(接口)\n注册中心起 配置信息存放的作用,  不做具体的数据传输.\n\n服务提供者\n\n导入依赖\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 核心模块，包括自动配置支持、日志和YAML； --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 测试模块，包括JUnit、Hamcrest、Mockito。 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Web支持 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 开发调试支持--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!-- http://blog.didispace.com/java-lombok-1/ --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.gitee.reger&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt;    &lt;version&gt;1.0.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;\n\n具体实现\n\n\n启动类 ml.xiaoweiba.ApplicationDubboServer\n123456789101112131415@SpringBootApplication@Slf4jpublic class ApplicationDubboServer &#123;    // 让 Dubbo 一直循环执行.    @Bean    public CountDownLatch closeLatch() &#123;        return new CountDownLatch(1);    &#125;    public static void main(String[] args) &#123;        SpringApplication.run(ApplicationDubboServer.class, args);        log.info(&quot;Dubbo 服务端启动&quot;);    &#125;&#125;\n\n接口 ml.xiaoweiba.service.ComputeService\n123public interface ComputeService &#123;    Integer add(int a, int b);&#125;\n实现 ml.xiaoweiba.service.impl.ComputeServiceImpl\n123456789101112131415161718import com.alibaba.dubbo.config.annotation.Service;import ml.xiaoweiba.service.ComputeService;/** * @program: demo * @description: 组件实现类 * @author: Mr.xweiba * @create: 2018-06-30 00:43 **/// 添加dubbo service注解 让dubbo扫描到@Servicepublic class ComputeServiceImpl implements ComputeService&#123;    @Override    public Integer add(int a, int b) &#123;        return a + b;    &#125;&#125;\n\n服务发布者配置, application.yml\n1234567891011121314151617# Spring-Boot 端口号 防止跟消费者冲突server:  port: 8899spring:  dubbo:    application:      name: provider  # 服务名称    base-package: ml.xiaoweiba.service  # 扫描@Service注解接口    registry:  # 注册中心配置 这里使用 zookeeper      address: 127.0.0.1      port: 2181    protocol:   # 使用协议 及 序列化方式      name: dubbo      serialization: hessian2    provider:   # 是否重连, 0 为不重连, 这里让消费者重连      retries: 0\n\n服务消费者\n\n导入依赖 (与服务提供者一致, 最好保服务消费者的Dubbo版本与服务提供者一致)\n具体实现\n\n启动类 ml.xiaoweiba.ApplicationDubbo\n12345678910111213141516171819202122232425import lombok.extern.slf4j.Slf4j;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @program: demo * @description: Dubbo 服务端启动类 * @author: Mr.xweiba * @create: 2018-06-30 00:18 **/// 通过 lombok 直接使用日志@Slf4j@SpringBootApplicationpublic class ApplicationDubbo implements CommandLineRunner &#123;    public static void main(String[] args) throws InterruptedException &#123;        SpringApplication.run(ApplicationDubbo.class, args);    &#125;    @Override    public void run(String... strings) throws Exception &#123;        log.info(&quot;服务调用者------&gt;&gt;启动完毕&quot;);    &#125;&#125;\n\n接口 ml.xiaoweiba.service.ComputeService 这里是消费者, 接口实现由服务提供者提供\n123public interface ComputeService &#123;    Integer add(int a, int b);&#125;\n\n使用服务, 这里用web测试 :\n1234567891011121314151617181920212223import com.reger.dubbo.annotation.Inject;import ml.xiaoweiba.service.ComputeService;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;/** * @program: demo * @description: Dubbo 测试控制器 * @author: Mr.xweiba * @create: 2018-06-30 16:14 **/@RestControllerpublic class DubboTest &#123;    // 使用Dubbo注解来实现远程对象注入    @Inject    private ComputeService computeService;    @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)    public String index()&#123;        return String.valueOf(computeService.add(1,3));    &#125;&#125;\n\n配置 application.yml \n12345678910111213141516171819server:  port: 8080spring:  dubbo:    application:      name: consumer    base-package: ml.xiaoweiba.service    registry:      address: 127.0.0.1      port: 2181    protocol:      name: dubbo      serialization: hessian2    consumer:      timeout: 1000      check: true      retries: 2\n\n测试\n测试类\n12345678910111213141516171819import com.reger.dubbo.annotation.Inject;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class ComputeServiceTest &#123;    @Inject    private ComputeService computeService;    @Test    public void add() &#123;        Assert.assertEquals(&quot;compute-service:add&quot;, new Integer(3), computeService.add(1, 2));    &#125;&#125;\n\nweb测试:\n\nDubbo-Admin\n官方Github地址: https://github.com/apache/incubator-dubbo\ngit下来后配置好直接生成jar包运行即可. \n配置: application.properties\n123456789101112server.port=7001spring.velocity.cache=falsespring.velocity.charset=UTF-8spring.velocity.layout-url=/templates/default.vmspring.messages.fallback-to-system-locale=falsespring.messages.basename=i18n/message# 注意 这里是设置root用户的密码spring.root.password=root# 注意 这里是设置guest用户的密码spring.guest.password=guestdubbo.registry.address=zookeeper://127.0.0.1:2181\n\n消费者和服务者启动后即可再web页面管理它:\n\n\n\n明天计划的事:spring-boot 整合 shiro\n","slug":"SpringBoot 整合 Dubbo ","date":"2018-06-30T04:49:08.000Z","categories_index":"SpringBoot","tags_index":"SpringBoot,Dubbo","author_index":"Weiba"},{"id":"46e975c07ccd0222dca386e908b54400","title":"SpringBoot Web过滤器Filter","content":"Spring Boot Web相关示例过滤器tomcat 提供的过滤器 : RemoteIpFilter.\n[Spring Boot：定制servlet filters] https://www.ktanx.com/blog/p/4237\n自定义配置 Property配置在application.properties中即可, Spring Boot默认都是读取该配置的. \n设置自定义值\n12com.neo.username=测试com.neo.age=34\n123456789@Componentpublic class User implements Serializable&#123;    private static final long serialVersionUID = 8667468581448787106L;    @Value(&quot;$&#123;com.neo.username&#125;&quot;)    private String sUsername;    @Value(&quot;$&#123;com.neo.age&#125;&quot;)    private int iAge;&#125;\n\nlog配置\n12345#window下这样的路径是直接再c盘下新建的logging.path=/user/local/loglogging.level.com.favorites=DEBUGlogging.level.org.springframework.web=INFOlogging.level.org.hibernate=ERROR\npath为本机的log地址，logging.level  后面可以根据包路径配置不同资源的log级别\n数据库操作在这里我重点讲述mysql、spring data jpa的使用，其中mysql 就不用说了大家很熟悉，jpa是利用Hibernate生成各种自动化的sql，如果只是简单的增删改查，基本上不用手写了，spring内部已经帮大家封装实现了。\n下面简单介绍一下如何在spring boot中使用\n12345678# 数据库连接配置spring.datasource.url=jdbc:mysql://localhost:3306/test  spring.datasource.data-username=test  spring.datasource.data-password=test123456  spring.datasource.driver-class-name=com.mysql.jdbc.Driver  # Spring date jpaspring.jpa.properties.hibernate.hbm2ddl.auto=update  \n\nhibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构,有四个值：\n\ncreate： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。\n\ncreate-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。\n\nupdate：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。\n\nvalidate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。\n\n\n","slug":"SpringBoot- Web过滤器Filter","date":"2018-06-29T04:38:53.000Z","categories_index":"SpringBoot","tags_index":"SpringBoot,过滤器","author_index":"Weiba"},{"id":"d501b5a3ec21ab2909c51ff01349c237","title":"SpringBoot 浏览器自动刷新扩展","content":"chrome 安装 livereload 插件\nspring boot 添加 devtools 依赖\n并开启配置\nspring.devtools.livereload.enabled&#x3D;true\n","slug":"SpringBoot 浏览器自动刷新扩展","date":"2018-06-28T04:36:45.000Z","categories_index":"SpringBoot","tags_index":"SpringBoot,浏览器","author_index":"Weiba"},{"id":"fa5e0930c1df87d0cd434074c90d5e5e","title":"SpringBoot Thymeleaf  模板","content":"配置说明: \n配置一切正常, 但一直 404 问题, 解决办法\n原因, maven仓库包下载的问题\n1按照在Stack Overflow上一位外国朋友遇到的差不多的问题以及解答，说是有可能是maven引入的包有问题导致的。但是该问题无法通过在项目中清理后重新构建来修复（本人尝试无用），只能把配置的对应的maven m2目录清空，然后打开eclipse以后重新构建的时候让maven重新下载所需jar包才可以。\n\n解决方法\n\n删除原来的maven仓库, 有很多个人包, 不方便\n手动指定Thymeleaf版本\n\n1234&lt;properties&gt;    &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt;    &lt;thymeleaf-layout-dialect.version&gt;2.1.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;\n\n支持JSP的配置\nSpring Boot 不建议使用Jsp，但如果一定要使用，可以参考此工程作为脚手架：JSP支持\n","slug":"SpringBoot Thymeleaf  模板","date":"2018-06-28T04:35:45.000Z","categories_index":"SpringBoot","tags_index":"SpringBoot,Thymeleaf","author_index":"Weiba"},{"id":"55462c26c8d97c85cb11e092c0e581ae","title":"SpringBoot Data Jpa","content":"今天完成的事熟悉 spring data jpa的使用\nSpring data jpa首先了解JPA是什么？\nJPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象&#x2F;关联映射工具来管理Java应用中的关系数据。他的出现主要是为了简化现有的持久化开发工作和整合ORM技术，结束现在Hibernate，TopLink，JDO等ORM框架各自为营的局面。值得注意的是，JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，JPA受到了极大的支持和赞扬，其中就包括了Spring与EJB3.0的开发团队。\n1注意:JPA是一套规范，不是一套产品，那么像Hibernate,TopLink,JDO他们是一套产品，如果说这些产品实现了这个JPA规范，那么我们就可以叫他们为JPA的实现产品。\n\nspring data jpa\nSpring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！\n1spring data jpa让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现\n\n基本查询基本查询也分为两种，一种是spring data默认已经实现，一种是根据查询的方法来自动解析成SQL。\n预先生成方法\nspring data jpa 默认预先生成了一些基本的CURD的方法，例如：增、删、改等等\n1). 接口继承JpaRepository (之前使用过)\n12public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125;\n\n2). 使用默认方法, 根据方法名可以看出他的意思\n1234567891011121314151617@Testpublic void testBaseQuery() throws Exception &#123;\tUser user=new User();\t// 查询所有数据\tuserRepository.findAll();\t// 根据id查询出一个用户\tuserRepository.findOne(1l);\t// 保存用户数据\tuserRepository.save(user);\t// 删除用户\tuserRepository.delete(user);\t// 统计用户个数\tuserRepository.count();\t// 判断该id是否存在, 返回 bool 值\tuserRepository.exists(1l);\t// ...&#125;\n\n自定义简单查询\n自定义的简单查询就是根据方法名来自动生成SQL，主要的语法是 findXXBy, readAXXBy, queryXXBy, countXXBy, getXXBy 后面跟属性名称：\n1User findByUserName(String userName);\n\n也使用一些加一些关键字 And、 Or\n1User findByUserNameOrEmail(String username, String email);\n\n修改、删除、统计也是类似语法\n123Long deleteById(Long id);Long countByUserName(String userName)\n\n基本上SQL体系中的关键词都可以使用，例如：LIKE、 IgnoreCase、 OrderBy。\n12345List&lt;User&gt; findByEmailLike(String email);User findByUserNameIgnoreCase(String userName);    List&lt;User&gt; findByUserNameOrderByEmailDesc(String email);\n\n具体的关键字，使用方法和生产成SQL如下表所示:\n\n\n\nKeyword\nSample\nJPQL snippet\n\n\n\nAnd\nfindByLastnameAndFirstname\n… where x.lastname &#x3D; ?1 and x.firstname &#x3D; ?2\n\n\nOr\nfindByLastnameOrFirstname\n… where x.lastname &#x3D; ?1 or x.firstname &#x3D; ?2\n\n\nIs,Equals\nfindByFirstnameIs,findByFirstnameEquals\n… where x.firstname &#x3D; ?1\n\n\nBetween\nfindByStartDateBetween\n… where x.startDate between ?1 and ?2\n\n\nLessThan\nfindByAgeLessThan\n… where x.age &lt; ?1\n\n\nLessThanEqual\nfindByAgeLessThanEqual\n… where x.age ⇐ ?1\n\n\nGreaterThan\nfindByAgeGreaterThan\n… where x.age &gt; ?1\n\n\nGreaterThanEqual\nfindByAgeGreaterThanEqual\n… where x.age &gt;&#x3D; ?1\n\n\nAfter\nfindByStartDateAfter\n… where x.startDate &gt; ?1\n\n\nBefore\nfindByStartDateBefore\n… where x.startDate &lt; ?1\n\n\nIsNull\nfindByAgeIsNull\n… where x.age is null\n\n\nIsNotNull,NotNull\nfindByAge(Is)NotNull\n… where x.age not null\n\n\nLike\nfindByFirstnameLike\n… where x.firstname like ?1\n\n\nNotLike\nfindByFirstnameNotLike\n… where x.firstname not like ?1\n\n\nStartingWith\nfindByFirstnameStartingWith\n… where x.firstname like ?1 (parameter bound with appended %)\n\n\nEndingWith\nfindByFirstnameEndingWith\n… where x.firstname like ?1 (parameter bound with prepended %)\n\n\nContaining\nfindByFirstnameContaining\n… where x.firstname like ?1 (parameter bound wrapped in %)\n\n\nOrderBy\nfindByAgeOrderByLastnameDesc\n… where x.age &#x3D; ?1 order by x.lastname desc\n\n\nNot\nfindByLastnameNot\n… where x.lastname &lt;&gt; ?1\n\n\nIn\nfindByAgeIn(Collection ages)\n… where x.age in ?1\n\n\nNotIn\nfindByAgeNotIn(Collection age)\n… where x.age not in ?1\n\n\nTRUE\nfindByActiveTrue()\n… where x.active &#x3D; true\n\n\nFALSE\nfindByActiveFalse()\n… where x.active &#x3D; false\n\n\nIgnoreCase\nfindByFirstnameIgnoreCase\n… where UPPER(x.firstame) &#x3D; UPPER(?1)\n\n\n复杂查询在实际的开发中我们需要用到分页、删选、连表等查询的时候就需要特殊的方法或者自定义SQL\n分页查询\n分页查询在实际使用中非常普遍了，spring data jpa 已经帮我们实现了分页的功能，在查询的方法中，需要传入参数 Pageable ,当查询中有多个参数的时候 Pageable 建议做为最后一个参数传入\n123Page&lt;User&gt; findALL(Pageable pageable);    Page&lt;User&gt; findByUserName(String userName,Pageable pageable);\n\nPageable 是spring封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则\n12345678@Testpublic void testPageQuery() throws Exception &#123;\tint page=1,size=10;\tSort sort = new Sort(Direction.DESC, &quot;id&quot;);    Pageable pageable = new PageRequest(page, size, sort);    userRepository.findALL(pageable);    userRepository.findByUserName(&quot;testName&quot;, pageable);&#125;\n\n限制查询\n有时候我们只需要查询前N个元素，或者支取前一个实体。\n123456789ser findFirstByOrderByLastnameAsc();User findTopByOrderByAgeDesc();Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);\n\n自定义SQL查询\n其实Spring data 觉大部分的SQL都可以根据方法名定义的方式来实现，但是由于某些原因我们想使用自定义的SQL来查询，spring data也是完美支持的；在SQL的查询方法上面使用 @Query 注解，如涉及到删除和修改在需要加上 @Modifying .也可以根据需要添加 @Transactional 对事物的支持，查询超时的设置等\n12345678910111213@Modifying@Query(&quot;update User u set u.userName = ?1 where u.id = ?2&quot;)int modifyByIdAndUserId(String  userName, Long id);\t@Transactional@Modifying@Query(&quot;delete from User where id = ?1&quot;)void deleteByUserId(Long id);  @Transactional(timeout = 10)@Query(&quot;select u from User u where u.emailAddress = ?1&quot;)User findByEmailAddress(String emailAddress);    \n\n多表查询\n多表查询在spring data jpa中有两种实现方式，第一种是利用hibernate的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要第二种方式。\n首先需要定义一个结果集的接口类。\n12345678910111213public interface HotelSummary &#123;\tCity getCity();\tString getName();\tDouble getAverageRating();\tdefault Integer getAverageRatingRounded() &#123;\t\treturn getAverageRating() == null ? null : (int) Math.round(getAverageRating());\t&#125;&#125;\n\n查询的方法返回类型设置为新创建的接口\n1234567@Query(&quot;select h.city as city, h.name as name, avg(r.rating) as averageRating &quot;\t\t- &quot;from Hotel h left outer join h.reviews r where h.city = ?1 group by h&quot;)Page&lt;HotelSummary&gt; findByCity(City city, Pageable pageable);@Query(&quot;select h.name as name, avg(r.rating) as averageRating &quot;\t\t- &quot;from Hotel h left outer join h.reviews r  group by h&quot;)Page&lt;HotelSummary&gt; findByCity(Pageable pageable);\n\n使用方法\n1234Page&lt;HotelSummary&gt; hotels = this.hotelRepository.findByCity(new PageRequest(0, 10, Direction.ASC, &quot;name&quot;));for(HotelSummary summay:hotels)&#123;\t\tSystem.out.println(&quot;Name&quot; +summay.getName());\t&#125;\n\n\n\n\n\n\n\n\n\n\n在运行中Spring会给接口（HotelSummary）自动生产一个代理类来接收返回的结果，代码汇总使用 getXX 的形式来获取\n多数据源的支持同源数据库的多源支持(未测试)\n日常项目中因为使用的分布式开发模式，不同的服务有不同的数据源，常常需要在一个项目中使用多个数据源，因此需要配置sping data jpa对多数据源的使用，一般分一下为三步：\n1.配置多数据源2.不同源的实体类放入不同包路径3.声明不同的包路径下使用不同的数据源、事务支持\n异构数据库多源支持(未测试)\n比如我们的项目中，即需要对 mysql 的支持，也需要对 mongodb 的查询等。\n实体类声明 @Entity 关系型数据库支持类型、声明 @Document 为mongodb支持类型，不同的数据源使用不同的实体就可以了\n1234567891011121314151617interface PersonRepository extends Repository&lt;Person, Long&gt; &#123; …&#125;@Entitypublic class Person &#123;  …&#125;interface UserRepository extends Repository&lt;User, Long&gt; &#123; …&#125;@Documentpublic class User &#123;  …&#125;\n\n但是，如果User用户既使用 mysql 也使用 mongodb 呢，也可以做混合使用\n12345678910111213interface JpaPersonRepository extends Repository&lt;Person, Long&gt; &#123; …&#125;interface MongoDBPersonRepository extends Repository&lt;Person, Long&gt; &#123; …&#125;@Entity@Documentpublic class Person &#123;  …&#125;\n\n也可以通过对不同的包路径进行声明，比如A包路径下使用mysql, B包路径下使用mongoDB\n123@EnableJpaRepositories(basePackages = &quot;com.neo.repositories.jpa&quot;)@EnableMongoRepositories(basePackages = &quot;com.neo.repositories.mongo&quot;)interface Configuration &#123; &#125;\n\n其他使用枚举\n使用枚举的时候，我们希望数据库中存储的是枚举对应的String类型，而不是枚举的索引值，需要在属性上面添加 @Enumerated(EnumType.STRING) 注解\n123@Enumerated(EnumType.STRING) @Column(nullable = true)private UserType type;\n\n不需要和数据库映射的属性\n正常情况下我们在实体类上加入注解 @Entity，就会让实体类和表相关连如果其中某个属性我们不需要和数据库来关联只是在展示的时候做计算，只需要加上 @Transient 属性既可。\n12@Transientprivate String  userName;\n\n明日计划Spring mybatis的使用\n","slug":"SpringBoot Data Jpa","date":"2018-06-26T04:37:39.000Z","categories_index":"SpringBoot","tags_index":"SpringBoot,JPA","author_index":"Weiba"},{"id":"7bf038e0b297e00ea48bc31e608946a7","title":"Mysql常用命令","content":"常用命令查看线程:   \n1234select id, db, user, host, command, time, state, infofrom information_schema.processlistwhere db like &#x27;resource_01&#x27;order by time desc ;\n\n\nUNION ALL: 将两张表的数据拼装到一起返回.\n联表查询: \n123456789SELECT tb_students.id, tb_students.stuName, tb_profession.proName AS stuProfession FROM tb_students, tb_profession WHERE tb_students.stuProfession = tb_profession.id ORDER BY tb_students.id SELECT tb_profession.*, COUNT(*) AS proCount        FROM tb_students        INNER JOIN tb_profession        ON tb_profession.id = tb_students.stuProfession        GROUP BY tb_profession.id","slug":"Mysql常用命令","date":"2018-06-23T06:34:27.000Z","categories_index":"Mysql","tags_index":"常用命令,Mysql","author_index":"Weiba"},{"id":"83b0d42133474ff4a2edb50fe8dc767c","title":"SpringBoot - Redis","content":"今天完成的事情：Spring Boot Redis, 依赖的事情弄了很久, 纯洁的微笑的示例教程是使用1.0的Spring Boot, 我使用的是2.0.1, 有很大出入, 它Github上的1.5.6版本的Redis示例也是有问题的.\nSpring Boot Redis如何使用\n引入 redis 相关依赖, 注意:\n,12345678910111213141516171819202122&lt;!-- Spring Boot使用的是1.4（包括1.4版本）之前的版本使用如下配置 --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 1.5.* 的版本需要指定版本号 --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;   &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 2.* 版本 redis依赖改名了,直接使用下面的依赖 --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 导入其他模块的依赖 --&gt;&lt;dependency&gt;   &lt;groupId&gt;com.example&lt;/groupId&gt;   &lt;artifactId&gt;02-SpringBootWeb&lt;/artifactId&gt;   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;\n在配置文件中添加配置\n1234567891011121314151617181920#Redis ProPerTies#Redis数据库索引(默认为0)spring.redis.database=0#Redis服务器地址spring.redis.host=127.0.0.1#Redis服务器端口号spring.redis.port=6379#Redis服务器密码(默认为空)spring.redis.password=#Redis 连接池最大连接数(使用负值表示没有限制)spring.redis.jedis.pool.max-active=8#Redis 连接池最大阻塞时间(使用负数表示没有限制)spring.redis.jedis.pool.max-wait=-1#Redis 连接池中最大的空闲连接spring.redis.jedis.pool.max-idle=8#Redis 连接池中最小的空间连接spring.redis.jedis.pool.min-idle=0#Redis 连接超时时间spring.redis.timeout=0\n代码实现: \n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374ml.xiaoweiba.cache.RedisConfigpackage ml.xiaoweiba.cache;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import java.lang.reflect.Method;/*** @program: demo* @description: Redis Cache 配置类* @author: Mr.xweiba* @create: 2018-06-22 11:13**/@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport &#123;   @Bean   public KeyGenerator keyGenerator() &#123;       return new KeyGenerator() &#123;           @Override           public Object generate(Object target, Method method, Object... params) &#123;               StringBuilder sb = new StringBuilder();               sb.append(target.getClass().getName());               sb.append(method.getName());               for (Object obj : params) &#123;                   sb.append(obj.toString());               &#125;               return sb.toString();           &#125;       &#125;;   &#125;   @SuppressWarnings(&quot;rawtypes&quot;)   @Bean   public CacheManager cacheManager(RedisTemplate redisTemplate) &#123;       RedisCacheManager rcm = new RedisCacheManager(redisTemplate);       //设置缓存过期时间       //rcm.setDefaultExpiration(60);//秒       return rcm;   &#125;   @Bean(name=&quot;redisTemplate&quot;)   public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123;       StringRedisTemplate template = new StringRedisTemplate(factory);       Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);       ObjectMapper om = new ObjectMapper();       om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);       om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);       jackson2JsonRedisSerializer.setObjectMapper(om);       template.setValueSerializer(jackson2JsonRedisSerializer);       template.afterPropertiesSet();       return template;   &#125;&#125;\n\n测试类:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package ml.xiaoweiba.cache;import java.util.concurrent.TimeUnit;import ml.xiaoweiba.entity.Student;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class&#125;)@SpringBootTestpublic class RedisConfigTest &#123;   @Autowired   private StringRedisTemplate stringRedisTemplate;   @Autowired   private RedisTemplate redisTemplate;   @Test   public void test() throws Exception &#123;       stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);       Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));   &#125;   @Test   public void testObj() throws Exception &#123;       Student student = new Student(&quot;aa&quot;, 24, &quot;aa@126.com&quot;, &quot;213321&quot;);       ValueOperations&lt;String, Student&gt; operations = redisTemplate.opsForValue();       operations.set(&quot;students&quot;, student);       operations.set(&quot;studentOne&quot;, student, 1, TimeUnit.SECONDS);       Thread.sleep(1000);       //redisTemplate.delete(&quot;com.neo.f&quot;);       boolean exists = redisTemplate.hasKey(&quot;studentOne&quot;);       if (exists) &#123;           System.out.println(&quot;exists is true&quot;);       &#125; else &#123;           System.out.println(&quot;exists is false&quot;);       &#125;       Assert.assertEquals(&quot;aa&quot;, operations.get(&quot;students&quot;).getStudentName());   &#125;&#125;\n\n错误测试报错:\nIf you have database settings to be loaded from a particular profile you may need to active it\n导致此问题的原因为，springboot生成的项目启动时会自动注入数据源。而此时在配置文件中并没有配置数据源信息，因此会抛出异常\n（1）如果暂时不需要数据源，可将pom文件中的mysql和mybatis（或其他数据源框架）注释掉，即可正常启动。\n（2）在@SpringBootApplication中排除其注入,( 这里使用这个方法解决 )\n@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class&#125;)\n（3）提供数据源的配置或其他数据源配置，此处提供默认配置示例，在application.properties文件中添加以下配置项：\n主数据源，默认的123456#spring.datasource.type=com.zaxxer.hikari.HikariDataSourcespring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=root\n\n注解@EnableCachingSpring 3开始提供的通过注解开启缓存功能\n明天计划的事情：继续Spring Boot, 今天弄清楚Redis和Spring Boot 1.* 2.* 之间的关系花了很久, 明天完成redis 在Spring Boot 2.0版本下的应用.\n","slug":"SpringBoot - Redis","date":"2018-06-22T04:32:13.000Z","categories_index":"SpringBoot","tags_index":"Redis,SpringBoot","author_index":"Weiba"},{"id":"ffe1e7d4556a4c5d56e072285362f94d","title":"SpringBoot 代码中使用国际化配置文件","content":"国际化文件12345678910resources    │  application.yml    │  logback.xml    │  mybatis-config.xml    │    └─i18n            lang.properties            lang_en_US.properties            lang_zh_CN.properties            lang_zh_TW.properties\nyml 配置文件123456i18n:     locale: zh_CNspring:     messages:          basename: i18n/lang          encoding: UTF-8\n\n启动类注入国际化配置123456789@Value(&quot;$&#123;i18n.locale&#125;&quot;)private String locale;@Beanpublic LocaleResolver localeResolver() &#123;\tLocale locale = I18nUtils.localeFromString(this.locale, (Locale)null);\treturn new FixedLocaleResolver(locale);&#125;\n\n使用工具类获取国际化配置这里应该使用 Aware 接口.\n12345678910111213public class I18nToolUtils &#123;    /**     * 国际化信息服务     */    private final static MessageSource messageSource = SpringBeanUtils.getBean(MessageSource.class);    public static String getI18String(String code) &#123;        if (StringUtils.isBlank(code)) return null;        return messageSource.getMessage(code, null, LocaleContextHolder.getLocale());    &#125;&#125;","slug":"SpringBoot 代码中使用国际化配置文件","date":"2018-06-21T04:30:40.000Z","categories_index":"SpringBoot","tags_index":"SpringBoot,国际化","author_index":"Weiba"},{"id":"682ca596a13a30a92b684fce37102be2","title":"Spring Boot-Hello World","content":"本文学习自 纯洁的微笑 Spring Boot 教程\nSpring Boot 示例程序: \nmaven构建项目下载Spring Boot模板:\n\n访问http://start.spring.io/\n选择构建工具Maven Projec, 其他默认即可, \n点击Generate Project下载项目压缩包\n下载后解压, 再使用idea打开\n\n项目结构介绍:\nspingboot建议的目录结果如下：\n123456789101112131415com  +- example    +- myproject      +- Application.java      |      +- domain      |  +- Customer.java      |  +- CustomerRepository.java      |      +- service      |  +- CustomerService.java      |      +- controller      |  +- CustomerController.java      |\n\n\nApplication.java 建议放到根目录下面,主要用于做一些框架配置 (它是Spring Boot的main方法, 启动时只会扫描以它为根目录一下的文件)\ndomain目录主要用于实体（Entity）与数据访问层（Repository）\nservice 层主要是业务类代码\ncontroller 负责页面访问控制\n\n采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改最后，启动Application main方法，至此一个java项目搭建好了！\npom.xml文件中默认有两个模块：\nspring-boot-starter: 核心模块，包括自动配置支持、日志和YAML；\nspring-boot-starter-test: 测试模块，包括JUnit、Hamcrest、Mockito。\npom.xml 中添加spring boot Web支持:\n1234&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n在项目中添加一个controller\n@RestController :\n\n代表这个Controller类所有的handler都以Json格式返回数据, 不需要在对接的方法添加@ResponseBody\n不需要你去导入JSON等依赖\n不需要配置 spring controller扫描\n\n*. 如果我们需要使用页面开发只要使用 @Controller\n1234567@RestControllerpublic class HelloWorldController &#123;    @RequestMapping(&quot;/&quot;)    public String index() &#123;        return &quot;Hello World&quot;;    &#125;&#125;\n\n启动main方法, 就可以正常访问 http://127.0.0.1:8080, 不需要任何其他配置. \n测试类: \n1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.demo;import com.example.demo.controller.HelloWorldController;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123;    private MockMvc mockMvc;    @Before    public void setMvc() &#123;        // 启动Spring Boot        mockMvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build();    &#125;    @Test    public void getMvc() throws Exception &#123;        // perform 执行 -&gt;          // MockMvcRequestBuilders.get(&quot;/&quot;) 请求 -&gt;        // 接收数据accept, 接收的格式为:MediaType.APPLICATION_JSON -&gt;         // 对比 andExpect(), 条件为: 返回状态码 status() 是否为正常获取: isOk() -&gt;        // 对比 andExpect(), 条件为: 返回内容 content() 是否为: string(&quot;Hello World&quot;).        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/&quot;).accept(MediaType.APPLICATION_JSON))                .andExpect(status().isOk())                .andExpect(content().string(&quot;Hello World&quot;));    &#125;&#125;\n\n开发环境的调试\n热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：\n12345678910111213141516171819 &lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;\n\n该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。\n","slug":"SpringBoot-Hello World","date":"2018-06-18T04:28:30.000Z","categories_index":"SpringBoot","tags_index":"SpringBoot,hello world","author_index":"Weiba"},{"id":"1e49212fb32c9d3364917f80982bd0ed","title":"Spring RMI 远程函数调用","content":"1.需要分离出来的类- 实体类- dao层, 直接在server端实现. OSS 封装为接口 阿里云 与 七牛云阿里云方法:\n\nOSSClient getOssClient();\nboolean createBucket();\nboolean deleteBucket();\nString updateFile();\nInputStream getFile();\nboolean deleteFile();\n\n七牛云\n\nAuth getAuth();\nConfiguration getCfg():\nUploadManager getUploadManager();\nBucketManager getBucketManager();\nboolean delete(String keyFile)\nboolean updateFile(Integer id, MultipartFile multipartFile)\nBucketManager.FileListIterator getObjectList\n\n暂时需要实现接口:上传文件列表\n","slug":"Spring RMI 远程函数调用","date":"2018-06-08T04:44:05.000Z","categories_index":"Spring","tags_index":"Spring,RMI","author_index":"Weiba"},{"id":"170ae045f381d8d39d07812ade26def7","title":"缓存更新策略","content":"读取步骤\n读取\n\n读取数据库数据\n成功 -&gt; 写入缓存\n失败 -&gt; 不写入缓存\n\n\n更新\n\n更新数据库数据\n成功 -&gt; 将缓存标记失败, 不要写入缓存.\n\n\n\n\n\n\n\n\n两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。\n\n\n\n插入\n\n插入数据库\n成功 -&gt; 不写入缓存.\n\n\n\n刷新内存，以memcached为例，新增，修改和删除操作，一般采用lazy load的策略，即新增时只写入数据库，并不会马上更新Memcached，而是等到再次读取时才会加载到Memcached中，修改和删除操作也是更新 数据库，然后将Memcached中的数据标记为失效，等待下次读取时再加载。\n","slug":"缓存更新策略","date":"2018-05-24T04:59:36.000Z","categories_index":"缓存","tags_index":"缓存","author_index":"Weiba"},{"id":"a8ca03413c144f76afe39fcc28a8a039","title":"JQuery 文件上传","content":"Java后端接收文件:\n12345@RequestMapping(value = &quot;/uploaded&quot;)@ResponseBodypublic String uploaded(MultipartFile file)&#123;    return file.getOriginalFilename();&#125;\n\nposoman 测试注意不要请求头\n可能会遇到的错误Current request is not a multipart request 错误: 去掉请求头\nweb 上传htmlthymeleaf + Vue 示范\n1&lt;input class=&quot;file&quot; type=&quot;file&quot; value=&quot;上传&quot; id=&quot;file&quot; multiple=&quot;multiple&quot; accept=&quot;image/png,image/jpeg&quot; v-on:input=&quot;uploadConfig&quot;/&gt;\njs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 上传业务方法uploadConfig: function(e) &#123;    var _this = this;    var verificationImageFiles = _this.verificationImageFiles(e);    var responses = CommUtils.uploadFile(e, EditPaperWorkPage.uploadPaperWorkImagesUrl, verificationImageFiles);    if (CommUtils.isNotEmpty(responses) &amp;&amp; CommUtils.isNotEmpty(responses.successFiles)) &#123;        // 添加排序字段        $.each(responses.successFiles, function (index, response) &#123;            $.extend(response, &#123;                &#x27;sequencing&#x27;: index            &#125;);            if (CommUtils.isEmpty(_this.paper.paperWorkFileList )) &#123;                _this.paper.paperWorkFileList = [];            &#125;            _this.paper.paperWorkFileList.push(response);            _this.paper.isSaved = false;        &#125;);        if (!this.isShowImages) &#123;            _this.changeImageShow();        &#125;        CommUtils.showSuccess(i18n[&#x27;file_upload_success&#x27;]);    &#125;        if (CommUtils.isNotEmpty(responses) &amp;&amp; CommUtils.isNotEmpty(responses.errorFiles)) &#123;        var errorFileNames = &#x27;&#x27;;        $.each(responses.errorFiles, function (index, errorFile) &#123;            if (CommUtils.isEmpty(errorFileNames)) &#123;                errorFileNames += errorFile.fileName;            &#125; else &#123;                errorFileNames += &quot;,&quot; + errorFile.fileName;            &#125;        &#125;);        if (CommUtils.isNotEmpty(errorFileNames)) &#123;            CommUtils.showFail(errorFileNames + i18n[&#x27;file_upload_error&#x27;]);        &#125;    &#125;&#125;,// 过滤重复文件verificationImageFiles: function(e) &#123;    var _this = this;    var uploadImagesMap = &#123;&#125;;    var verificationImageFileMap = &#123;&#125;;    var duplicateFileNames = &quot;&quot;;    $.each(_this.paper.paperWorkFileList, function (index, file) &#123;        var fileKey = file.fileName + file.size;        uploadImagesMap[fileKey] = file;    &#125;);    $.each(e.target.files, function (index, file) &#123;        var fileKey = file.name + file.size;        if (uploadImagesMap[fileKey] || file.type.indexOf(&quot;image&quot;) &lt; 0) &#123;            verificationImageFileMap[fileKey] = file;            if (CommUtils.isNotEmpty(duplicateFileNames)) &#123;                duplicateFileNames += (&#x27;,&#x27; +  file.name);            &#125; else &#123;                duplicateFileNames += file.name;            &#125;        &#125;    &#125;);    if (CommUtils.isNotEmpty(duplicateFileNames)) &#123;        CommUtils.showFail(i18n[&#x27;duplicate_file&#x27;] + duplicateFileNames);    &#125;    return verificationImageFileMap;&#125;,// 上传工具类uploadFile: function(e, uploadFileUrl, verificationImageFileMap) &#123;\tvar response = &#123;\t\t&#x27;successFiles&#x27; : [],\t\t&#x27;errorFiles&#x27;: []\t&#125;;\tvar tempFileName = &#x27;&#x27;;\tfor (var i = 0; i &lt; e.target.files.length; i++) &#123;\t\tvar formData = new FormData();\t\tvar file = e.target.files[i];\t\ttempFileName = file.name;\t\tvar fileKey = tempFileName + file.size;\t\tif (this.isEmpty(verificationImageFileMap) || this.isEmpty(verificationImageFileMap[fileKey])) &#123;\t\t\tformData.append(&#x27;file&#x27;, file);\t\t\tformData.append(&quot;name&quot;, tempFileName);\t\t\t$.ajax(&#123;\t\t\t\turl : uploadFileUrl,\t\t\t\ttype : &#x27;POST&#x27;,\t\t\t\tdata : formData,\t\t\t\t// 告诉jQuery不要去处理发送的数据\t\t\t\tprocessData : false,\t\t\t\t// 告诉jQuery不要去设置Content-Type请求头\t\t\t\tcontentType : false,\t\t\t\tasync: false,\t\t\t\tbeforeSend:function()&#123;\t\t\t\t&#125;,\t\t\t\tsuccess : function(responseStr) &#123;\t\t\t\t\tresponse.successFiles.push(responseStr);\t\t\t\t&#125;,\t\t\t\terror : function(responseStr) &#123;\t\t\t\t\tconsole.log(&quot;文件上传失败!&quot; + responseStr);\t\t\t\t\tresponse.errorFiles.push(&#123;\t\t\t\t\t\t&#x27;fileName&#x27;: tempFileName\t\t\t\t\t&#125;);\t\t\t\t&#125;\t\t\t&#125;);\t\t&#125;\t&#125;\te.target.value=&#x27;&#x27;;\treturn response;&#125;,","slug":"JQuery 文件上传","date":"2018-05-23T05:02:42.000Z","categories_index":"JQuery","tags_index":"JQuery","author_index":"Weiba"},{"id":"6e888c70e455b1bb951534046563934e","title":"Spring 登陆验证 Session Cookie","content":"今日完成的事\n线上项目 整合Cookie 登陆\n通过 Memcached 来同步Session, 解决tomcat多开带来的Session同步问题.\n\nMemcached 同步 Session\n由于使用了多台tomcat, 在Nginx做负载均衡时会将请求随机分发到各个tomcat上, 当属于tomcat_1的登陆后会话请求被转发到tomcat_2上时, 就会出现登陆验证错误, 因为tomcat_2上这个会话并未登陆.\n\n解决方法, 通过Memcache保存Session会话.\n\n注意, Session是容器保存的,内容放置在服务器具体的文件中,并不是程序保存的, 这个概念一定要搞清楚.\n我这里场景是 登陆后执行一个请求列出所有用户, 所以不能直接转到jsp. \n使用 redirect 跳转页面会导致 session 值丢失. 参考连接1 参考连接2\n解决方法\n思路: handler中保存session后,先forward到一个handler再redirect到目标handler, session值不会丢失\n具体实现:\nhandler 中保存 session, 此时session还未保存到容器中\n返回页面使用redirect到新页面,因为重定向特性不会带前页面的数据, 所以容器会将session值直接丢弃,导致session值丢失.(session id还在)\n返回时使用 forward 到新handler, 容器会将session保存.\n\n\n在新handler中再redirect到新页面, 此时session已保存,不会影响\n\n\n\n\n\n\n\n将Tomcat的session由Memcached保存  准备工作\nNginx 负载均衡已配置\nTomcat 已开启多个容器\nTomcat 8\n官方文档: https://github.com/magro/memcached-session-manager/wiki/SetupAndConfiguration\n参考资料: https://www.cnblogs.com/jsonhc/p/7344902.html\n\n\n下载所需jar包, 每个tomcat版本对应的包不同\nwget http://repo1.maven.org/maven2/de/javakaffee/msm/memcached-session-manager/2.1.1/memcached-session-manager-2.1.1.jar\nwget http://repo1.maven.org/maven2/de/javakaffee/msm/memcached-session-manager-tc8/2.1.1/memcached-session-manager-tc8-2.1.1.jar\nwget http://repo1.maven.org/maven2/net/spy/spymemcached/2.11.1/spymemcached-2.11.1.jar\n如果仅仅只是用java来做序列化器只需上面这三个包就ok\n下面两个包,配置后一直报错,未测试通过 \nwget http://repo1.maven.org/maven2/de/javakaffee/msm/msm-javolution-serializer/1.8.3/msm-javolution-serializer-1.8.3.jar\nwget http://repo1.maven.org/maven2/de/javakaffee/msm/msm-javolution-serializer/2.1.1/msm-javolution-serializer-2.1.1.jar\n下载完成后放入tomcat&#x2F;lib目录中\n\n修改两个tomcat配置文件,启动\nvim &#123;tomcat&#125;/conf/context.xml\n  123456789101112131415&lt;Context&gt;    &lt;!-- web application will be reloaded.                                   --&gt;    &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt;    &lt;WatchedResource&gt;$&#123;catalina.base&#125;/conf/web.xml&lt;/WatchedResource&gt;    &lt;!-- Uncomment this to disable session persistence across Tomcat restarts --&gt;    &lt;!--    &lt;Manager pathname=&quot;&quot; /&gt;    --&gt;    &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;    memcachedNodes=&quot;n1:127.0.0.1:11211,n2:127.0.0.1:22122&quot;    failoverNodes=&quot;n1&quot;    requestUriIgnorePattern=&quot;.*\\.(ico|png|gif|jpg|css|js)$&quot;    /&gt;&lt;/Context&gt;\n\n开一个test项目测试\ntest&#x2F;index.jsp, 分别写到两个 tomcat 测试, 修改{TomcatA}.liuhuan.ml代指Tomcat容器123456789101112131415161718&lt;%@ page language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatA.liuhuan.ml&lt;/font&gt;&lt;/h1&gt;&lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt;&lt;tr&gt;    &lt;td&gt;SessionID&lt;/td&gt;    &lt;%session.setAttribute(&quot;linuxinfo.top&quot;,&quot;linuxinfo.top&quot;);%&gt;    &lt;td&gt;&lt;%=session.getId() %&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;Createdon&lt;/td&gt;    &lt;td&gt;&lt;%=session.getCreationTime() %&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\n测试\n\n\n启动Memcached\nmemcached -p 11211 -m 64m -vv -u root\nmemcached -p 22122 -m 64m -vv -u root\n\n测试123456789101112131415161718&lt;%@ page language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   &lt;h1&gt;&lt;font color=&quot;blue&quot;&gt;TomcatA.liuhuan.ml&lt;/font&gt;&lt;/h1&gt;   &lt;table align=&quot;centre&quot; border=&quot;1&quot;&gt;       &lt;tr&gt;           &lt;td&gt;SessionID&lt;/td&gt;           &lt;%session.setAttribute(&quot;linuxinfo.top&quot;,&quot;linuxinfo.top&quot;);%&gt;&lt;td&gt;&lt;%=session.getId() %&gt;&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;           &lt;td&gt;Createdon&lt;/td&gt;           &lt;td&gt;&lt;%=session.getCreationTime() %&gt;&lt;/td&gt;       &lt;/tr&gt;   &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\n实际项目\nsession 登陆验证 Controller 123456789101112131415161718192021222324//登陆@RequestMapping(&quot;/login.action&quot;)public String login(HttpSession session, Auth auth) throws Exception &#123;    if(userService.findAuth(auth))&#123;        // 在session中保存用户身份信息        session.setAttribute(&quot;username&quot;, auth.getUsername());        logger.info(&quot;session.getId():&quot; + session.getId());        // 存入缓存 用作效验        MemcacheUtils.set(session.getId(), auth.getUsername());    &#125;    //redirect 重定向到用户信息页面,会导致session内容丢失. 这里先forward保存session    return &quot;forward:/s/succed.action&quot;;&#125;//退出登陆@RequestMapping(&quot;/logout.action&quot;)public String logout(HttpSession session)&#123;    // 删除缓存    MemcacheUtils.delete(session.getId());    //删除session    session.invalidate();    return &quot;redirect:/login.action&quot;;&#125;\n拦截器效验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//执行Handler方法之前执行//用于身份认证、身份授权//比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行@Overridepublic boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;    //handler 开始时间    this.timer = System.currentTimeMillis();    //获取请求的url    String url = httpServletRequest.getRequestURI();    //判断url是否是公开地址(实际使用时将公开地址配置到配置文件中)    //正则匹配url    Pattern pattern = Pattern.compile(&quot;^.*login.action.*$|^.*rest\\\\/api\\\\/.*$|^.*home\\\\/.*$|^.*profession\\\\/.*$|^.*memcache\\\\/.*$&quot;);    Matcher matcher = pattern.matcher(url);    //可以导入一个配置文件,匹配其中的请求    if (matcher.matches())&#123;        //如果要进行登陆提交,放行        return true;    &#125;    // 获取 session    HttpSession session = httpServletRequest.getSession();    // 从session中取出用户信息    String username = (String)session.getAttribute(&quot;username&quot;);    logger.debug(&quot;尝试登陆用户: &quot; + username + &quot;session_id:&quot; + session.getId());    // 登陆数据效验    if(username !=&quot;&quot; &amp;&amp;username!=null)&#123;        String sessionName = (String) MemcacheUtils.get(session.getId());        logger.info(&quot;登陆用户名: &quot; + username +  &quot;, sessionName:&quot; + sessionName + &quot;, session.getId():&quot; + session.getId());        if(username.equals(sessionName))&#123;            //身份存在 放行            logger.debug(&quot;身份存在 放行&quot;);            return true;        &#125;    &#125;else&#123;        // 当 session或缓存的 username 的 值为空时(可能是缓存出问题,又或者浏览器将seesion删除), 需要删除其session重新创建, 否则会一直判空        // 删除缓存        MemcacheUtils.delete(session.getId());        //删除session        session.invalidate();    &#125;    //执行到这里标识用户身份需要认证,跳转到登陆界面    //跳转网址需要绝对路径,将当前请求重新映射到/WEB-INF/jsp/login.jsp,    // WEB-INF/jsp/login.jsp访问的是原地址+WEB-INF/jsp/login.jsp    httpServletRequest.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(httpServletRequest, httpServletResponse);    logger.info(&quot;用户身份需要认证,跳转至登陆页面,执行Handler方法之前执行&quot;);    //return false表示拦截，不向下执行 此时应计算页面结束时间    this.timer = System.currentTimeMillis() - this.timer;    logger.debug( &quot;性能日志 页面生成时长 : &quot; + this.timer + &quot;ms&quot; );    //return true表示放行    return false;&#125;\n\n登陆测试\nsession 登陆测试\n\n\n日志\n重启tomcat, session任然可以登陆\n刷新页面 正常显示\n日志\n\n\n\n\nCookie登陆, 由于它存储在用户端, 后端只需要解密验证, 没有同步问题, 服务器端重启也是不影响它验证的\n\n总结\nmemcached 因为session同步的问题拖了一天, 今天就结束了, 相对cookie验证, 纯session相对限制多一些.\n\n明日计划\n更换Redis测试.\n\n","slug":"Spring 登陆验证 Session Cookie","date":"2018-05-21T04:40:33.000Z","categories_index":"Spring","tags_index":"Spring,Cookie","author_index":"Weiba"},{"id":"e5e16181cb838f43f9740a90072d7812","title":"SpringMVC 整合 memcached","content":"今天完成的事情\n完成Spring MVC memcachede 融合\n\n整合\nmemcachede只缓存数据, 所以我们只需要在service 层 的实现中添加对应的缓存即可.\n\n\n原接口添加缓存123456789101112131415161718192021222324252627282930313233343536373839404142434445@Overridepublic UserCustom findUserById(Integer id) throws Exception &#123;    // 查找缓存    Object object = MemcacheUtils.get(&quot;user&quot; + id);    // 当存在缓存时直接返回缓存数据    if (object != null) &#123;        return (UserCustom) object;    &#125;    UserCustom userCustom = userDao.findUserById(id);    // 当缓存为空时 添加 memcached 缓存    MemcacheUtils.set(&quot;user&quot; + id, userCustom);    return userCustom;&#125;@Overridepublic int insertUser(User user) throws Exception &#123;    //插入成功后返回的值存入了user的id中    userDao.insertUser(user);    // 写入缓存 这里使用add 当 key(id)存在时, 不写入缓存    MemcacheUtils.add(&quot;user&quot; + user.getId(), user);    //所以返回user的id值    return user.getId();&#125;@Overridepublic boolean updateUser(UserCustom userCustom, Integer id) throws Exception &#123;    userCustom.setId(id);    // 写入缓存 这里使用replace, 当key(id)不存在时, 不写入缓存    MemcacheUtils.replace(&quot;user&quot; + id, userCustom);    return userDao.updateUser(userCustom);&#125;@Overridepublic boolean deleteUser(Integer i) throws Exception &#123;    // 删除缓存    MemcacheUtils.delete(String.valueOf(i));    return userDao.deleteUser(i);&#125;@Overridepublic boolean findAuth(Auth auth) throws Exception &#123;    // 密码验证的就不做缓存了    return authDao.findAuth(auth);&#125;\n测试 查找数据, 第一次从数据库中查询并将值存入到缓存, 第二次直接从缓存获取\n测试 更新数据, 再次获取, 直接从缓存中获取更新过的数据\n\n\n创建缓存api接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.jnshu.controller;import com.jnshu.model.UserCustom;import com.jnshu.service.UserService;import com.jnshu.tools.MemcacheUtils;import com.whalin.MemCached.MemCachedClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.*;/** * @program: taskTwo * @description: MemCache 缓存接口 * @author: Mr.xweiba * @create: 2018-05-19 00:06 **/@Controller@RequestMapping(&quot;/memcache&quot;)public class MemCacheController &#123;    @Autowired    UserService userService;    private static Logger logger = LoggerFactory.getLogger(MemCacheController.class);    /**    * @Description: 获取key为id的user缓存    * @Param: [key]    * @return: java.lang.Object    * @Author: Mr.Wang    * @Date: 2018/5/19    */    @RequestMapping(value = &quot;/api/&#123;id&#125;&quot;, method = RequestMethod.GET)    @ResponseBody    public Object findByKey(@RequestBody @PathVariable(&quot;id&quot;) String key)&#123;        if(StringUtils.isEmpty(key))&#123;            return &quot;key must not be empty or null!&quot;;        &#125;        return MemcacheUtils.get(&quot;user&quot; + key);    &#125;    /**    * @Description: 缓存更新接口 当key不存在时取消更新    * @Param: [key, userCustom] 键. 值    * @return: boolean    * @Author: Mr.Wang    * @Date: 2018/5/19    */    @RequestMapping(value = &quot;/api/&#123;id&#125;&quot;, method = RequestMethod.POST, produces = &quot;application/json; charset=utf-8&quot;)    @ResponseBody    public boolean updateByKey(@PathVariable(&quot;id&quot;) String key, @RequestBody UserCustom userCustom)&#123;        userCustom.setId(Integer.valueOf(key));        if(StringUtils.isEmpty(key))&#123;            return false;        &#125;        return MemcacheUtils.replace(&quot;user&quot; + key, userCustom);    &#125;        /**     * @Description: 增加缓存数据 当键存在时取消存入    * @Param: [key, userCustom] 键, 值     * @return: java.lang.Boolean     * @Author: Mr.Wang     * @Date: 2018/5/19     */    @RequestMapping(value = &quot;/api/&#123;id&#125;&quot;, method = RequestMethod.PUT, produces = &quot;application/json; charset=utf-8&quot;)    @ResponseBody    public Boolean insert(@PathVariable(&quot;id&quot;) String key, @RequestBody UserCustom userCustom)&#123;        System.out.println(userCustom.toString());        userCustom.setId(Integer.valueOf(key));        if(StringUtils.isEmpty(key))&#123;            return false;        &#125;        return MemcacheUtils.add(&quot;user&quot; + key, userCustom);    &#125;        /**     * @Description: 删除指定key     * @Param: [key]     * @return: java.lang.Boolean     * @Author: Mr.Wang     * @Date: 2018/5/19     */     @RequestMapping(value = &quot;/api/&#123;id&#125;&quot;, method = RequestMethod.DELETE)    @ResponseBody    public Boolean deleteByKey(@PathVariable(&quot;id&quot;) String key)&#123;        if(StringUtils.isEmpty(key))&#123;            return false;        &#125;        return MemcacheUtils.delete(&quot;user&quot; + key);    &#125;    /**     * @Description: 清除缓存中的所有键值对     * @Param: []     * @return: boolean     * @Author: Mr.Wang     * @Date: 2018/5/19     */    @RequestMapping(value = &quot;/api/all&quot;, method = RequestMethod.DELETE)    @ResponseBody    public boolean flashAll() throws Exception &#123;        return MemcacheUtils.flashAll();    &#125;&#125;\n\n\n测试\n\n\n错误\n中文json数据插入后乱码\n\n\n接收方法添加接收字符类型  produces = &quot;application/json; charset=utf-8&quot;12345678910@RequestMapping(value = &quot;/api/&#123;id&#125;&quot;, method = RequestMethod.PUT, produces = &quot;application/json; charset=utf-8&quot;)    @ResponseBody    public Boolean insert(@PathVariable(&quot;id&quot;) String key, @RequestBody UserCustom userCustom)&#123;        System.out.println(userCustom.toString());        userCustom.setId(Integer.valueOf(key));        if(StringUtils.isEmpty(key))&#123;            return false;        &#125;        return MemcacheUtils.add(&quot;user&quot; + key, userCustom);    &#125;\n\n\n存储对象时, 报错: exception thrown while writing bytes to server on set\n\n\n原因: memcachede接收的对象,必须序列化, 将存储的实体类实现Serializable接口即可123public class User implements Serializable &#123;    ...&#125;\n\n\n将对象集合存入缓存, 取值时为空, 应该时集合序列化的问题, 还未解决\n\n明日计划\n解决错误3 \nNginx 负载测试\n\n","slug":"Spring MVC 整合memcached ","date":"2018-05-19T04:40:33.000Z","categories_index":"SpringMVC","tags_index":"SpringMVC,memcached,缓存","author_index":"Weiba"},{"id":"f35892a29aba9ce91e96954679315c25","title":"SpringBoot 默认配置","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# 1984组 求学大作战后台服务 academy_canary_admin_web# 开发环境配置# Spring 设置spring:  datasource:    # 连接池    type: com.alibaba.druid.pool.DruidDataSource    # 数据库驱动    driver-class-name: com.mysql.jdbc.Driver    # 数据库url    url: jdbc:mysql://localhost:3306/canary?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false    username: test    password: test123456  application:    name: academy-canary# HTTP ENCODING  http:      multipart:          max-file-size: 2MB          max-request-size: 10MB      encoding:          enabled: true          charset: UTF-8          force: true  messages:      encoding: UTF-8  jmx:      enabled: true      default-domain: agentservice  resources:      chain:          strategy:              content:                  enabled: true                  paths: /**server:  context-path: /a  port: 20475  # HTTP请求和响应头的最大量, 以字节为单位, 默认值为4096, 超过此长度的部分不予处理, 一般为8k. 解决java.io.EOFException: null问题  max-http-header-size: 8192  # 请求是否允许X-Forwarded-*  use-forward-headers: true  compression:    # 是否开启压缩，默认为false.    enabled: true    # 执行压缩的阈值，默认为2048    min-response-size: 1024    # 指定要压缩的MIME type，多个以逗号分隔.    mime-types: text/plain,text/css,text/xml,text/javascript,application/json,application/javascript,application/xml,application/xml+rss,application/x-javascript,application/x-httpd-php,image/jpeg,image/gif,image/png  tomcat:    # 设定remote IP的header，如果remoteIpHeader有值，则设置为RemoteIpValve    remote-ip-header: X-Forwarded-for    # 设定Header包含的协议，通常是 X-Forwarded-Proto，如果remoteIpHeader有值，则将设置为RemoteIpValve.    protocol-header: X-Forwarded-Proto    # 设定http header使用的，用来覆盖原来port的value.    port-header: X-Forwarded-Port    # 设定URI的解码字符集.    uri-encoding: UTF-8    # 存放Tomcat的日志、Dump等文件的临时文件夹，默认为系统的tmp文件夹（如：C:\\Users\\Shanhy\\AppData\\Local\\Temp）    basedir: /var/tmp/website-app# MyBatismybatis:    # 多个包加 ,    type-aliases-package: com.ptteng.academy.persistence.beans,com.ptteng.academy.business.dto,com.ptteng.academy.business.query    mapper-locations: classpath:/mybatis/*.xml# mappermapper:    mappers:        - com.ptteng.academy.plugin.BaseMapper    not-empty: false    identity: MYSQL# pagehelperpagehelper:    helper-dialect: mysql    reasonable: true    support-methods-arguments: true    params: count=countSqlbanner:    charset: UTF-8canary:  druid:    # druid访问用户名（默认：test）    username: test    # druid访问密码（默认：zyd-druid）    password: test    # druid访问地址（默认：/druid/*）    servletPath: /druid/*    # 启用重置功能（默认false）    resetEnable: false    # 白名单(非必填)， list    allowIps[0]:    # 黑名单(非必填)， list    denyIps[0]:# 开启mysql sql 日志logging:  level:    com.ptteng.academy.persistence.mapper: DEBUG\n\nspringboot 导入外部配置, core定义全局配置:\n1234spring:  profiles:    # 引入核心配置    include: core","slug":"SpringBoot 默认配置","date":"2018-02-23T04:34:21.000Z","categories_index":"SpringBoot","tags_index":"配置,SpringBoot","author_index":"Weiba"},{"id":"7b4fe36b9ef03773e5070d880757a8f8","title":"Maven-常用配置说明","content":"全局版本号12345678&lt;properties&gt;    &lt;!-- 设置编码 --&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;spring.version&gt;4.3.14.RELEASE&lt;/spring.version&gt;    &lt;!--log4j日志包版本号--&gt;    &lt;slf4j.version&gt;1.7.18&lt;/slf4j.version&gt;    &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;  &lt;/properties&gt;\n\n依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314&lt;dependencies&gt;    &lt;!-- redis  --&gt;    &lt;!-- redis 连接驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;/groupId&gt;        &lt;artifactId&gt;jedis&lt;/artifactId&gt;        &lt;version&gt;2.9.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring 支持包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;        &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;        &lt;version&gt;2.0.7.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- redis end --&gt;  \t&lt;!-- memcached --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.whalin&lt;/groupId&gt;            &lt;artifactId&gt;Memcached-Java-Client&lt;/artifactId&gt;            &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- end --&gt;        &lt;!-- 对象池 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-pool&lt;/groupId&gt;            &lt;artifactId&gt;commons-pool&lt;/artifactId&gt;            &lt;version&gt;1.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- end --&gt;  \t&lt;!-- encodebase64string --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-net&lt;/groupId&gt;            &lt;artifactId&gt;commons-net&lt;/artifactId&gt;            &lt;version&gt;3.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- end --&gt;  \t&lt;!-- Tiles 包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.tiles&lt;/groupId&gt;            &lt;artifactId&gt;tiles-api&lt;/artifactId&gt;            &lt;version&gt;2.2.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.tiles&lt;/groupId&gt;            &lt;artifactId&gt;tiles-core&lt;/artifactId&gt;            &lt;version&gt;2.2.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.tiles&lt;/groupId&gt;            &lt;artifactId&gt;tiles-jsp&lt;/artifactId&gt;            &lt;version&gt;2.2.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.tiles&lt;/groupId&gt;            &lt;artifactId&gt;tiles-servlet&lt;/artifactId&gt;            &lt;version&gt;2.2.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.tiles&lt;/groupId&gt;            &lt;artifactId&gt;tiles-template&lt;/artifactId&gt;            &lt;version&gt;2.2.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Tiles end --&gt;  \t      &lt;!-- mysql --&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;          &lt;version&gt;5.1.39&lt;/version&gt;      &lt;/dependency&gt;      &lt;!-- mysql end --&gt;      &lt;!-- junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;      &lt;!-- junit end --&gt;            &lt;!--mybatis--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis-spring组合包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;      &lt;!--mybatis end--&gt;            &lt;!-- 上传文件使用 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-io&lt;/groupId&gt;            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;            &lt;version&gt;2.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 上传文件使用end--&gt;                &lt;!-- 加载json --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;            &lt;version&gt;2.8.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;            &lt;version&gt;2.8.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt;            &lt;version&gt;1.9.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;            &lt;artifactId&gt;jackson-mapper-lgpl&lt;/artifactId&gt;            &lt;version&gt;1.9.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.8.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 加载json end --&gt;\t\t\t\t\t\t&lt;!-- validator 数据验证--&gt;        &lt;!--jsr 303--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.validation&lt;/groupId&gt;            &lt;artifactId&gt;validation-api&lt;/artifactId&gt;            &lt;version&gt;1.1.0.Final&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- hibernate validator--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;            &lt;version&gt;5.2.0.Final&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- validator 数据验证end--&gt;        &lt;!-- 日志 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt;            &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt;            &lt;version&gt;3.3.0.Final&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 日志end--&gt;\t\t\t\t\t\t      &lt;!-- jstl --&gt;        &lt;!--  HttpServletRequest http请求依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;!--  只在编译和测试阶段运行,因为容器中自带了这个jar包 jetty中自带  --&gt;            &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;        &lt;/dependency&gt;        &lt;!--  HttpServletRequest http请求依赖 end --&gt;        &lt;!--  web el表达式 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.1&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--  web el表达式 end --&gt;                &lt;!-- 添加taglibs标签包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;taglibs&lt;/groupId&gt;            &lt;artifactId&gt;standard&lt;/artifactId&gt;            &lt;version&gt;1.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 添加taglibs标签包end --&gt;                &lt;!-- jstl end--&gt;         &lt;!-- slf4j日志包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;      &lt;!-- slf4j end --&gt;            &lt;!-- spring start --&gt;       &lt;!-- spring dbcp连接jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- 自动生成sql--&gt;\t\t\t\t&lt;!-- @Query(&quot;update #&#123;#entityName&#125; rule set rule.isEnable=1,rule.lastEnable= NOW() where rule.id= :id&quot;)    @Modifying    public int enable(@Param(&quot;id&quot;)int id);    --&gt;      &lt;dependency&gt;\t          &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;\t          &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;\t          &lt;version&gt;1.10.1.RELEASE&lt;/version&gt;\t      &lt;/dependency&gt;\t      &lt;!-- spring aop包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;aopalliance&lt;/groupId&gt;            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- aop 注解包 --&gt;        &lt;dependency&gt;              &lt;groupId&gt;org.aspectj&lt;/groupId&gt;              &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;              &lt;version&gt;1.6.11&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.aspectj&lt;/groupId&gt;              &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;              &lt;version&gt;1.6.11&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- spring aop包end --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring end --&gt;  &lt;/dependencies&gt;\n\n插件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;plugins&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;        &lt;version&gt;3.1&lt;/version&gt;        &lt;configuration&gt;            &lt;source&gt;1.8&lt;/source&gt;            &lt;target&gt;1.8&lt;/target&gt;        &lt;/configuration&gt;    &lt;/plugin&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;        &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;9.4.5.v20170502&lt;/version&gt;        &lt;configuration&gt;            &lt;!--开启自动检测配置,默认为0,不改变. 单位为秒 --&gt;            &lt;scanIntervalSeconds&gt;2&lt;/scanIntervalSeconds&gt;            &lt;httpConnector&gt;                &lt;!--配置端口号--&gt;                &lt;port&gt;8080&lt;/port&gt;                &lt;!--空闲超时--&gt;                &lt;idleTimeout&gt;60000&lt;/idleTimeout&gt;            &lt;/httpConnector&gt;            &lt;!--解决静态文件修改后不刷新的问题--&gt;            &lt;!--原因是如果NIO被支持的话，Jetty会使用内存映射文件来缓存静态文件，其中包括.js文件。在Windows下面，使用内存映射文件会导致文件被锁定。解决方案是不使用内存映射文件来做缓存。--&gt;            &lt;!--&lt;webDefaultXml&gt;src/main/resources/webdefault.xml&lt;/webDefaultXml&gt;--&gt;        &lt;/configuration&gt;    &lt;/plugin&gt;        &lt;!-- 自动部署到服务器 --&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;        &lt;configuration&gt;            &lt;port&gt;8080&lt;/port&gt;  &lt;!-- 项目的端口--&gt;            &lt;path&gt;/taskTwo&lt;/path&gt; &lt;!-- web项目的项目名称--&gt;            &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;            &lt;!-- 对应的 tomcat manager的接口--&gt;            &lt;!-- 本地测试 --&gt;            &lt;!--&lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt;--&gt;            &lt;!-- 远程测试 --&gt;            &lt;url&gt;http://45.76.214.173:8080/manager/text&lt;/url&gt;            &lt;server&gt;tomcat7&lt;/server&gt;  &lt;!-- setting.xml 的server id--&gt;            &lt;username&gt;tomcat&lt;/username&gt; &lt;!-- tomcat-user.xml 的 username --&gt;                &lt;password&gt;managerstatus&lt;/password&gt; &lt;!-- tomcat-user,xml 的 password --&gt;        &lt;/configuration&gt;    &lt;/plugin&gt;\n\n资源1234567891011121314151617181920&lt;!--没有这个mapping中的xml文件将不会随着编译被迁移到classes中--&gt;    &lt;resources&gt;      &lt;resource&gt;          &lt;directory&gt;src/main/java&lt;/directory&gt;          &lt;includes&gt;              &lt;include&gt;**/*.xml&lt;/include&gt;              &lt;include&gt;*.properties&lt;/include&gt;          &lt;/includes&gt;          &lt;filtering&gt;true&lt;/filtering&gt;      &lt;/resource&gt;          &lt;resource&gt;          &lt;directory&gt;src/main/resources&lt;/directory&gt;          &lt;includes&gt;              &lt;include&gt;*.xml&lt;/include&gt;              &lt;include&gt;*.properties&lt;/include&gt;          &lt;/includes&gt;          &lt;filtering&gt;true&lt;/filtering&gt;      &lt;/resource&gt;    &lt;/resources&gt;\n\nmaven依赖冲突\n使用Maven依赖时, 依赖id页下方由其依赖包所需的依赖信息, Compile Dependencies, 可以查看其需要的依赖所需的版本\n\n","slug":"Maven-常用配置说明","date":"2017-11-23T05:36:29.000Z","categories_index":"Maven","tags_index":"配置,Maven","author_index":"Weiba"},{"id":"223869ff70cdf67828d0a81df7754b01","title":"注解解析","content":"@SuppressWarnings\n用于抑制编译器产生警告信息。\n示例1——抑制单类型的警告123456@SuppressWarnings(&quot;unchecked&quot;)public void addItems(String item)&#123;    @SuppressWarnings(&quot;rawtypes&quot;)    List items = new ArrayList();    items.add(item);&#125;\n示例2——抑制多类型的警告12345@SuppressWarnings(value=&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public void addItems(String item)&#123;    List items = new ArrayList();    items.add(item);&#125;\n示例3——抑制所有类型的警告12345@SuppressWarnings(&quot;all&quot;)public void addItems(String item)&#123;    List items = new ArrayList();    items.add(item);&#125;\n\n\n\n关键字\n用途\n\n\n\nall\n抑制所有警告\n\n\nboxing\n抑制与箱&#x2F;非装箱操作相关的警告\n\n\ncast\n抑制与铸造操作相关的警告\n\n\ndep-ann\n相对于弃用的注释，抑制警告\n\n\ndeprecation\n抑制相对于弃用的警告\n\n\nfallthrough\n在switch语句中，相对于缺失的中断，抑制警告\n\n\nfinally\n抑制警告相对于最终阻止不返回的警告告\n\n\nhiding\n抑制相对于隐藏变量的局部的警告\n\n\nincomplete-switch\n为了在switch语句（enum案例）中抑制相对于缺失条目的警告告\n\n\nnls\n要抑制相对于非nls字符串字面量的警告\n\n\nnull\n抑制null相关的警告\n\n\nrawtypes\n在类params上使用泛型时，抑制相对于非特异性类型的警告\n\n\nserial\n针对可串行化类，抑制相对于缺少serialVersionUID字段的警告\n\n\nstatic-access\n抑制不正确的静态访问的警告\n\n\nsynthetic-access\n抑制相对于内部类的未优化访问的警告\n\n\nunchecked\n抑制相对于未检查操作的警告\n\n\nunqualified-field-access\n禁止与字段访问不合格的警告\n\n\nunused\n抑制相对于弃用的警告\n\n\ndeprecation\n抑制未使用的代码的警告\n\n\n\n\n@PathVariable\n当使用@RequestMapping URI template 样式映射时， 即 someUrl&#x2F;{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。\n\n@RequestHeader\n可以把Request请求header部分的值绑定到方法的参数上。\n\n@CookieValue\n可以把Request header中关于cookie的值绑定到方法的参数上。\n\n@MatrixVariable 矩阵变量 示例123456//GET /owners/42;q=11/pets/21;q=22@RequestMapping(value = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET)public void findPet(     @MatrixVariable(value = &quot;q&quot;,pathVar=&quot;ownerId&quot;) int q1,     @MatrixVariable(value = &quot;q&quot;,pathVar=&quot;petId&quot;) int q2)&#125;\n此处q1&#x3D;11,q2&#x3D;22.\n@Autowired 与@Resource@Autowire默认按照类型装配，默认情况下它要求依赖对象必须存在如果允许为null，可以设置它required属性为false，如果我们想使用按照名称装配，可以结合@Qualifier注解一起使用; \n@Resource默认按照名称装配，当找不到与名称匹配的bean才会按照类型装配，可以通过name属性指定，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象.注意：如果没有指定name属性，并且按照默认的名称仍然找不到依赖的对象时候，会回退到按照类型装配，但一旦指定了name属性，就只能按照名称装配了.建议使用@Resource。 \n@ReferenceDouble 中 代表资源.\n@Configuration 和 @Bean @Configuration 标注在类上，相当于把该类作为spring的xml配置文件中的 &lt;beans&gt; * 注意不是bean，作用为：配置spring容器(应用上下文)\n@Bean 标注在方法上(返回某个实例的方法)，等价于spring的xml配置文件中的 &lt;bean&gt; ，作用为：注册bean对象\n@Component把普通pojo实例化到spring容器中，相当于配置文件中的  \n\n泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。\n案例： &lt;context:component-scan base-package=”com.*”&gt;\n\n@Value 通过@Value将外部的值动态注入到Bean中. 一般使用在类的属性上.  \n@Value(“测试”) 或 配置文件中 @Value(“${com.neo.username}”)\n导入配置中的中文乱码\nIdea:设置 File Encodings 的 Transparent native-to-ascii conversion 为 true，具体步骤如下：依次点击File -&gt; Settings -&gt; Editor -&gt; File Encodings将 Properties Files (*.properties) 下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。\n还乱码的话, 把文件内容剪切后再粘贴进去 Transparent native-to-ascii conversion 会自动转换编码, 再测试\n@Entity 和 @Table @Entity 标注在类上, 说明这个class是实体类，并且使用默认的orm规则，即class名即数据库表中表名，class字段名即表中的字段名\n如果想改变这种默认的orm规则，就要使用@Table来改变class名与数据库中表名的映射规则，@Column来改变class中字段名与db中表的字段名的映射规则\n\n\n\n注解\n作用\n默认值\n\n\n\n@Id\n主键\n\n\n\n@GeneratedValue\n主键生成策略\nAUTO\n\n\n@TableGenerator\n主键表\n\n\n\n@Column\n标识实体类中属性与数据表中字段的对应关系\n\n\n\n2018-6-21 \n@EnableCachingSpring 3开始提供的通过注解开启缓存功能\n@ModelAttribute 具有如下三个作用：①绑定请求参数到命令对象：放在功能处理方法的入参上时，用于将多个请求参数绑定到一个命令对象，从而简化绑定流程，而且自动暴露为模型数据用于视图页面展示时使用。其实@ModelAttribute此处对于供视图页面展示来说与model.addAttribute(“attributeName”, abc);功能类似。\n1public String test(@ModelAttribute(&quot;user&quot;) UserModel user) \n\n此处多了一个注解@ModelAttribute(“user”)，它的作用是将该绑定的命令对象以“user”为名称添加到模型对象中供视图页面展示使用。我们此时可以在视图页面使用${user.username}来获取绑定的命令对象的属性。\n②暴露@RequestMapping 方法返回值为模型数据：放在功能处理方法的返回值上时，是暴露功能处理方法的返回值为模型数据，用于视图页面展示时使用。\n1public @ModelAttribute(&quot;user2&quot;) UserModel test3(@ModelAttribute(&quot;user2&quot;) UserModel user)\n\n大家可以看到返回值类型是命令对象类型，而且通过@ModelAttribute(“user2”)注解，此时会暴露返回值到模型数据（ 名字为user2 ） 中供视图展示使用\n@ModelAttribute 注解的返回值会覆盖@RequestMapping 注解方法中的@ModelAttribute 注解的同名命令对象\n③暴露表单引用对象为模型数据：放在处理器的一般方法（非功能处理方法）上时，是为表单准备要展示的表单引用对象，如注册时需要选择的所在城市等，而且在执行功能处理方法（@RequestMapping 注解的方法）之前，自动添加到模型对象中，用于视图页面展示时使用\n@Optionsmybatis的@Options注解能够设置缓存时间，能够为对象生成自增的key\n@Options(useGeneratedKeys = true, keyProperty = &quot;instanceId&quot;, keyColumn = &quot;instance_id&quot;)\n@Options注解中默认设置的主键对应的字段名为id、在我们的表中，主键名为instance_id，因此需要将keyProperty和keyColumn设置成我们想要的字段：\n这个注解的意思就是，从instance_id这个字段里面把数据放到传入对象的instanceId成员变量里面。\n注解中的useCache还可以设置缓存相关的选项：\n123useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\n\n@Paramdao层示例\n1Public User selectUser(@param(“userName”) String name,@param(“userpassword”) String password);\n\nxml映射对应示例\n123&lt;select id=&quot; selectUser&quot; resultMap=&quot;BaseResultMap&quot;&gt;     select  *  from user_user_t   where user_name = #&#123;userName，jdbcType=VARCHAR&#125; and user_password=#&#123;userPassword,jdbcType=VARCHAR&#125;  &lt;/select&gt;\n\n注意：采用#{}的方式把@Param注解括号内的参数进行引用（括号内参数对应的是形参如 userName对应的是name）；\n@Param注解JavaBean对象\ndao层示例\n1public List&lt;user&gt; getUserInformation(@Param(&quot;user&quot;) User user);\n\nxml映射对应示例\n12345678&lt;select id=&quot;getUserInformation&quot; parameterType=&quot;com.github.demo.vo.User&quot; resultMap=&quot;userMapper&quot;&gt;          select           &lt;include refid=&quot;User_Base_Column_List&quot; /&gt;          from mo_user t where 1=1                        &lt;!-- 因为传进来的是对象所以这样写是取不到值得 --&gt;              &lt;if test=&quot;user.userName!=null  and user.userName!=&#x27;&#x27;&quot;&gt;   and   t.user_name = #&#123;user.userName&#125;  &lt;/if&gt;              &lt;if test=&quot;user.userAge!=null  and user.userAge!=&#x27;&#x27;&quot;&gt;   and   t.user_age = #&#123;user.userAge&#125;  &lt;/if&gt;      &lt;/select&gt;  \n不使用@Param注解来声明参数时\n\n必须使用使用 #{}方式。如果使用 ${} 的方式，会报错。\n\n当参数只能有一个，并且是Javabean。在SQL语句里可以引用JavaBean的属性，而且只能引用JavaBean的属性。\n\n\nuseGeneratedKeys 参数\n@Options(useGeneratedKeys = true, keyProperty = &quot;instanceId&quot;, keyColumn = &quot;instance_id&quot;) int addInstance(Instance instance);\n@Options(useGeneratedKeys=true) 获取新添加记录的自增长主键字段值\nkeyProperty &#x3D; “instanceId” 对应实体类属性\nkeyColumn &#x3D; “instance_id” 对应数据库属性\n这句的意思是 添加的时候将插入后生成的主键 instance_id 值自动写入到实体类instanceId 中. 注意不是返回. 是写入到实体类的属性中了, 取的话需要去 Instance.getinstanceId() 去取.\n@Transactional开启事务注解\n配合 @Rollback : 回滚, 方法执行完成后回滚数据, 不写入数据库, 做测试用\n配合 @Commit : 提交, 提交后数据写入数据库\n@Results对返回的多个结果如List进行绑定, \n123456@Results(        &#123;            @Result(property = &quot;name&quot;, column = &quot;age&quot;),            @Result(property = &quot;age&quot;, column = &quot;age&quot;)        &#125;)","slug":"注解解析","date":"2017-10-13T04:43:05.000Z","categories_index":"注解","tags_index":"注解","author_index":"Weiba"},{"id":"df45be00e9070baa034fc74ef3a965fd","title":"Spring 添加Redis支持","content":"Maven 包1234567891011121314&lt;!-- redis --&gt;    &lt;!-- redis 驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;/groupId&gt;        &lt;artifactId&gt;jedis&lt;/artifactId&gt;        &lt;version&gt;2.9.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring redis数据支持包 spring-data-redis 2.0后版本只支持spring5和spring boot2 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;        &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;        &lt;version&gt;1.8.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;!-- redis end --&gt;\n依赖冲突\n在mavne仓库里面,查找你的jar相关的版本\n\n\n\n\n\n\n\n\n地址: http://mvnrepository.com/点开相关版本,查看Compile Dependencies 列表,会显示此包所依赖的相关版本信息.\n\nspring-data-redis依赖\n\n\n\n\n\n\n\n\n其最低的spring依赖版本为4.3.10.RELEASE,将spring版本升级到到4.3.10\n\n升级spring版本后AOP的依赖又出现了问题. 心累\n\n\n\n\n\n\n\n\n报错异常 :Expected raw type form of org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\n\n原因是spring 4.3.10以上 aspectJ 版本必须高于1.8.9, 我升级到1.8.11正常.\n\n配置\nredis连接配置 redis.properties\n\n\n\n\n\n\n\n\nredis.host&#x3D;127.0.0.1redis.port&#x3D;6379redis.pass&#x3D;redis.maxIdle&#x3D;300redis.maxWait&#x3D;1000redis.testOnBorrow&#x3D;true  \n\n添加redis spring配置 &#96;applicationContenxt-redis.xml\n导入redis连接配置 \n1&lt;context:property-placeholder location=&quot;WEB-INF/config/other/redis.properties&quot;/&gt;\n报错 Could not resolve placeholder 参考连接  \n\n\n\n\n\n\n\n\n\n因为使用了多个PropertyPlaceholderConfigurer或者多个context:property-placeholder的原因。一定要记住，不管是在一个Spring文件还是在多个Spring文件被统一load的情况下，直接写多个都是不允许的. \n\n解决方法\n\n解决方法一, 定义一个全局context导入不同配置  1234567&lt;context-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;              WEB-INF/config/spring/dao.xml,               WEB-INF/config/spring/dfs.xml      &lt;/param-value&gt;  &lt;/context-param&gt;  \n解决方法二, 每资源导入时都要加上ignore-unresolvable=&quot;true&quot;参数，一个加另一个不加也是不行的12345678910111213   &lt;context:property-placeholder location=&quot;xxx.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;     &lt;context:property-placeholder location=&quot;yyy.properties&quot; ignore-unresolvable=&quot;true&quot; /&gt;  - 注入连接池配置  [testOnBorrow作用](https://blog.csdn.net/wangyangzhizhou/article/details/52209336)  ```xml  &lt;!-- 注入连接池配置 --&gt;  &lt;bean id=&quot;redis-config&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;     &lt;!-- 最大空闲数 --&gt;     &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;redis.maxIdle&#125;&quot;/&gt;     &lt;!-- 最大等待时间 --&gt;     &lt;property name=&quot;maxWaitMillis&quot; value=&quot;$&#123;redis.maxWait&#125;&quot;/&gt;     &lt;!-- 是否检测连接池的可用性 --&gt;     &lt;property name=&quot;testOnBorrow&quot; value=&quot;$&#123;redis.testOnBorrow&#125;&quot;/&gt;  &lt;/bean&gt;\n  参考连接\n\n\n\n\n\n","slug":"Spring 添加Redis支持","date":"2017-05-26T04:44:58.000Z","categories_index":"Spring","tags_index":"Redis,Spring","author_index":"Weiba"},{"id":"eaa00d865cbf6795dd0a46e06ef96cc9","title":"Spring配置","content":"的 id 和 name 属性区别\n配置一个bean的时候，我们可以不设置id，也可以不设置name，spring默认会使用类的全限定名作为bean的标识符。1&lt;bean class=&quot;net.aty.spring.ioc.first.C1&quot;&gt;&lt;/bean&gt; \n1234// 没有设置id,也没有设置name, 默认用类的全限定名  boolean same = ctx.getBean(C1.class) == ctx.getBean(C1.class          .getCanonicalName());  System.out.println(same);//true  \n如果使用id属性来设置bean的标识符，那么id在spring容器中必需唯一。\n如果使用name属性来设置，那么设置的其实就是bean的标识符，必需在容器中唯一。1&lt;bean name=&quot;c1&quot; class=&quot;net.aty.spring.ioc.first.C1&quot;&gt;&lt;/bean&gt;  \n1234ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(          &quot;first-spring.xml&quot;);  System.out.println(ctx.getBean(&quot;c1&quot;,C1.class));  ctx.close();  \n如果同时设置id和name，那么id设置的是标识符，name设置的是别名。1&lt;bean id=&quot;cid&quot; name=&quot;alias1&quot; class=&quot;net.aty.spring.ioc.first.C1&quot;&gt;&lt;/bean&gt;  \n12345678910ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(          &quot;first-spring.xml&quot;);    String[] alias = ctx.getAliases(&quot;cid&quot;);    for (String e : alias) &#123;      System.out.println(e);//alias1  &#125;    ctx.close(); \n如果id和name的值相同，那么spring容器会自动检测并消除冲突：让这个bean只有标识符，而没有别名。1&lt;bean id=&quot;cid&quot; name=&quot;cid&quot; class=&quot;net.aty.spring.ioc.first.C1&quot;&gt;&lt;/bean&gt;  \n12345678ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(          &quot;first-spring.xml&quot;);    String[] alias = ctx.getAliases(&quot;cid&quot;);    System.out.println(alias.length);//0    ctx.close();  \nname属性设置多个值。不设置id，那么第一个被用作标识符，其他的被视为别名。如果设置了id，那么name的所有值都是别名。1&lt;bean name=&quot;a1,a2,a3&quot; class=&quot;net.aty.spring.ioc.first.C1&quot;&gt;&lt;/bean&gt;  \n12345678ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(          &quot;first-spring.xml&quot;);    String[] alias = ctx.getAliases(&quot;a1&quot;);    System.out.println(Arrays.toString(alias));//[a2, a3]    ctx.close();  \n\n注意：不管是标识符，还是别名，在容器中必需唯一。因为标识符和别名，都是可以用来获取bean的，如果不唯一，显然不知道获取的到底是哪儿一个bean。\n使用标签指定别名，别名也必须在IoC容器中唯一。123&lt;bean id=&quot;c1&quot; class=&quot;net.aty.spring.ioc.first.C1&quot;&gt;&lt;/bean&gt;  &lt;alias name=&quot;c1&quot; alias=&quot;1&quot;/&gt;  &lt;alias name=&quot;c1&quot; alias=&quot;2&quot;/&gt;  \n12345678ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(          &quot;first-spring.xml&quot;);    String[] alias = ctx.getAliases(&quot;c1&quot;);    System.out.println(Arrays.toString(alias));//[1,2]    ctx.close(); \n\n总结: 标识符和别名没有任何区别，所以id和name属性唯一的差别在于：id只能设置一个标识符，而name可以设置多个标识符123&lt;bean id=&quot;c1&quot; class=&quot;net.aty.spring.ioc.first.C1&quot;&gt;&lt;/bean&gt;  &lt;alias name=&quot;c1&quot; alias=&quot;1&quot;/&gt;  &lt;alias name=&quot;c1&quot; alias=&quot;2&quot;/&gt;  \n123456System.out.println(Arrays.toString(ctx.getAliases(&quot;c1&quot;)));//[1,2]  System.out.println(Arrays.toString(ctx.getAliases(&quot;1&quot;)));//[c1,2]  System.out.println(Arrays.toString(ctx.getAliases(&quot;2&quot;)));//[c1,1]    System.out.println(ctx.getBean(&quot;c1&quot;) == ctx.getBean(&quot;1&quot;));//true  System.out.println(ctx.getBean(&quot;c1&quot;) == ctx.getBean(&quot;2&quot;));//true  \n配置静态资源后出现异常\n异常信息\n\n\n\n\n\n\n\n\n Failed to convert from type [java.util.ArrayList] to type [java.util.List] for value '[/WEB-INF/static/]'; nested exception is org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting from type [java.util.ArrayList] to type [org.springframework.core.io.Resource]\n\n原因\nbean id冲突\n同时配置了静态资源 &lt;mvc:resources&gt; 其默认bean id为 conversionService  \nspring自动参数绑定并且其bian id为 &lt;bean id=&quot;conversionServiceCustom&quot;&gt;.\n\n\n\n","slug":"Spring 配置","date":"2017-05-23T04:46:18.000Z","categories_index":"Spring","tags_index":"配置,Spring","author_index":"Weiba"}]