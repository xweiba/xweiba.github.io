{"title":"JVM类加载机制","uid":"696f58cc973f75c60837976660da7ceb","slug":"JVM类加载机制","date":"2022-12-29T05:17:00.000Z","updated":"2025-04-30T08:11:18.849Z","comments":true,"path":"api/articles/JVM类加载机制.json","keywords":null,"cover":[],"content":"<h1 id=\"类加载全过程\"><a href=\"#类加载全过程\" class=\"headerlink\" title=\"类加载全过程\"></a>类加载全过程</h1><p>当我们使用Java命令启动一个类的main()方法时，首先需要通过类加载器将主类加载到JVM中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.weiba.jvm;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Math</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">initData</span> <span class=\"operator\">=</span> <span class=\"number\">666</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compute</span><span class=\"params\">()</span> &#123;  <span class=\"comment\">//一个方法对应一块栈帧内存区域</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (a + b) * <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Math</span> <span class=\"variable\">math</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Math</span>();</span><br><span class=\"line\">        math.compute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"通过Java命令执行代码的大体流程\"><a href=\"#通过Java命令执行代码的大体流程\" class=\"headerlink\" title=\"通过Java命令执行代码的大体流程\"></a>通过Java命令执行代码的大体流程</h2><img src=\"/post/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20221229143200062.png\" class=\"\" title=\"image-20221229143200062\">\n\n<h2 id=\"loadClass-加载过程\"><a href=\"#loadClass-加载过程\" class=\"headerlink\" title=\"loadClass 加载过程\"></a>loadClass 加载过程</h2><h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>在硬盘上查找并通过IO读取字节码文件，<strong>使用到类时才会加载，例如调用类的main()方法，new对象等等</strong>。在加载阶段会在<strong>宿主机内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>效验字节码文件的的正确性，如class文件内容依次应该为：<strong>CAFEBABE(魔数)，副版本号，主版本号，常量池计数器，常量池区域，类信息等等</strong>。</p>\n<img src=\"/post/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/10812.png\" class=\"\" title=\"img\">\n\n<h4 id=\"Class文件结构参照表\"><a href=\"#Class文件结构参照表\" class=\"headerlink\" title=\"Class文件结构参照表\"></a>Class文件结构参照表</h4><img src=\"/post/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/10780.png\" class=\"\" title=\"img\">\n\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>给类的静态变量分配内存，并赋予默认值。</p>\n<p><strong>静态变量：基础类型如int为0，boolean为false，对象为null。</strong></p>\n<p><strong>静态常量：用字面量进行显示赋值，字面量（保存在常量池中） 可以认为是有确定值的基本数据类型，还有具有确定值的string。</strong></p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>将<strong>符号引用（静态方法如main()）</strong>替换为<strong>直接引用（内存地址）</strong>，该阶段会把一些静态方法替换为指向数据所存内存的指针或句柄。这就是所谓的<strong>静态链接（类加载期间完成）</strong>过程，<strong>动态链接</strong>是程序在运行期间将<strong>符号引用</strong>替换为<strong>直接引用</strong>。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>对类的静态变量初始化为指定的值。</li>\n<li>执行静态代码块。</li>\n</ul>\n<img src=\"/post/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/102279.png\" class=\"\" title=\"img\">\n\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>类被加载至方法区后主要包含：<strong>运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应Class实例的引用等</strong>信息。</p>\n<h3 id=\"类加载器的引用\"><a href=\"#类加载器的引用\" class=\"headerlink\" title=\"类加载器的引用\"></a>类加载器的引用</h3><p>这个类加载时使用的类加载器。</p>\n<h3 id=\"对应Class实例的引用\"><a href=\"#对应Class实例的引用\" class=\"headerlink\" title=\"对应Class实例的引用\"></a>对应Class实例的引用</h3><p>类加载器在加载类信息放到方法区后，会<strong>创建一个对应的Class类型的对象实例放到堆中</strong>，作为开发人员访问方法区中类定义的入口和切入点。</p>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p><strong>注意：同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个。</strong></p>\n<h3 id=\"引导类加载器（BootStrapClassLoader）\"><a href=\"#引导类加载器（BootStrapClassLoader）\" class=\"headerlink\" title=\"引导类加载器（BootStrapClassLoader）\"></a>引导类加载器（BootStrapClassLoader）</h3><p><strong>负责加载JRE下lib目录的核心类库。</strong></p>\n<h3 id=\"扩展类加载器器（ExtClassLoader）\"><a href=\"#扩展类加载器器（ExtClassLoader）\" class=\"headerlink\" title=\"扩展类加载器器（ExtClassLoader）\"></a>扩展类加载器器（ExtClassLoader）</h3><p><strong>负责加载JRE下lib目录中ext扩展文件夹中的类库。</strong></p>\n<h3 id=\"应用类加载器（APPClassLoader）\"><a href=\"#应用类加载器（APPClassLoader）\" class=\"headerlink\" title=\"应用类加载器（APPClassLoader）\"></a>应用类加载器（APPClassLoader）</h3><p><strong>负责加载classPath路径下的类库，主要是加载我们直接写的和导入的依赖包。</strong></p>\n<h3 id=\"自定义类加载器\"><a href=\"#自定义类加载器\" class=\"headerlink\" title=\"自定义类加载器\"></a>自定义类加载器</h3><p><strong>自己定义的类加载器，自己管理，如Tomcat打破双亲委派的自定义类加载器，实现各个路径下的class隔离。</strong></p>\n<p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是loadClass(String, boolean)，实现了<strong>双亲委派机制</strong>，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是<strong>重写findClass方法</strong>。</p>\n<h3 id=\"全盘负责委托机制\"><a href=\"#全盘负责委托机制\" class=\"headerlink\" title=\"全盘负责委托机制\"></a>全盘负责委托机制</h3><p><strong>全盘负责委托机制是指当一个ClassLoader装载一个类时，除非显式的使用另一个ClassLoader，该类所有依赖的及引用的类都使用这个ClassLoader载入。</strong></p>\n<h2 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><img src=\"/post/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/102278.png\" class=\"\" title=\"img\">\n\n<p><strong>一个类在加载时，会先找这个类加载器的父类，看是否为空，不为空继续它类加载器的父类，直到没有父类。在找到后会先判断有没有加载过这个，找到直接返回，没有找到返回子类加载器查找，直到返回到自己的类加载器，开始真正的加载</strong>。</p>\n<h3 id=\"为什么要设计双亲委派机制？\"><a href=\"#为什么要设计双亲委派机制？\" class=\"headerlink\" title=\"为什么要设计双亲委派机制？\"></a>为什么要设计双亲委派机制？</h3><ul>\n<li><strong>沙箱安全机制：自定义的java.lang.String.class类不会被加载，这样可以防止核心类库被篡改。</strong></li>\n<li><strong>防止类的重复加载：当父类已经加载了该类，子类就没有必要再加载一次了，保证被加载类的唯一性。</strong></li>\n</ul>\n<h1 id=\"JVM级别类加载全过程\"><a href=\"#JVM级别类加载全过程\" class=\"headerlink\" title=\"JVM级别类加载全过程\"></a>JVM级别类加载全过程</h1><img src=\"/post/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/106918.png\" class=\"\" title=\"img\">","text":"类加载全过程当我们使用Java命令启动一个类的main()方法时，首先需要通过类加载器将主类加载到JVM中。 1234567891011121314151617...","permalink":"/post/JVM类加载机制","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"JVM","slug":"JVM","count":1,"path":"api/categories/JVM.json"}],"tags":[{"name":"原理","slug":"原理","count":1,"path":"api/tags/原理.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">类加载全过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87Java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">通过Java命令执行代码的大体流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#loadClass-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">loadClass 加载过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">加载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">验证</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%8F%82%E7%85%A7%E8%A1%A8\"><span class=\"toc-text\">Class文件结构参照表</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%86%E5%A4%87\"><span class=\"toc-text\">准备</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">解析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">初始化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA\"><span class=\"toc-text\">方法区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">类加载器的引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E5%BA%94Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">对应Class实例的引用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">类加载器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88BootStrapClassLoader%EF%BC%89\"><span class=\"toc-text\">引导类加载器（BootStrapClassLoader）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%99%A8%EF%BC%88ExtClassLoader%EF%BC%89\"><span class=\"toc-text\">扩展类加载器器（ExtClassLoader）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88APPClassLoader%EF%BC%89\"><span class=\"toc-text\">应用类加载器（APPClassLoader）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">自定义类加载器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E7%9B%98%E8%B4%9F%E8%B4%A3%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">全盘负责委托机制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">双亲委派机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">为什么要设计双亲委派机制？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM%E7%BA%A7%E5%88%AB%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">JVM级别类加载全过程</span></a></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"JVM-垃圾收集算法解析","uid":"347757ce9e70573368e0803b807e225c","slug":"JVM-垃圾收集算法解析","date":"2022-12-30T02:27:17.000Z","updated":"2025-04-30T08:11:18.848Z","comments":true,"path":"api/articles/JVM-垃圾收集算法解析.json","keywords":null,"cover":[],"text":"垃圾收集算法 分代收集理论当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是通过对象存活周期的不同将内存分为几块。一般将JAVA堆分为新生代...","permalink":"/post/JVM-垃圾收集算法解析","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"GC","slug":"GC","count":1,"path":"api/categories/GC.json"}],"tags":[{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"},{"name":"GC","slug":"GC","count":1,"path":"api/tags/GC.json"},{"name":"CMS","slug":"CMS","count":1,"path":"api/tags/CMS.json"},{"name":"ParNew","slug":"ParNew","count":1,"path":"api/tags/ParNew.json"},{"name":"三色标记","slug":"三色标记","count":1,"path":"api/tags/三色标记.json"},{"name":"内存屏障","slug":"内存屏障","count":1,"path":"api/tags/内存屏障.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"注册中心服务真实IP获取脚本","uid":"b6c44ddff928c2bc54e5fe634d621a85","slug":"注册中心服务真实IP获取脚本","date":"2022-12-26T05:58:09.000Z","updated":"2025-04-30T08:11:18.902Z","comments":true,"path":"api/articles/注册中心服务真实IP获取脚本.json","keywords":null,"cover":null,"text":"由于部分同事在测试环境启服务时常常不改服务名称且ip直接配置成localhost，导致很多服务调用时会连接异常，但又找不到人，为此我写了一个脚本来定位服务的真实...","permalink":"/post/注册中心服务真实IP获取脚本","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"Shell","slug":"Shell","count":2,"path":"api/categories/Shell.json"}],"tags":[{"name":"Shell","slug":"Shell","count":5,"path":"api/tags/Shell.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}