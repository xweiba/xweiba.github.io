{"title":"Java-高级-Day-5-JVM性能优化","uid":"74b4ce53d861aece862753ca4c35dd9e","slug":"Java-高级-Day-5-JVM性能优化","date":"2025-04-27T08:23:22.000Z","updated":"2025-04-30T08:11:18.860Z","comments":true,"path":"api/articles/Java-高级-Day-5-JVM性能优化.json","keywords":null,"cover":[],"content":"<h1 id=\"核心点\"><a href=\"#核心点\" class=\"headerlink\" title=\"核心点\"></a>核心点</h1><ul>\n<li>所有优化都要根据实际服务的具体业务场景做优化配置，没有通用的配置。</li>\n<li>GC 优化目标：<strong>降低 <code>full gc</code> 产生的 <code>STW </code>,让短期存活的对象尽量都留在 <code>survivor</code>里，不要进入老年代，这样在<code>minor gc</code>的时候这些对象都会被回收，不会进到老年代从而导致<code>full gc</code>。让长期存活的对象尽早进入老年代，不要占用年轻代空间。</strong></li>\n<li>缓存类等需要大量对象长期存活的服务，老年代要够大。</li>\n<li><strong>非缓存服务且压力比较大的服务，比如订单服务</strong>，年轻代一定要大一点，年轻代过小会导致下面的问题：<ul>\n<li>Survivor区空间不足：如果年轻代设置过小，Survivor区空间紧张，可能导致对象在未达到 <code>MaxTenuringThreshold</code> 之前就被迫晋升。</li>\n<li>垃圾回收频率过高：频繁的<code>minor gc</code>会导致对象年龄增长加快，可能在Survivor区中快速累积到触发条件。</li>\n<li>触发对象动态年龄判断：<strong>如果某一年龄的对象总大小超过了Survivor区的50%，那么所有大于等于该年龄的对象会被直接晋升到老年代。</strong><ul>\n<li>短生命周期对象过多：如果应用中有大量短时间内创建并消亡的对象，这些对象可能在Survivor区快速积累，超过50%的阈值，触发动态年龄判断，导致晋升。</li>\n<li>对象大小分布不均：如果某类对象的大小突然增加，或者同一批对象同时达到某个年龄，可能突然超过Survivor区的50%，引发晋升。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>让全局对象尽早进入老年代不要占用年轻代空间：减少默认的分代年龄配置，根据实际观察来配置，一般5左右, 可以设置：<code>‐XX:MaxTenuringThreshold=5</code></li>\n<li>让大对象直接进入老年代，系统内的缓存对象或全局对象，一般都比较大，且需要长期存活，可以设置 <code>‐XX:PretenureSizeThreshold=1M</code><ul>\n<li>注意要根据实际业务对象大小去设置。</li>\n</ul>\n</li>\n<li>老年代空间分配担保机制: <strong>老年代最大可用连续空间是否大于新生代所有对象总大小，如果大于，则Minor GC可以确保安全, 执行Minor GC.</strong></li>\n<li>对延时敏感的服务可以使用CMS(并发-标记-清理)垃圾收集器<ul>\n<li>CMS: 并发标记清理，也就是执行后内存是不连续的，需要进行碎片整理。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>Arthas</p>\n<ul>\n<li>dashboard: 整个进程的运行情况，线程、内存、GC、运行环境信息</li>\n<li>thread: 查看线程详细情况<ul>\n<li>thread加上线程ID 可以查看线程堆栈</li>\n<li>thread -b 可以查看线程死锁</li>\n</ul>\n</li>\n<li>jad加类的全名 可以反编译，这样可以方便我们查看线上代码是否是正确的版本</li>\n<li>ognl 可以查看线上系统变量的值，也可以修改变量的值</li>\n<li>watch <code>类的完整限定名 方法</code> 可以查看方法的入参和返回值</li>\n<li>trace <code>类的完整限定名 方法</code> 可以查看方法执行的</li>\n</ul>\n<h2 id=\"GC-优化\"><a href=\"#GC-优化\" class=\"headerlink\" title=\"GC 优化\"></a>GC 优化</h2><p>环境：4核3G，每秒300请求，每个请求平均纯业务实体数据15Kb，对其转为对象进行处理还有其他对象生成 5Kb和其他因素扩大10倍， 每秒生成对象：(15Kb+5Kb) * 10 * 300 个答案对象，60MB&#x2F;s</p>\n<p>未优化：</p>\n<ul>\n<li>年轻代1GB(eden:800MB s0:100MB s1:100MB)   老年代 2GB</li>\n<li>** 15s 左右撑满Eden区，注意s区只有100MB，对象动态年龄判断阈值在50MB**</li>\n<li>**压力很大的服务，资源是很紧缺的，接口的对象可能会堆积，那Eden满了在 Minor GC 时，有大几率进入s区的对象回超过50MB, 那么所有大于等于该年龄的对象会被直接晋升到老年代，会频繁触发 <code>full gc</code> **</li>\n</ul>\n<p>优化：</p>\n<ul>\n<li><p>年轻代2GB(eden:800MB s0:200MB s1:200MB)   老年代 1GB</p>\n</li>\n<li><p>压力较大的业务系统，90% 应该都是临时对象，要确保他们在年轻代就被销毁。</p>\n</li>\n<li><p>全局对象1GB如果不够，那就需要提高配置了。</p>\n</li>\n<li><p>本例中一次minor gc要间隔二三十秒，大多数对象一般在几秒内就会变为垃圾，完全可以将默认的15岁改小一点，比如改为5，那么意味着对象要经过5次minor gc才会进入老年代，整个时间也有一两分钟了，如果对象这么长时间都没被回收，完全可以认为这些对象是会存活的比较长的对象，可以移动到老年代，而不是继续一直占用survivor区空间。</p>\n</li>\n<li><p>对于多大的对象直接进入老年代(参数-XX:PretenureSizeThreshold)，这个一般可以结合你自己系统看下有没有什么大对象生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始化分配的缓存对象，比如大的缓存List，Map之类的对象</p>\n</li>\n<li><p>对于JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)，如果内存较大(超过4个G，只是经验<br>值)，系统对停顿时间比较敏感，我们可以使用ParNew+CMS(-XX:+UseParNewGC -XX:+UseConcMarkSweepGC)</p>\n<ul>\n<li><p>老年代CMS的参数如何设置？</p>\n<ul>\n<li><p>首先我们想下当前这个系统有哪些对象可能会长期存活躲过5次以上<code>minor gc</code> 最终进入老年代：<code>Spring容器里的Bean，线程池对象，一些初始化缓存数据对象等，这些加起来充其量也就几十MB。</code></p>\n</li>\n<li><p>如果突然某一秒瞬间要处理五六百请求，那么每秒生成的对象可能有一百多M，再加上整个系统可能压力剧增，一个请求要好几秒才能处理完，下一秒可能又有很多订单过来，那么就会直接进入老年代。我们可以估算下大概每隔五六分钟出现一次这样的情况，那么大概半小时到一小时之间就可能因为老年代满了触发一次 <code>Full GC</code>，<code>Full GC</code>的触发条件还有我们之前说过的<strong>老年代空间分配担保机制</strong>，历次的 <code>minor gc</code> 挪动到老年代的对象大小肯定是非常小的，所以几乎不会在 <code>minor gc</code> 触发之前由于老年代空间分配担保失败而产生 <code>full gc</code>，其实在半小时后发生 <code>full gc</code>，这时候已经过了交卷的最高峰期，后续可能几小时才做一次 <code>FullGC</code>。</p>\n</li>\n<li><p>对于碎片整理，因为都是1小时或几小时才做一次 <code>FullGC</code> ，是可以每做完一次就开始碎片整理，或者两到三次之后再做一次也行。<br>综上，只要年轻代参数设置合理，老年代CMS的参数设置基本都可以用默认值，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">‐Xms3072M ‐Xmx3072M ‐Xmn2048M ‐Xss1M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:SurvivorRatio=8</span><br><span class=\"line\">2 ‐XX:MaxTenuringThreshold=5 ‐XX:PretenureSizeThreshold=1M ‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC</span><br><span class=\"line\">3 ‐XX:CMSInitiatingOccupancyFraction=92 ‐XX:+UseCMSCompactAtFullCollection ‐XX:CMSFullGCsBeforeCompaction=0</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"详细解析\"><a href=\"#详细解析\" class=\"headerlink\" title=\"详细解析\"></a>详细解析</h1><img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-5-JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/94575.png\" class=\"\" title=\"img\">\n\n","feature":true,"text":"核心点 所有优化都要根据实际服务的具体业务场景做优化配置，没有通用的配置。 GC 优化目标：降低 full gc 产生的 STW ,让短期存活的对象尽量都留在 ...","permalink":"/post/Java-高级-Day-5-JVM性能优化","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E7%82%B9\"><span class=\"toc-text\">核心点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GC-%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">GC 优化</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">详细解析</span></a></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java-基于Redis的高性能任务队列设计与实现","uid":"6456b03f672a87198a79af9e60f25dff","slug":"Java-基于Redis的高性能任务队列设计与实现","date":"2025-04-29T09:19:39.000Z","updated":"2025-04-30T08:11:18.852Z","comments":true,"path":"api/articles/Java-基于Redis的高性能任务队列设计与实现.json","keywords":null,"cover":null,"text":"我们早期2.0系统交卷是同步提交，交一笔写一笔，还要做各种逻辑处理，通知其他服务修改活动状态，在班级考试里还能用，只是慢，qps不超50, 后来需要支持年级考试...","permalink":"/post/Java-基于Redis的高性能任务队列设计与实现","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"},{"name":"请求合并","slug":"请求合并","count":1,"path":"api/tags/请求合并.json"},{"name":"Redis阻塞队列","slug":"Redis阻塞队列","count":1,"path":"api/tags/Redis阻塞队列.json"},{"name":"任务队列","slug":"任务队列","count":1,"path":"api/tags/任务队列.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Java-高级-Day-4-GC垃圾收集算法","uid":"55e262e45820c6fc0e5602715c3359d4","slug":"Java-高级-Day-4-GC垃圾收集算法","date":"2025-04-24T05:26:47.000Z","updated":"2025-04-30T08:11:18.858Z","comments":true,"path":"api/articles/Java-高级-Day-4-GC垃圾收集算法.json","keywords":null,"cover":[],"text":"核心点分代收集理论 新升代：复制算法，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法 老年代：“标记-清除”或“标记-整理”算法，对象存活几率是比...","permalink":"/post/Java-高级-Day-4-GC垃圾收集算法","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}