{"title":"Mysql-事务与MVCC","uid":"3ea889d0200adbef6f577008a7289f16","slug":"Mysql-事务与MVCC","date":"2025-04-30T04:20:26.000Z","updated":"2025-04-30T08:11:18.862Z","comments":true,"path":"api/articles/Mysql-事务与MVCC.json","keywords":null,"cover":null,"content":"<h1 id=\"Mysql-ACID-特性\"><a href=\"#Mysql-ACID-特性\" class=\"headerlink\" title=\"Mysql ACID 特性\"></a>Mysql ACID 特性</h1><ul>\n<li>原子性: 事务是最小的执行单位，不允许分割。要么全部成功，要么全部失败。</li>\n<li>一致性: 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；比如转账：我给你转100，我原来是100，你是0，总数100，执行完毕后总数还是100.</li>\n<li>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ul>\n<p>AID 是手段 D是目标。</p>\n<h1 id=\"Mysql-事务隔离级别，都是事务执行过程中查询数据的限制和结果\"><a href=\"#Mysql-事务隔离级别，都是事务执行过程中查询数据的限制和结果\" class=\"headerlink\" title=\"Mysql 事务隔离级别，都是事务执行过程中查询数据的限制和结果\"></a>Mysql 事务隔离级别，都是事务执行过程中查询数据的限制和结果</h1><h2 id=\"READ-UNCOMMITTED：读未提交\"><a href=\"#READ-UNCOMMITTED：读未提交\" class=\"headerlink\" title=\"READ UNCOMMITTED：读未提交\"></a>READ UNCOMMITTED：读未提交</h2><p>可以看到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读。</p>\n<h1 id=\"READ-COMMITTED：读已提交（MVCC）。\"><a href=\"#READ-COMMITTED：读已提交（MVCC）。\" class=\"headerlink\" title=\"READ COMMITTED：读已提交（MVCC）。\"></a>READ COMMITTED：读已提交（MVCC）。</h1><p>能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读。事务过程中每次查询的都是已提交的最新数据。</p>\n<h1 id=\"REPEATABLE-READ：可重复读-默认-MVCC\"><a href=\"#REPEATABLE-READ：可重复读-默认-MVCC\" class=\"headerlink\" title=\"REPEATABLE READ：可重复读(默认)(MVCC)\"></a>REPEATABLE READ：可重复读(默认)(MVCC)</h1><p>每次查询的都是当前事务开始前的数据快照，因此查询不会出现不一样的情况，解决了不可重复读问题。</p>\n<p>但如果其他事务新增&#x2F;删除了数据，它再查询，会查询到新的</p>\n<p>注意：幻读和不可重复读的侧重点是不同的，不可重复读侧重于数据修改，两次读取到的同一行数据不一样；而幻读侧重于添加或删除，两次查询返回的数据行数不同。</p>\n<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p>\n<h1 id=\"SERIALIZABLE：序列化-锁\"><a href=\"#SERIALIZABLE：序列化-锁\" class=\"headerlink\" title=\"SERIALIZABLE：序列化(锁)\"></a>SERIALIZABLE：序列化(锁)</h1><p>事务最高隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。</p>\n<h1 id=\"事务并发控制方式\"><a href=\"#事务并发控制方式\" class=\"headerlink\" title=\"事务并发控制方式\"></a>事务并发控制方式</h1><h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p>通过锁来显式控制共享资源而不是通过调度手段，MySQL 中主要是通过 读写锁 来实现并发控制。</p>\n<ul>\n<li>共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>\n<li>排他锁（X 锁）：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>\n</ul>\n<p>读写锁可以做到读读并行，但是无法做到写读、写写并行。</p>\n<p>另外，根据根据锁粒度的不同，又被分为 表级锁(table-level locking) 和 行级锁(row-level locking) 。</p>\n<p>InnoDB 支持</p>\n<ul>\n<li>表级锁 执行ALTER TABLE、DROP TABLE、TRUNCATE TABLE等DDL语句时</li>\n<li>行级锁(默认) <ul>\n<li>写操作（INSERT、UPDATE、DELETE）时，InnoDB会自动对受影响的行加排他锁（X锁）</li>\n<li>当存在外键约束时，插入或更新操作会对相关的外键行加共享锁</li>\n<li>当插入或更新操作导致唯一索引冲突时，会对冲突的行加共享锁</li>\n</ul>\n</li>\n</ul>\n<p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p>\n<p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p>\n<h2 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h2><p>多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>\n<p>MVCC 在 MySQL 中实现所依赖的手段主要是:<br>隐藏字段：</p>\n<ul>\n<li>DB_TRX_ID（事务ID）</li>\n<li>DB_ROLL_PTR（回滚指针），通过回滚指针找到上一个log<br>undo log : undo log 用于记录某行数据的多个版本的数据。<br>read view : 用来判断当前版本数据的可见性。</li>\n</ul>\n","feature":true,"text":"Mysql ACID 特性 原子性: 事务是最小的执行单位，不允许分割。要么全部成功，要么全部失败。 一致性: 执行事务前后，数据保持一致，例如转账业务中，无论...","permalink":"/post/Mysql-事务与MVCC","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Mysql","slug":"Mysql","count":6,"path":"api/tags/Mysql.json"},{"name":"事务","slug":"事务","count":2,"path":"api/tags/事务.json"},{"name":"MVCC","slug":"MVCC","count":1,"path":"api/tags/MVCC.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Mysql-ACID-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Mysql ACID 特性</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E9%83%BD%E6%98%AF%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E9%99%90%E5%88%B6%E5%92%8C%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">Mysql 事务隔离级别，都是事务执行过程中查询数据的限制和结果</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#READ-UNCOMMITTED%EF%BC%9A%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4\"><span class=\"toc-text\">READ UNCOMMITTED：读未提交</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#READ-COMMITTED%EF%BC%9A%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%88MVCC%EF%BC%89%E3%80%82\"><span class=\"toc-text\">READ COMMITTED：读已提交（MVCC）。</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#REPEATABLE-READ%EF%BC%9A%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-%E9%BB%98%E8%AE%A4-MVCC\"><span class=\"toc-text\">REPEATABLE READ：可重复读(默认)(MVCC)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SERIALIZABLE%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96-%E9%94%81\"><span class=\"toc-text\">SERIALIZABLE：序列化(锁)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">事务并发控制方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%81\"><span class=\"toc-text\">锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MVCC\"><span class=\"toc-text\">MVCC</span></a></li></ol></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"设计模式-原型模式","uid":"ba36f7fdf24221629f84d123d60f7a05","slug":"设计模式-原型模式","date":"2025-04-30T13:52:20.000Z","updated":"2025-04-30T08:11:18.902Z","comments":true,"path":"api/articles/设计模式-原型模式.json","keywords":null,"cover":null,"text":"模式定义原型模式（Prototype Pattern）是一种创建型设计模式，它允许你复制已有对象，而无需使代码依赖它们所属的类。该模式通过克隆现有对象来创建新对...","permalink":"/post/设计模式-原型模式","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"编程","slug":"编程","count":8,"path":"api/categories/编程.json"},{"name":"设计模式","slug":"编程/设计模式","count":8,"path":"api/categories/编程/设计模式.json"}],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"},{"name":"原型模式","slug":"原型模式","count":1,"path":"api/tags/原型模式.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"设计模式-桥接模式","uid":"8a95a847ba41df9a0cdac0faf9ed7ebe","slug":"设计模式-桥接模式","date":"2025-04-29T14:11:58.000Z","updated":"2025-04-30T08:11:18.902Z","comments":true,"path":"api/articles/设计模式-桥接模式.json","keywords":null,"cover":null,"text":"模式定义桥接模式（Bridge Pattern）是一种结构型设计模式，它将抽象部分与其实现部分分离，使它们都可以独立地变化。这种模式通过组合的方式，将类的抽象与...","permalink":"/post/设计模式-桥接模式","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"编程","slug":"编程","count":8,"path":"api/categories/编程.json"},{"name":"设计模式","slug":"编程/设计模式","count":8,"path":"api/categories/编程/设计模式.json"}],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"},{"name":"桥接模式","slug":"桥接模式","count":1,"path":"api/tags/桥接模式.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}