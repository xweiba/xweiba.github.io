{"title":"Angular中的Dom操作以及父子组件通讯","uid":"7aef0660ec2ed29ddc3bc1051080913a","slug":"Angular中的Dom操作以及父子组件通讯","date":"2020-11-23T05:53:55.000Z","updated":"2025-04-30T08:11:18.830Z","comments":true,"path":"api/articles/Angular中的Dom操作以及父子组件通讯.json","keywords":null,"cover":null,"content":"<h2 id=\"4-Angular中的Dom操作以及父子组件通讯\"><a href=\"#4-Angular中的Dom操作以及父子组件通讯\" class=\"headerlink\" title=\"4.Angular中的Dom操作以及父子组件通讯\"></a><center>4.Angular中的Dom操作以及父子组件通讯</center></h2><h4 id=\"1-组件中获取Dom对象\"><a href=\"#1-组件中获取Dom对象\" class=\"headerlink\" title=\"1. 组件中获取Dom对象\"></a>1. 组件中获取Dom对象</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">组件中的ngOnInit()方法,是组件和指令初始化完成,并不是真正的dom加载完成  </span><br><span class=\"line\"></span><br><span class=\"line\">组件中还有一个ngAfterViewInit()方法,这个是视图加载完成,因此建议把dom操作都放在这个方法内</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-通过-ViewChild装饰器获取Dom对象\"><a href=\"#2-通过-ViewChild装饰器获取Dom对象\" class=\"headerlink\" title=\"2. 通过@ViewChild装饰器获取Dom对象\"></a>2. 通过@ViewChild装饰器获取Dom对象</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.需要在html中给dom起一个名字,e.g:</span><br><span class=\"line\">&lt;div #myBox&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">2.在组件中引入viewChild,e.g:</span><br><span class=\"line\">import &#123;Component,OnInit,ViewChild&#125; from &#x27;@angular/core&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">3.通过@ViewChild装饰器获取Dom对象,通过类的成员变量,e.g:</span><br><span class=\"line\">    export classs xxx implements OnInit &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        @ViewChild(&quot;myBox&quot;) myBox:any;</span><br><span class=\"line\">        </span><br><span class=\"line\">        constructor()&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">4.在生命周期函数ngAfterViewInit中操作Dom对象,e.g:</span><br><span class=\"line\">//nativeElement才是dom对象</span><br><span class=\"line\">this.myBox.nativeElement</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-通过-ViewChild获取子组件\"><a href=\"#3-通过-ViewChild获取子组件\" class=\"headerlink\" title=\"3. 通过@ViewChild获取子组件\"></a>3. 通过@ViewChild获取子组件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.在html中引入子组件,并命名,e.g:</span><br><span class=\"line\">&lt;app-header #header &gt;&lt;/app-header&gt; </span><br><span class=\"line\">&lt;div #myBox&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">2.同获取dom对象一样,引入viewChild,创建成员变量接受组件实例,e.g:</span><br><span class=\"line\"> @ViewChild(&quot;header&quot;) header:any;</span><br><span class=\"line\"></span><br><span class=\"line\">4.在生命周期函数ngAfterViewInit中就可以调用子组件的方法:</span><br><span class=\"line\">this.header.xxx()</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-组件中通讯\"><a href=\"#4-组件中通讯\" class=\"headerlink\" title=\"4. 组件中通讯\"></a>4. 组件中通讯</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.子组件调用父组件中的属性或方法(父组件 -&gt; 子组件 传值)</span><br><span class=\"line\">    - 1. 父组件调用子组件时,需要传入数据,e.g:</span><br><span class=\"line\">        &lt;app-header [msg]=&#x27;msg&#x27;&gt;&lt;/app-header&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [msg]:是自定义属性,名称对应子组件中的成员变量</span><br><span class=\"line\">        =&#x27;msg&#x27;:是父组件中所拥有的成员变量</span><br><span class=\"line\">        </span><br><span class=\"line\">    - 2. 子组件中引入Input模块</span><br><span class=\"line\">        import &#123;Component,OnInit,ViewChild,Input&#125; from &#x27;@angular/core&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    - 3. 子组件中通过@Input接收父组件传过来的数据</span><br><span class=\"line\">        export classs xxx implements OnInit &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">            @Input() msg:string;</span><br><span class=\"line\">            </span><br><span class=\"line\">            constructor()&#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    //同理,可传递方法,以及父组件本身(传this),e.g:</span><br><span class=\"line\">        &lt;app-header [msg]=&#x27;msg&#x27; [method]=&#x27;method&#x27; [parent]=&#x27;this&#x27;&gt;&lt;/app-header&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">2.父组件调用子组件中的属性或方法(子组件 -&gt; 父组件 传值)</span><br><span class=\"line\">    可以通过@ViewChild来调用.同上</span><br><span class=\"line\">    </span><br><span class=\"line\">3.子组件通过@Output广播给父组件传值 (子组件 -&gt; 父组件 传值)</span><br><span class=\"line\">    - 1. 子组件引入Output和EventEmitter,e.g:</span><br><span class=\"line\">        import &#123;Component,OnInit,Output,EventEmitter&#125; from &#x27;@angular/core&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    - 2. 子组件中实例化EventEmitter</span><br><span class=\"line\">        //相当于注册了一个广播节点</span><br><span class=\"line\">        @Output private outer = new EventEmitter();</span><br><span class=\"line\">        </span><br><span class=\"line\">    - 3. 父组件监听广播,即将广播节点传递给父组件</span><br><span class=\"line\">        &lt;app-footer #footer (outer)=&#x27;run()&#x27;&gt;&lt;/app-footer&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">        其中:(outer)对应子组件中广播节点的名称,run()是父组件的方法</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>","text":"4.Angular中的Dom操作以及父子组件通讯1. 组件中获取Dom对象123组件中的ngOnInit()方法,是组件和指令初始化完成,并不是真正的dom加载...","permalink":"/post/Angular中的Dom操作以及父子组件通讯","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"Angular","slug":"Angular","count":16,"path":"api/categories/Angular.json"}],"tags":[{"name":"Angular","slug":"Angular","count":16,"path":"api/tags/Angular.json"},{"name":"Dom","slug":"Dom","count":1,"path":"api/tags/Dom.json"},{"name":"父子组件通讯","slug":"父子组件通讯","count":1,"path":"api/tags/父子组件通讯.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-Angular%E4%B8%AD%E7%9A%84Dom%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF\"><span class=\"toc-text\">4.Angular中的Dom操作以及父子组件通讯</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%8F%96Dom%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1. 组件中获取Dom对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%80%9A%E8%BF%87-ViewChild%E8%A3%85%E9%A5%B0%E5%99%A8%E8%8E%B7%E5%8F%96Dom%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">2. 通过@ViewChild装饰器获取Dom对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E9%80%9A%E8%BF%87-ViewChild%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3. 通过@ViewChild获取子组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BB%84%E4%BB%B6%E4%B8%AD%E9%80%9A%E8%AE%AF\"><span class=\"toc-text\">4. 组件中通讯</span></a></li></ol></li></ol></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Angular中的拦截器","uid":"ec5c1cad41982d5d9681c6467b72a951","slug":"Angular中的拦截器","date":"2020-11-23T05:54:32.000Z","updated":"2025-04-30T08:11:18.830Z","comments":true,"path":"api/articles/Angular中的拦截器.json","keywords":null,"cover":null,"text":"10.Angular中的拦截器1. 拦截器12345678910111213141516171819202122232425261.需要实现HttpInterc...","permalink":"/post/Angular中的拦截器","photos":[],"count_time":{"symbolsCount":713,"symbolsTime":"1 mins."},"categories":[{"name":"Angular","slug":"Angular","count":16,"path":"api/categories/Angular.json"}],"tags":[{"name":"Angular","slug":"Angular","count":16,"path":"api/tags/Angular.json"},{"name":"拦截器","slug":"拦截器","count":1,"path":"api/tags/拦截器.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Angular中的服务Service","uid":"06068962b522e5630d6e1e61ca839338","slug":"Angular中的服务Service","date":"2020-11-23T05:53:11.000Z","updated":"2025-04-30T08:11:18.830Z","comments":true,"path":"api/articles/Angular中的服务Service.json","keywords":null,"cover":null,"text":"3.Angular中的服务1. 服务Service Angular中组件和组件之间是不能相互调用以及通讯的,因此,一般的公共方法都写到服务(Service)中....","permalink":"/post/Angular中的服务Service","photos":[],"count_time":{"symbolsCount":394,"symbolsTime":"1 mins."},"categories":[{"name":"Angular","slug":"Angular","count":16,"path":"api/categories/Angular.json"}],"tags":[{"name":"Angular","slug":"Angular","count":16,"path":"api/tags/Angular.json"},{"name":"Service","slug":"Service","count":1,"path":"api/tags/Service.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}