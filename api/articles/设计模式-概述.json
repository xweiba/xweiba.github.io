{"title":"设计模式-概述","uid":"2a65e05f182b95ab6109ed82fd948943","slug":"设计模式-概述","date":"2025-04-29T13:35:19.000Z","updated":"2025-04-30T08:11:18.902Z","comments":true,"path":"api/articles/设计模式-概述.json","keywords":null,"cover":null,"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://github.com/youlookwhat/DesignPattern\">DesignPattern</a></p></blockquote>\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><h2 id=\"主题-Subject\"><a href=\"#主题-Subject\" class=\"headerlink\" title=\"主题 Subject\"></a>主题 Subject</h2><ol>\n<li>维护订阅者</li>\n<li>内部维护一个订阅者列表 <code>List&lt;Observer&gt; observers</code></li>\n<li>registerObserver(Observer observer), 添加订阅者到列表中</li>\n<li>removeObserver(Observer observer), 从列表中移除订阅者</li>\n<li>提供消息发布接口，notifyObservers(), 遍历列表，调用每个订阅者的更新接口</li>\n</ol>\n<h2 id=\"订阅者-Observer\"><a href=\"#订阅者-Observer\" class=\"headerlink\" title=\"订阅者 Observer\"></a>订阅者 Observer</h2><ol>\n<li>提供消息更新接口，当主题发生变化时，主题会调用这个接口。</li>\n</ol>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><p>在一个集所有商城的购物APP中购物，商品支付多种，不同支付方式则扣不同 如何实现？</p>\n<h2 id=\"支付实现类，不同支付折扣不同\"><a href=\"#支付实现类，不同支付折扣不同\" class=\"headerlink\" title=\"支付实现类，不同支付折扣不同\"></a>支付实现类，不同支付折扣不同</h2><ol>\n<li>京东支付</li>\n<li>淘宝支付</li>\n<li>微信支付</li>\n<li>支付宝支付</li>\n</ol>\n<h2 id=\"折扣实现类\"><a href=\"#折扣实现类\" class=\"headerlink\" title=\"折扣实现类\"></a>折扣实现类</h2><ol>\n<li>微信支付 10%</li>\n<li>支付宝支付 20%</li>\n<li>支付宝支付 0%</li>\n</ol>\n<h2 id=\"抽象策略类\"><a href=\"#抽象策略类\" class=\"headerlink\" title=\"抽象策略类\"></a>抽象策略类</h2><p>私有属性，支付接口，折扣策略接口，通过set设置接口实现，就可以提供不同的商品查询和支付方式策略。</p>\n<h2 id=\"策略实现类\"><a href=\"#策略实现类\" class=\"headerlink\" title=\"策略实现类\"></a>策略实现类</h2><p>策略1：微信支付，打折10%<br>策略2：支付宝支付，打折20%<br>策略3：拼多多商品，微信支付，不打折<br>策略4：拼多多商品，支付宝支付，不打折</p>\n<h2 id=\"商城客户端\"><a href=\"#商城客户端\" class=\"headerlink\" title=\"商城客户端\"></a>商城客户端</h2><p>传入策略，调用支付接口。实现不同业务场景下使用不同的策略来完成支付打折。</p>\n<h1 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h1><p>一个遥控器，有多个按钮，每个按钮对应一个命令，按下按钮，执行命令。</p>\n<h2 id=\"命令执行接口\"><a href=\"#命令执行接口\" class=\"headerlink\" title=\"命令执行接口\"></a>命令执行接口</h2><ol>\n<li>执行命令接口，execute()</li>\n</ol>\n<h2 id=\"命令实现类\"><a href=\"#命令实现类\" class=\"headerlink\" title=\"命令实现类\"></a>命令实现类</h2><ol>\n<li>打开电视命令</li>\n<li>关闭电视命令</li>\n<li>打开空调命令</li>\n<li>关闭空调命令</li>\n<li>一个默认命令，什么都不做</li>\n<li>一个组合命令，包含多个命令，执行时，遍历列表，执行每个命令</li>\n</ol>\n<h2 id=\"遥控器类\"><a href=\"#遥控器类\" class=\"headerlink\" title=\"遥控器类\"></a>遥控器类</h2><ol>\n<li>内部维护一个命令列表 <code>List&lt;Command&gt; commands</code>，初始化时，添加默认命令到列表中</li>\n<li>注册命令，registerCommand(Command command), 添加命令到列表中</li>\n<li>每个按钮对应列表中的一个命令，按下按钮，执行命令。</li>\n</ol>\n<p>命令模式就是把命令封装成对象，然后将动作请求者与动作执行者完全解耦，上例中遥控器的按钮和电器什么关系都没有依然可以正常调用。</p>\n<h1 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h1><p>游戏装备，装备有攻击力，防御力，装备可以镶嵌宝石，宝石提升攻击力。</p>\n<h2 id=\"装备接口\"><a href=\"#装备接口\" class=\"headerlink\" title=\"装备接口\"></a>装备接口</h2><ol>\n<li>攻击力</li>\n<li>描述</li>\n</ol>\n<h2 id=\"装备实现类\"><a href=\"#装备实现类\" class=\"headerlink\" title=\"装备实现类\"></a>装备实现类</h2><ol>\n<li>倚天剑</li>\n<li>屠龙刀</li>\n</ol>\n<h2 id=\"宝石接口\"><a href=\"#宝石接口\" class=\"headerlink\" title=\"宝石接口\"></a>宝石接口</h2><p>继承装备接口</p>\n<h2 id=\"宝石实现类\"><a href=\"#宝石实现类\" class=\"headerlink\" title=\"宝石实现类\"></a>宝石实现类</h2><ul>\n<li>内部维护一个装备接口属性，通过构造函数传入</li>\n<li>实现攻击力接口，实现攻击力接口，返回装备实例的攻击力加上宝石的攻击力。</li>\n<li>实现描述接口，返回装备实例的描述加上宝石的描述。</li>\n</ul>\n<h2 id=\"具体宝石实现类\"><a href=\"#具体宝石实现类\" class=\"headerlink\" title=\"具体宝石实现类\"></a>具体宝石实现类</h2><ol>\n<li>红宝石 攻击力提升10</li>\n<li>蓝宝石 攻击力提升20</li>\n</ol>\n<h2 id=\"实际使用\"><a href=\"#实际使用\" class=\"headerlink\" title=\"实际使用\"></a>实际使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个镶嵌2颗红宝石，1颗蓝宝石的靴子</span><br><span class=\"line\">System.out.println(&quot; 一个镶嵌2颗红宝石，1颗蓝宝石的靴子&quot;);</span><br><span class=\"line\">IEquip equip = new RedGemDecorator(new RedGemDecorator(new BlueGemDecorator(new ShoeEquip())));</span><br><span class=\"line\">System.out.println(&quot;攻击力  : &quot; + equip.caculateAttack());</span><br><span class=\"line\">System.out.println(&quot;描述 :&quot; + equip.description());</span><br><span class=\"line\">System.out.println(&quot;-------&quot;);</span><br><span class=\"line\">// 一个镶嵌1颗红宝石，1颗蓝宝石的武器</span><br><span class=\"line\">System.out.println(&quot; 一个镶嵌1颗红宝石，1颗蓝宝石,1颗黄宝石的武器&quot;);</span><br><span class=\"line\">equip = new RedGemDecorator(new BlueGemDecorator(new YellowGemDecorator(new ArmEquip())));</span><br><span class=\"line\">System.out.println(&quot;攻击力  : &quot; + equip.caculateAttack());</span><br><span class=\"line\">System.out.println(&quot;描述 :&quot; + equip.description());</span><br><span class=\"line\">System.out.println(&quot;-------&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个镶嵌2颗红宝石，1颗蓝宝石的靴子</span><br><span class=\"line\">攻击力  : 40</span><br><span class=\"line\">描述 :圣战靴子+ 蓝宝石+ 红宝石+ 红宝石</span><br><span class=\"line\">-------</span><br><span class=\"line\"> 一个镶嵌1颗红宝石，1颗蓝宝石,1颗黄宝石的武器</span><br><span class=\"line\">攻击力  : 50</span><br><span class=\"line\">描述 :屠龙刀+ 黄宝石+ 蓝宝石+ 红宝石</span><br><span class=\"line\">-------</span><br></pre></td></tr></table></figure>\n<p>Java 中的 IO 流就是装饰模式的应用。</p>\n<h1 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h1><p>提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。其实就是为了方便客户的使用，把一群操作，封装成一个方法。</p>\n<p>我比较喜欢看电影，于是买了投影仪、电脑、音响、设计了房间的灯光、买了爆米花机，然后我想看电影的时候，我需要：<br>1、打开爆米花机<br>2、制作爆米花<br>3、将灯光调暗<br>4、打开投影仪<br>5、放下投影仪投影区<br>6、打开电脑<br>7、打开播放器<br>8、将播放器音调设为环绕立体声</p>\n<p>使用外观模式，定义两个方法，一个是打开电影，一个是关闭电影。</p>\n<ul>\n<li>打开电影<br>1、打开爆米花机<br>2、制作爆米花<br>3、将灯光调暗<br>4、打开投影仪<br>5、放下投影仪投影区<br>6、打开电脑<br>7、打开播放器<br>8、将播放器音调设为环绕立体声</li>\n<li>关闭电影<br>1、关闭播放器<br>2、关闭电脑<br>3、放下投影仪投影区<br>4、关闭投影仪<br>5、将灯光调亮<br>6、关闭爆米花机</li>\n</ul>\n<h1 id=\"模板方法\"><a href=\"#模板方法\" class=\"headerlink\" title=\"模板方法\"></a>模板方法</h1><p>定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。<br>比如定义一个上班族工作流程的抽象模板，提供接口：进入公司，打开电脑，上班情况，关闭电脑，离开公司。</p>\n<h2 id=\"不同人实现的具体工作流程\"><a href=\"#不同人实现的具体工作流程\" class=\"headerlink\" title=\"不同人实现的具体工作流程\"></a>不同人实现的具体工作流程</h2><ol>\n<li>程序员，进入公司，打开电脑，写代码，关闭电脑，离开公司。</li>\n<li>PM，进入公司，打开电脑，开会，关闭电脑，离开公司。</li>\n<li>hr，进入公司，打开电脑，看简历-打电话-接电话，关闭电脑，离开公司。</li>\n</ol>\n<p>其中除了上班情况，其他都可以放到抽象模板中实现。</p>\n<h1 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h1><p>定义：当对象的内部状态改变时，它的行为跟随状态的改变而改变了，看起来好像重新初始化了一个类似的。<br>以自动售货机为例子。</p>\n<h2 id=\"状态接口\"><a href=\"#状态接口\" class=\"headerlink\" title=\"状态接口\"></a>状态接口</h2><ol>\n<li>投币</li>\n<li>退币</li>\n<li>转动曲柄</li>\n<li>发放商品</li>\n</ol>\n<h2 id=\"状态实现类\"><a href=\"#状态实现类\" class=\"headerlink\" title=\"状态实现类\"></a>状态实现类</h2><p>每个实现类都需要传入自动售货机实例，当状态发生变化时，自动售货机的状态也会发生变化。</p>\n<ol>\n<li>没钱状态</li>\n</ol>\n<ul>\n<li>投币，改变状态为有投币状态</li>\n<li>退币，什么都不做</li>\n<li>转动曲柄，什么都不做</li>\n<li>发放商品，提示非法操作</li>\n</ul>\n<ol start=\"2\">\n<li>有投币<ul>\n<li>投币，提示您已经投过币了，无需再投….</li>\n<li>退币，改变状态为没钱状态</li>\n<li>转动曲柄，改变状态为正在出货状态</li>\n<li>发放商品，什么都不做</li>\n</ul>\n</li>\n<li>正在出货<ul>\n<li>投币，什么都不做</li>\n<li>退币，什么都不做</li>\n<li>转动曲柄，什么都不做</li>\n<li>发放商品，调用自动售货机的发放商品方法，判断是否还有商品，有商品则改变状态为没钱状态，没有商品则改变状态为已售罄状态</li>\n</ul>\n</li>\n<li>已售罄<ul>\n<li>投币，什么都不做</li>\n<li>退币，什么都不做</li>\n<li>转动曲柄，什么都不做</li>\n<li>发放商品，提示商品已售罄</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"自动售货机类\"><a href=\"#自动售货机类\" class=\"headerlink\" title=\"自动售货机类\"></a>自动售货机类</h2><p>它也需要实现State接口，并添加一个setState方法，用于设置当前状态。</p>\n<ol>\n<li>通过构造函数初始化对所有状态通过状态构造方法将this传入，完成初始化。</li>\n<li>提供setState方法，用于设置当前状态。</li>\n<li>默认设置为没钱状态。</li>\n</ol>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p>创建自动售货机实例，调用投币接口，然后调用转动曲柄接口，然后调用退币接口，然后调用转动曲柄接口，然后调用转动曲柄接口。它会根据实际情况，调用不同的状态接口。</p>\n<p>可以看到，我们现在把每个状态对应于动作的行为局部化到了状态自己的类中实现，不仅增加了扩展性而且使代码的阅读性大幅度的提高。以后再添加状态，只需要针对新添加的状态的实现类，并在自动售货机中添加此状态即可。</p>\n<h1 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h1><p>用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。</p>\n<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。类似的还有内存缓存，当获取一个缓存对象时，我们可以直接返回它的克隆，而不是重新创建一个新的对象。同时避免元数据被修改的风险。</p>\n<h1 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h1><p>主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>\n<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。</p>\n<p>同一个类型的对象使用同一个对象，减少内存占用。 在真正使用时只修改其属性执行享元接口;</p>\n<p>定义享元接口：创建一个享元接口，规定可以共享的状态。<br>创建具体享元类：实现该接口的具体类，包含内部状态。<br>使用享元工厂：创建一个工厂类，用于管理享元对象的创建和复用。</p>\n","feature":true,"text":" DesignPattern 观察者模式主题 Subject 维护订阅者 内部维护一个订阅者列表 List<Observer> observers regist...","permalink":"/post/设计模式-概述","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"编程","slug":"编程","count":8,"path":"api/categories/编程.json"},{"name":"设计模式","slug":"编程/设计模式","count":8,"path":"api/categories/编程/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"},{"name":"软件架构","slug":"软件架构","count":1,"path":"api/tags/软件架构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">观察者模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%A2%98-Subject\"><span class=\"toc-text\">主题 Subject</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%A2%E9%98%85%E8%80%85-Observer\"><span class=\"toc-text\">订阅者 Observer</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">策略模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%94%AF%E4%BB%98%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E4%B8%8D%E5%90%8C%E6%94%AF%E4%BB%98%E6%8A%98%E6%89%A3%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">支付实现类，不同支付折扣不同</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%98%E6%89%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">折扣实现类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%AD%96%E7%95%A5%E7%B1%BB\"><span class=\"toc-text\">抽象策略类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">策略实现类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%95%86%E5%9F%8E%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">商城客户端</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">命令模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">命令执行接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">命令实现类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%81%A5%E6%8E%A7%E5%99%A8%E7%B1%BB\"><span class=\"toc-text\">遥控器类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">装饰模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E5%A4%87%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">装备接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E5%A4%87%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">装备实现类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9D%E7%9F%B3%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">宝石接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9D%E7%9F%B3%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">宝石实现类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E5%AE%9D%E7%9F%B3%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">具体宝石实现类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">实际使用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">外观模式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">模板方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E4%BA%BA%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%B7%E4%BD%93%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">不同人实现的具体工作流程</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">状态模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">状态接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">状态实现类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%94%AE%E8%B4%A7%E6%9C%BA%E7%B1%BB\"><span class=\"toc-text\">自动售货机类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">客户端</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">原型模式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">享元模式</span></a></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"设计模式-单例模式","uid":"073020299d8408617f662c6184305f2a","slug":"设计模式-单例模式","date":"2025-04-29T13:40:02.000Z","updated":"2025-04-30T08:11:18.902Z","comments":true,"path":"api/articles/设计模式-单例模式.json","keywords":null,"cover":null,"text":"模式定义单例模式（Singleton Pattern）是一种创建型设计模式，它保证一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。3 应用场景单例模...","permalink":"/post/设计模式-单例模式","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":8,"path":"api/categories/编程.json"},{"name":"设计模式","slug":"编程/设计模式","count":8,"path":"api/categories/编程/设计模式.json"}],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"},{"name":"单例模式","slug":"单例模式","count":1,"path":"api/tags/单例模式.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Js-Web转PDf框架的设计与实现","uid":"16e3b72ab86bdd03c61cdf559c2dc7de","slug":"Js-Web转PDf框架的设计与实现","date":"2025-04-29T09:38:40.000Z","updated":"2025-04-30T08:11:18.860Z","comments":true,"path":"api/articles/Js-Web转PDf框架的设计与实现.json","keywords":null,"cover":null,"text":" 设计开发了一个输出标准A3、A4等指定大小的PDF前端js框架，支持实时预览和字符级自适应分页，实时获取业务dom的精准坐标信息，所见即所得。后端使用Egg....","permalink":"/post/Js-Web转PDf框架的设计与实现","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Js，NodeJs,PDF,Js框架","slug":"Js，NodeJs-PDF-Js框架","count":1,"path":"api/tags/Js，NodeJs-PDF-Js框架.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}