{"title":"Docker 常用命令","uid":"a465c4657a75baece0af2cd4f6ae40c5","slug":"Docker 常用命令","date":"2019-08-12T03:35:42.000Z","updated":"2025-04-30T08:11:18.833Z","comments":true,"path":"api/articles/Docker 常用命令.json","keywords":null,"cover":[],"content":"<p>#<strong>shell</strong></p>\n<ul>\n<li><code>systemctl start docker</code> - 启动</li>\n<li><code>service docker restart</code> - 重启</li>\n<li><code>docker version</code> - 查看运行状态</li>\n<li><code>/etc/docker/daemon.json</code> - 镜像源文件<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`vim /etc/docker/daemon.json` </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"镜像相关\"><a href=\"#镜像相关\" class=\"headerlink\" title=\"镜像相关\"></a>镜像相关</h1><ul>\n<li><p><code>docker image ls</code> - 列出已下载的镜像</p>\n</li>\n<li><p><code>docker image ls -f dangling=true</code> - 查看虚悬镜像， 有的镜像更新后可能会出现既没有仓库名，也没有标签，均为 <none>，称为虚悬镜像，可用此命令查看</p>\n</li>\n<li><p><code>docker image prune</code> - 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用此命令删除。</p>\n</li>\n<li><p><code>docker rm $(docker ps -aq)</code> - 删除所有镜像</p>\n</li>\n<li><p><code>docker rm -v</code> - 删除镜像时同事删除其数据卷</p>\n</li>\n<li><p><code>docker rmi $(docker images -q)</code> - 删除所有镜像</p>\n</li>\n<li><p><code>docker rmi -f 127.0.0.1:8082/weiba/nginx:weiba</code> - 删除指定tag容器</p>\n</li>\n<li><p><code>docker save 镜像id &gt; tomcat8-apr.tar</code> - 导出镜像</p>\n</li>\n<li><p><code>docker load &lt; tomcat8-apr.tar</code> - 导入镜像</p>\n</li>\n<li><p>docker rmi <code>docker images | grep  &quot;&lt;none&gt;&quot; | awk &#39;&#123;print $3&#125;&#39;</code> 删除所有<code>none</code>镜像</p>\n</li>\n<li><p>docker rmi -f <code>docker images | grep  &quot;&lt;none&gt;&quot; | awk &#39;&#123;print $3&#125;&#39;</code> 强制删除所有<code>none</code>镜像</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">镜像和容器 导出和导入的区别</span><br><span class=\"line\">镜像导入和容器导入的区别：</span><br><span class=\"line\">1）容器导入 是将当前容器 变成一个新的镜像</span><br><span class=\"line\">2）镜像导入 是复制的过程</span><br><span class=\"line\">save 和 export区别：</span><br><span class=\"line\">1）save 保存镜像所有的信息-包含历史</span><br><span class=\"line\">2）export 只导出当前的信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>docker history 90457edaf6ff</code> - 查看镜像&#x2F;容器历史操作记录</p>\n</li>\n</ul>\n<h1 id=\"容器相关\"><a href=\"#容器相关\" class=\"headerlink\" title=\"容器相关\"></a>容器相关</h1><ul>\n<li><p><code>docker container rm  trusting_newton</code> - 清理指定的处于终止状态的容器</p>\n</li>\n<li><p><code>docker container prune</code> - 清理所有处于终止状态的容器</p>\n</li>\n<li><p><code>docker container start xxx</code> - 重新启动终止的容器</p>\n</li>\n<li><p><code>docker ps</code> - 查看运行中的容器</p>\n</li>\n<li><p><code>docker container ls</code> - 查看运行的容器状态</p>\n</li>\n<li><p><code>docker container ls -a</code> - 查看所有已经创建的包括终止状态的容器</p>\n</li>\n<li><p><code>docker inspect web</code> - 查看<code>web</code>容器的信息</p>\n</li>\n<li><p><code>docker stop 容器id</code>&amp;&amp;<code>docker container stop xxx</code> - 停止指定容器, 在docker stop命令执行的时候，会先向容器中PID为1的进程发送系统信号SIGTERM，然后等待容器中的应用程序终止执行，如果等待时间达到设定的超时时间，或者默认的10秒，会继续发送SIGKILL的系统信号强行kill掉进程。</p>\n</li>\n<li><p><code>docker kill xxx</code>&amp;&amp;<code>docker container kill xxx</code> - 立刻停止容器，该命令不会等待容器中的应用终止。</p>\n</li>\n<li><p><code>docker stop $(docker ps -aq)</code> - 停止所有容器</p>\n</li>\n<li><p><code>docker restart 容器id</code> - 重启指定容器</p>\n</li>\n<li><p><code>docker export b91d9ad83efa &gt; tomcat80824.tar</code> - 导入容器</p>\n</li>\n<li><p><code>docker import tomcat80824.tar</code> - 导入容器</p>\n</li>\n<li><p><code>docker import http://example.com/exampleimage.tgz example/imagerepo</code> - 从网络导入</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"容器运行相关\"><a href=\"#容器运行相关\" class=\"headerlink\" title=\"容器运行相关\"></a>容器运行相关</h2><ul>\n<li><p><code>docker exec -i -t 0a4f bash</code> - 运行&#x2F;进入 容器，使用exec方式运行容器内的bash，在其中exit容器不会停止，使用run方式运行的容器，exit后容器会停止</p>\n</li>\n<li><p><code>docker inspect --format  &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; nexus3</code> - 查看容器pid</p>\n</li>\n<li><p><code>nsenter --target PID --mount --uts --ipc --net --pid</code> - 根据pid进入容器</p>\n</li>\n<li><p><code>docker run hello-world</code> - 使用<code>docker</code>运行<code>hello-world</code>, 如果运行的<code>image</code>不存在会自动从仓库下载并运行。</p>\n</li>\n<li><p><code>docker run -p 22:22 -p 1080:1080 nginx</code> - 给容器映射多个端口 </p>\n</li>\n<li><p><code>docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code> - </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-d 守护状态运行容器，此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。**容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。**</span><br></pre></td></tr></table></figure></li>\n<li><p><code>docker run -it ubuntu</code> - 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 &#x2F;bin&#x2F;bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。</p>\n</li>\n<li><p><code>docker run -it ubuntu bash</code> - 使用<code>docker</code>运行<code>Ubuntu</code>并执行<code>bash</code>命令：<br> <img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b200009e\" alt=\"title\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<br>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。<br>ubuntu：这是指用 ubuntu 镜像为基础来启动容器。<br>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</p></blockquote>\n</li>\n<li><p><code>docker run -it ubuntu cat /etc/os-release</code> - 我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat &#x2F;etc&#x2F;os-release。这就是用 cat &#x2F;etc&#x2F;os-release 命令替换了默认的 &#x2F;bin&#x2F;bash 命令了，输出了系统版本信息。</p>\n</li>\n<li><p><code>docker run -it --rm --name test centos /bin/bash</code> - 退出后自己删除</p>\n</li>\n</ul>\n<h1 id=\"日志相关\"><a href=\"#日志相关\" class=\"headerlink\" title=\"日志相关\"></a>日志相关</h1><ul>\n<li><code>docker logs xxx</code> - 查看容器运行时输出日志</li>\n<li><code>docker logs -f xxx</code> - 滚动查看日志</li>\n</ul>\n<h1 id=\"仓库相关\"><a href=\"#仓库相关\" class=\"headerlink\" title=\"仓库相关\"></a>仓库相关</h1><ul>\n<li><code>docker login 127.0.0.1:8082</code> - 登录仓库</li>\n<li><code>docker pull 127.0.0.1:8082/weiba/nginx:weiba</code> - 下载镜像到本地</li>\n<li><code>docker pull 127.0.0.1:8082/weiba/nginx:weiba</code> - - 推送镜像到<code>127.0.0.1:8082</code> 仓库</li>\n<li><code>docker search 127.0.0.1:8082/weiba</code> - v1 API 直接docker搜索私有仓库镜像，<strong>v2 API 不支持搜索</strong></li>\n<li><code>curl 127.0.0.1:8082/v2/_catalog</code> - v2 API 查看私有Nexus3 Docker仓库镜像列表</li>\n<li><code>curl 127.0.0.1:8082/v2/ubuntu/tags/list</code> - v2 API Nexus3 Docker 查看<code>ubuntu</code>镜像标签列表</li>\n</ul>\n<h1 id=\"数据卷相关\"><a href=\"#数据卷相关\" class=\"headerlink\" title=\"数据卷相关\"></a>数据卷相关</h1><ul>\n<li><p><code>docker volume ls</code> - 查看数据卷</p>\n</li>\n<li><p><code>docker volume create my-vol</code> - 创建一个<code>my-vol</code>数据卷</p>\n</li>\n<li><p><code>docker volume rm my-vol</code> - 删除数据卷</p>\n</li>\n<li><p><code>docker volume inspect my-vol</code> - 查看数据卷信息</p>\n</li>\n<li><p><code>docker volume prune</code> - 删除无主数据卷</p>\n</li>\n<li><p><code>docker run -d -P --name web --mount type=bind,source=/src/webapp,target=/opt/webapp training/webapp python app.py</code></p>\n<ul>\n<li><p>使用–mount将主机&#x2F;src&#x2F;webapp目录挂载到容器的&#x2F;opt&#x2F;webapp目录。<br>主机目录不存在时会报错,可以使用<code>-v /src/webapp:/opt/webapp</code>替换<code>--mount type=bind,source=/src/webapp,target=/opt/webapp</code>参数，如果本地目录不存在 Docker 会自动为你创建一个文件夹</p>\n</li>\n<li><p>Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--mount type=bind,source=/src/webapp,target=/opt/webapp,readonly</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><code>docker run --rm -it --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history ubuntu:18.04 bash</code> - 挂载单个文件到容器，<strong>这是历史记录文件，创建后可以记录在容器中的操作哦</strong></p>\n<ul>\n<li><code>-v $HOME/.bash_history:/root/.bash_history </code> - 文件不存在时自动创建文件</li>\n</ul>\n</li>\n<li><p>宿主机与容器拷贝文件</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.docker ps -a  查看对应容器的ID</span><br><span class=\"line\">2.docker inspect -f &quot;&#123;&#123;.Id&#125;&#125;&quot; d4f6bfca36fa   查到容器的存储ID值</span><br><span class=\"line\">3.接下来直接cp就行</span><br><span class=\"line\">cp elasticsearch-5.2.1.rpm /software/data/docker/devicemapper/mnt/d4f6bfca36faa70276a40dd560d8a0d29b2fa5f3f8d6acc2189d185ac1f5b1c3/rootfs/root/</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"Tag-相关\"><a href=\"#Tag-相关\" class=\"headerlink\" title=\"Tag 相关\"></a>Tag 相关</h1><ul>\n<li><code>docker tag nginx:latest 127.0.0.1:8082/weiba/nginx:weiba</code> - 生成tag</li>\n</ul>\n<h1 id=\"网络相关\"><a href=\"#网络相关\" class=\"headerlink\" title=\"网络相关\"></a>网络相关</h1><ul>\n<li><p><code>docker run -d -P(大写) training/webapp python app.py</code> - 随机映射一个 49000~49900 的端口到内部容器开放的网络端口</p>\n</li>\n<li><p><code>-p(小写)</code> 参数格式 - ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort， 该标记可以多次使用来绑定多个端口</p>\n</li>\n<li><p><code>docker run -d -p 5000:5000 training/webapp python app.py</code> - 使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口</p>\n</li>\n<li><p><code>docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</code> - 使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>\n</li>\n<li><p><code>docker run -d -p 127.0.0.1::5000 training/webapp python app.py</code> - 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p>\n</li>\n<li><p><code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code> - 还可以使用 udp 标记来指定 udp 端口</p>\n</li>\n<li><p><code>docker port 8a256</code> - 根据镜像名称或id查看映射的端口配置</p>\n</li>\n<li><p>&#96;docker port 8a256 8081 - 查看8081端口绑定的地址</p>\n</li>\n</ul>\n<h2 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h2><ul>\n<li><code>docker network create -d bridge my-net</code> - 创建一个新的 Docker 网络。<ul>\n<li>-d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 <a href=\"https://yeasy.gitbooks.io/docker_practice/swarm_mode\">Swarm mode</a>。</li>\n<li><code>docker run -it --rm --name busybox1 --network my-net busybox sh</code> - 运行一个容器并连接到新建的 my-net 网络</li>\n<li><code>docker run -it --rm --name busybox2 --network my-net busybox sh</code> - 打开新的终端，再运行一个容器并加入到 my-net 网络</li>\n<li>在 busybox1 容器输入以下 <code>ping busybox2</code></li>\n<li>在 busybox2 容器执行 <code>ping busybox1</code></li>\n<li>即可发现已可以互相通过内网地址通信</li>\n</ul>\n</li>\n</ul>\n<p>##配置DNS<br>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p>\n<p>在容器中使用 mount 命令可以看到挂载信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mount</span><br><span class=\"line\">/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ...</span><br><span class=\"line\">/dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...</span><br><span class=\"line\">tmpfs on /etc/resolv.conf type tmpfs ...</span><br></pre></td></tr></table></figure>\n<p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 &#x2F;etc&#x2F;resolv.conf 文件立刻得到更新。</p>\n<p>配置全部容器的 DNS ，也可以在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件中增加以下内容来设置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;dns&quot; : [</span><br><span class=\"line\">    &quot;114.114.114.114&quot;,</span><br><span class=\"line\">    &quot;8.8.8.8&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。使用以下命令来证明其已经生效。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -it --rm ubuntu:18.04  cat etc/resolv.conf</span><br><span class=\"line\"></span><br><span class=\"line\">nameserver 114.114.114.114</span><br><span class=\"line\">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>\n\n<p>如果用户想要手动指定容器的配置，可以在使用 docker run 命令启动容器时加入如下参数：</p>\n<p>-h HOSTNAME 或者 –hostname&#x3D;HOSTNAME 设定容器的主机名，它会被写到容器内的 &#x2F;etc&#x2F;hostname 和 &#x2F;etc&#x2F;hosts。但它在容器外部看不到，既不会在 docker container ls 中显示，也不会在其他的容器的 &#x2F;etc&#x2F;hosts 看到。</p>\n<p>–dns&#x3D;IP_ADDRESS 添加 DNS 服务器到容器的 &#x2F;etc&#x2F;resolv.conf 中，让容器用这个服务器来解析所有不在 &#x2F;etc&#x2F;hosts 中的主机名。</p>\n<p>–dns-search&#x3D;DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</p>\n<p><strong>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 &#x2F;etc&#x2F;resolv.conf 来配置容器。</strong></p>\n<h1 id=\"列出镜像\"><a href=\"#列出镜像\" class=\"headerlink\" title=\"列出镜像\"></a>列出镜像</h1><ul>\n<li><p><code>docker image ls</code> - 列出已下载的镜像<br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b2000099\" alt=\"title\"></p>\n</li>\n<li><p><code>docker system df</code> - 查看镜像、容器、数据卷所占用的空间</p>\n</li>\n<li><p><code>docker image ls -f dangling=true</code> - 查看虚悬镜像， 有的镜像更新后可能会出现既没有仓库名，也没有标签，均为 <none>，称为虚悬镜像，可用此命令查看</p>\n</li>\n<li><p><code>docker image prune</code> - 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>\n</li>\n<li><p><code>docker image ls -a</code> - 中间层镜像，为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p>\n</li>\n</ul>\n<p>不加任何参数的情况下，docker image ls 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。</p>\n<ul>\n<li><code>docker image ls ubuntu</code> - 根据仓库名列出镜像</li>\n<li><code>docker image ls ubuntu:18.04</code> - 列出特定的某个镜像，也就是说指定仓库名和标签</li>\n<li><code>docker image ls -f since=mongo:3.2</code> - 除此以外，docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。</li>\n<li><code>docker image ls -f label=com.example.version=0.1</code> - 如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。</li>\n</ul>\n<h1 id=\"以特定格式显示\"><a href=\"#以特定格式显示\" class=\"headerlink\" title=\"以特定格式显示\"></a>以特定格式显示</h1><p>默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 docker image ls 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。</p>\n<ul>\n<li><code>docker image ls -q</code> - 列出镜像id<br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b200009d\" alt=\"title\"></li>\n<li><code>docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</code> - 列出镜像，只包含镜像ID和仓库名<br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b20000a2\" alt=\"title\"></li>\n<li><code>sudo docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;:&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Size&#125;&#125;&quot;</code><br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b20000a3\" alt=\"title\"></li>\n<li><code>docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;</code> - 以表格等距显示，并且有标题行，和默认一样，不过自己定义列<br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b200009b\" alt=\"title\"></li>\n</ul>\n<h1 id=\"删除本地镜像\"><a href=\"#删除本地镜像\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h1><ul>\n<li><code>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code> - 删除本地的镜像</li>\n<li><code>docker image rm $(docker image ls -q redis)</code> - 删除所有名为<code>redis</code>的镜像</li>\n<li><code>docker image rm $(docker image ls -q -f before=mongo:3.2)</code> - 删除所有在 mongo:3.2 之前的镜像</li>\n</ul>\n<h1 id=\"commit-修改镜像，-一般不使用commit修改镜像\"><a href=\"#commit-修改镜像，-一般不使用commit修改镜像\" class=\"headerlink\" title=\"commit 修改镜像， 一般不使用commit修改镜像\"></a>commit 修改镜像， 一般不使用commit修改镜像</h1><ol>\n<li>运行<code>nginx</code>镜像</li>\n</ol>\n<ul>\n<li><code>docker run --name webserver -d -p 80:80 nginx</code></li>\n</ul>\n<ol start=\"2\">\n<li>修改<code>nginx</code>启动页面</li>\n</ol>\n<ul>\n<li><code>docker exec -it webserver bash</code> - 进入<code>webserver</code>镜像</li>\n<li><code>echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code> - 修改启动页面，刷新即可看到。<ul>\n<li>修改后的镜像不<code>commit</code>，镜像重启后会恢复原样。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>查看镜像修改内容</li>\n</ol>\n<ul>\n<li><code>docker diff webserver</code> - 退出镜像后可以查看修改的记录<br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b200009f\" alt=\"title\"></li>\n</ul>\n<ol start=\"4\">\n<li>保存修改生成新的镜像</li>\n</ol>\n<ul>\n<li><code>docker commit --author &quot;weiba &lt;test@gmail.com&gt;&quot; --message &quot;修改nginx默 认网页&quot; webserver nginx:v2</code> – 生成新的镜像，–author 是指定修改的作者，而 –message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。<br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b20000a0\" alt=\"title\"></li>\n</ul>\n<ol start=\"5\">\n<li>查看镜像操作记录，可以查看刚刚的commit</li>\n</ol>\n<ul>\n<li><code>docker history nginx:v2</code> - 查看镜像的操作记录<br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b2000098\" alt=\"title\"></li>\n</ul>\n<ol start=\"6\">\n<li>启动刚刚修改的镜像</li>\n</ol>\n<ul>\n<li><code>docker run --name web2 -d -p 81:80 nginx:v2</code> - 启动镜像</li>\n</ul>\n<h1 id=\"慎用-docker-commit\"><a href=\"#慎用-docker-commit\" class=\"headerlink\" title=\"慎用 docker commit\"></a>慎用 docker commit</h1><p>使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>\n<p>首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</p>\n<p>此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p>\n<p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>\n<h1 id=\"使用-Dockerfile-定制镜像\"><a href=\"#使用-Dockerfile-定制镜像\" class=\"headerlink\" title=\"使用 Dockerfile 定制镜像\"></a>使用 Dockerfile 定制镜像</h1><p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">mkdir</span> mynginx</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> mynginx</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">touch</span> Dockerfile</span></span><br></pre></td></tr></table></figure>\n<p>其内容为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx</span><br><span class=\"line\">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>\n\n<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。</p>\n<h2 id=\"FROM-指定基础镜像\"><a href=\"#FROM-指定基础镜像\" class=\"headerlink\" title=\"FROM 指定基础镜像\"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p>\n<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM scratch</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>\n<h2 id=\"RUN-执行命令\"><a href=\"#RUN-执行命令\" class=\"headerlink\" title=\"RUN 执行命令\"></a>RUN 执行命令</h2><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>\n<ul>\n<li><code>shell</code> 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></li>\n<li><code>exec</code> 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</li>\n</ul>\n<p>既然 <code>RUN</code> 就像 <code>Shell</code> 脚本一样可以执行命令，那么我们是否就可以像 <code>Shell</code> 脚本一样把每个命令对应一个 <code>RUN</code> 呢？比如这样：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> debian:jessie</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y gcc libc6-dev make</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> wget -O redis.tar.gz <span class=\"string\">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">mkdir</span> -p /usr/src/redis</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> make -C /usr/src/redis</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure>\n<p>之前说过，<strong>Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</strong><br>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>\n<p><strong>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</strong></p>\n<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> debian:jessie</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> buildDeps=<span class=\"string\">&#x27;gcc libc6-dev make&#x27;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; apt-get update \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; apt-get install -y <span class=\"variable\">$buildDeps</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; wget -O redis.tar.gz <span class=\"string\">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span> \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; <span class=\"built_in\">mkdir</span> -p /usr/src/redis \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; make -C /usr/src/redis \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; make -C /usr/src/redis install \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/* \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; <span class=\"built_in\">rm</span> redis.tar.gz \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; <span class=\"built_in\">rm</span> -r /usr/src/redis \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; apt-get purge -y --auto-remove <span class=\"variable\">$buildDeps</span></span></span><br></pre></td></tr></table></figure>\n\n<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅<strong>使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</strong></p>\n<p>并且，这里为了格式化还进行了换行。<strong>Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。</strong>良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>\n<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。<strong>这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</strong></p>\n<h2 id=\"构建镜像\"><a href=\"#构建镜像\" class=\"headerlink\" title=\"构建镜像\"></a>构建镜像</h2><p>在 <code>Dockerfile</code> 文件所在目录执行: <code>$ docker build -t nginx:v3 .</code>, 注意后面的一个点，代表当前文件夹，<strong>这是在指定上下文路径</strong><br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b20000a1\" alt=\"title\"><br>启动测试：<code>docker run --name webserver -d -p 80:80 nginx:v3</code><br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b200009a\" alt=\"title\"><br><img src=\"leanote://file/getImage?fileId=5c18fd1375a1b808b200009c\" alt=\"title\"></p>\n<h3 id=\"什么是上下文？\"><a href=\"#什么是上下文？\" class=\"headerlink\" title=\"什么是上下文？\"></a>什么是上下文？</h3><p>首先我们要理解 docker build 的工作原理。<strong>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具</strong>。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，<strong>虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成</strong>。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>\n<p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p>\n<p>这就引入了上下文的概念。<strong>当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件</strong>。</p>\n<p>如果在 Dockerfile 中这么写：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./package.json /app/</span></span><br></pre></td></tr></table></figure>\n<p>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是<strong>复制 上下文（context） 目录下的 package.json</strong>。</p>\n<p>因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ..&#x2F;package.json &#x2F;app 或者 COPY &#x2F;opt&#x2F;xxxx &#x2F;app 无法工作的原因，因为<strong>这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件</strong>。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>\n<p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来. <strong>如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用.gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的</strong>。</p>\n<p>那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？<strong>这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile</strong>。</p>\n<p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ..&#x2F;Dockerfile.php 参数指定某个文件作为 Dockerfile： <code>docker build -t nginx:v4 -f test .</code></p>\n<p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>\n<h2 id=\"其它-docker-build-的用法\"><a href=\"#其它-docker-build-的用法\" class=\"headerlink\" title=\"其它 docker build 的用法\"></a>其它 docker build 的用法</h2><ul>\n<li><p>直接用 Git repo 进行构建<br>docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</span><br><span class=\"line\">docker build https://github.com/twang2218/gitlab-ce-zh.git\\#:8.14</span><br><span class=\"line\">Sending build context to Docker daemon 2.048 kB</span><br><span class=\"line\">Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0</span><br><span class=\"line\">8.14.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class=\"line\">aed15891ba52: Already exists</span><br><span class=\"line\">773ae8583d14: Already exists</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 &#x2F;8.14&#x2F;，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>\n</li>\n<li><p>用给定的 tar 压缩包构建</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从标准输入中读取 Dockerfile 进行构建</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure>\n<p>如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。</p>\n</li>\n<li><p>从标准输入中读取上下文压缩包进行构建</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>\n<p>如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>\n</li>\n</ul>\n<h2 id=\"docker-save-和-docker-load\"><a href=\"#docker-save-和-docker-load\" class=\"headerlink\" title=\"docker save 和 docker load\"></a>docker save 和 docker load</h2><ul>\n<li>保存镜像<br>使用 docker save 命令可以将镜像保存为归档文件。<br>比如我们希望保存这个 alpine 镜像。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker save alpine | gzip &gt; alpine-latest.tar.gz</span><br></pre></td></tr></table></figure>\n然后我们将 alpine-latest.tar.gz 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker load -i alpine-latest.tar.gz</span><br><span class=\"line\">Loaded image: alpine:latest</span><br></pre></td></tr></table></figure>\n如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; &#x27;cat | docker load&#x27;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h1><p>在使用 -d 参数时，容器启动后会进入后台。</p>\n<p>某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。</p>\n<ul>\n<li><p>attach 命令<br>docker attach 是 Docker 自带的命令。下面示例如何使用该命令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@weiba-PC:/home/weiba/mynginx# docker run -dit ubuntu</span><br><span class=\"line\">02d28e91c81bbd565942c1cc7ec17d9fc46265c47c0e82a78df6e465cdcf77b8</span><br><span class=\"line\">root@weiba-PC:/home/weiba/mynginx# docker container ls</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class=\"line\">02d28e91c81b        ubuntu              &quot;/bin/bash&quot;         14 seconds ago      Up 12 seconds                           wonderful_torvalds</span><br><span class=\"line\">root@weiba-PC:/home/weiba/mynginx# docker attach 02d</span><br><span class=\"line\">root@02d28e91c81b:/# exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">root@weiba-PC:/home/weiba/mynginx# docker container ls</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure>\n<p>注意： <strong>如果从这个 stdin 中 exit，会导致容器的停止。</strong></p>\n</li>\n<li><p>exec 命令<br>-i -t 参数<br>docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。</p>\n</li>\n</ul>\n<p><strong>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</strong></p>\n<p><strong>当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@weiba-PC:/home/weiba/mynginx# docker run -dit ubuntu</span><br><span class=\"line\">0a4f6cf3ef619bfa82d0671defed695a305653ce10ec347c9551fc062dbcf6e4</span><br><span class=\"line\">root@weiba-PC:/home/weiba/mynginx# docker container ls</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class=\"line\">0a4f6cf3ef61        ubuntu              &quot;/bin/bash&quot;         11 seconds ago      Up 10 seconds                           fervent_minsky</span><br><span class=\"line\">root@weiba-PC:/home/weiba/mynginx# docker exec -i 0a4f bash</span><br><span class=\"line\">ls</span><br><span class=\"line\">bin</span><br><span class=\"line\">boot</span><br><span class=\"line\">dev</span><br><span class=\"line\">etc</span><br><span class=\"line\">home</span><br><span class=\"line\">lib</span><br><span class=\"line\">lib64</span><br><span class=\"line\">media</span><br><span class=\"line\">mnt</span><br><span class=\"line\">opt</span><br><span class=\"line\">proc</span><br><span class=\"line\">root</span><br><span class=\"line\">run</span><br><span class=\"line\">sbin</span><br><span class=\"line\">srv</span><br><span class=\"line\">sys</span><br><span class=\"line\">tmp</span><br><span class=\"line\">usr</span><br><span class=\"line\">var</span><br><span class=\"line\"></span><br><span class=\"line\">exit</span><br><span class=\"line\">root@weiba-PC:/home/weiba/mynginx# docker container ls</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class=\"line\">0a4f6cf3ef61        ubuntu              &quot;/bin/bash&quot;         54 seconds ago      Up 53 seconds                           fervent_minsky</span><br><span class=\"line\">root@weiba-PC:/home/weiba/mynginx# docker exec -i -t 0a4f bash</span><br><span class=\"line\">root@0a4f6cf3ef61:/# ls</span><br><span class=\"line\">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>\n<p><strong>如果从这个 stdin 中 exit，不会导致容器的停止。推荐大家使用 docker exec</strong></p>\n<h2 id=\"安装-Nexus3-私有仓库\"><a href=\"#安装-Nexus3-私有仓库\" class=\"headerlink\" title=\"安装 Nexus3 私有仓库\"></a>安装 Nexus3 私有仓库</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name nexus3 --restart=always \\</span><br><span class=\"line\">    -p 8081:8081 \\</span><br><span class=\"line\">    --mount src=nexus-data,target=/nexus-data \\</span><br><span class=\"line\">    sonatype/nexus3</span><br></pre></td></tr></table></figure>\n<p>等待 3-5 分钟，如果 nexus3 容器没有异常退出，那么你可以使用浏览器打开 <a href=\"http://yourip:8081/\">http://YourIP:8081</a> 访问 Nexus 了。</p>\n<p>第一次启动 Nexus 的默认帐号是 admin 密码是 admin123 登录以后点击页面上方的齿轮按钮进行设置。</p>\n<p>第一次启动 Nexus 的默认帐号是 admin 密码是 admin123 登录以后点击页面上方的齿轮按钮进行设置。</p>\n","text":"#shell systemctl start docker - 启动 service docker restart - 重启 docker version - ...","permalink":"/post/Docker 常用命令","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"Docker","slug":"Docker","count":7,"path":"api/categories/Docker.json"}],"tags":[{"name":"docker","slug":"docker","count":5,"path":"api/tags/docker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">镜像相关</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">容器相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">容器运行相关</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">日志相关</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%93%E5%BA%93%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">仓库相关</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">数据卷相关</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Tag-%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">Tag 相关</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">网络相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94\"><span class=\"toc-text\">容器互联</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">列出镜像</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A5%E7%89%B9%E5%AE%9A%E6%A0%BC%E5%BC%8F%E6%98%BE%E7%A4%BA\"><span class=\"toc-text\">以特定格式显示</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">删除本地镜像</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#commit-%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%EF%BC%8C-%E4%B8%80%E8%88%AC%E4%B8%8D%E4%BD%BF%E7%94%A8commit%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">commit 修改镜像， 一般不使用commit修改镜像</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%85%8E%E7%94%A8-docker-commit\"><span class=\"toc-text\">慎用 docker commit</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Dockerfile-%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">使用 Dockerfile 定制镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FROM-%E6%8C%87%E5%AE%9A%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">FROM 指定基础镜像</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RUN-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">RUN 执行命令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">构建镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9F\"><span class=\"toc-text\">什么是上下文？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E5%AE%83-docker-build-%E7%9A%84%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">其它 docker build 的用法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#docker-save-%E5%92%8C-docker-load\"><span class=\"toc-text\">docker save 和 docker load</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">进入容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85-Nexus3-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93\"><span class=\"toc-text\">安装 Nexus3 私有仓库</span></a></li></ol></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"使用RamDisk加速Idea","uid":"899eecff22fb67a409c8e8dd7bf92429","slug":"使用RamDisk加速Idea","date":"2019-08-19T04:23:13.000Z","updated":"2025-04-30T08:11:18.900Z","comments":true,"path":"api/articles/使用RamDisk加速Idea.json","keywords":null,"cover":null,"text":"E盘为 RamDisk虚拟磁盘。 剪切 idea 主要的工作目录C:\\Users\\用户名.IntelliJIdea2019.2 文件夹到 E:\\Users\\用户...","permalink":"/post/使用RamDisk加速Idea","photos":[],"count_time":{"symbolsCount":257,"symbolsTime":"1 mins."},"categories":[{"name":"RamDisk","slug":"RamDisk","count":1,"path":"api/categories/RamDisk.json"}],"tags":[{"name":"idea","slug":"idea","count":1,"path":"api/tags/idea.json"},{"name":"Ramdisk","slug":"Ramdisk","count":1,"path":"api/tags/Ramdisk.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Deepin 安装 Docker","uid":"abb7b100693f257cce1f4583ac951898","slug":"Deepin 安装 Docker","date":"2019-08-12T03:34:46.000Z","updated":"2025-04-30T08:11:18.832Z","comments":true,"path":"api/articles/Deepin 安装 Docker.json","keywords":null,"cover":[],"text":" 最近公司发布会由于是异地举行，被部署搞的很伤，连续加了几天班，大多都是因为运行环境问题，所以这次会后，领导准备全面使用docker，将整体服务容器化，后期使用...","permalink":"/post/Deepin 安装 Docker","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Docker","slug":"Docker","count":7,"path":"api/categories/Docker.json"}],"tags":[{"name":"docker","slug":"docker","count":5,"path":"api/tags/docker.json"},{"name":"deepin","slug":"deepin","count":1,"path":"api/tags/deepin.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}