{"title":"Docker 容器的底层实现（转载资料）","uid":"01b31d33e59784cdd89994ca196501a5","slug":"Docker 容器的底层实现（转载资料）","date":"2019-08-12T03:32:47.000Z","updated":"2025-04-30T08:11:18.832Z","comments":true,"path":"api/articles/Docker 容器的底层实现（转载资料）.json","keywords":null,"cover":[],"content":"<p>写的非常详细，可以直接去原文看： <a href=\"https://www.cnblogs.com/zcqdream/articles/6542236.html\">Docker(1)底层实现</a></p>\n<p><em>以下存档防止丢失～～</em></p>\n<h1 id=\"Docker底层实现\"><a href=\"#Docker底层实现\" class=\"headerlink\" title=\"Docker底层实现\"></a><strong>Docker底层实现</strong></h1><p>Docker并没有传统虚拟化的Hypervisor层,因为dokcer是基于容器技术的轻量级虚拟化,相对于传统的虚拟化，省去了Hypervisor层的开销,而且其虚拟化技术是基于内核的Cgroup和Namespace技术,处理逻辑与内核深度融合,所以在很多方面,docker的性能与物理机非常接近</p>\n<p>在通信上,Docker并不会直接与内核交互,它是通过一个更底层的工具Libcontainer与内核交互的,<strong>Libcontainer 是真正意义上的容器引擎,它通过clone系统调用直接创建容器,通过pivot_root系统调用进入容器,且通过直接操作cgroupfs文件实现对资源的管控</strong></p>\n<p><strong>Docker本身则侧重于处理更上层的业务</strong></p>\n<p><strong>容器&#x3D;cgroup+namespace+rootfs+容器引擎(用户态工具LXC)</strong><br>　　.Cgroup　　资源控制<br>　　.Namespace　　访问隔离<br>　　.rootfs　　文件系统隔离<br>　　.容器引擎　　生命周期控制</p>\n<p>Docker底层的核心技术包括,linux上的名称空间(Namesaces),控制组(Contorl groups)，Union文件系统,和容器格式(Container format)</p>\n<h1 id=\"Cgroup是什么\"><a href=\"#Cgroup是什么\" class=\"headerlink\" title=\"Cgroup是什么\"></a><strong>Cgroup是什么</strong></h1><p><strong>它是control groups 的简写,属于linux内核的一个特性,用于限制和隔离一组进程对系统资源的使用</strong></p>\n<p>资源:CPU,内存,block I&#x2F;O 网络带宽</p>\n<p>devices:设备权限控制</p>\n<p>cpuset:分配指定cpu和内存节点</p>\n<p>cpu：控制cpu占用率</p>\n<p>cpuacct:统计CPU使用情况</p>\n<p>memory:限制内存的使用上限</p>\n<p>freezer:冻结(暂停) Cgroup中的进程</p>\n<p>net_cls:配合tc(traffic controller) 限制网络带宽</p>\n<p>net_prio:设置进程的网络流量优先级</p>\n<p>huge_tlb:限制HugeTLB的使用</p>\n<p>perf_event:允许Perf工具基于Cgroup分组做性能检测</p>\n<h2 id=\"容器机制\"><a href=\"#容器机制\" class=\"headerlink\" title=\"容器机制:\"></a>容器机制:</h2><p>让某些进程在彼此隔离的名字空间运行,大家虽然都共用一个内核和某些运行时的环境(例如一些系统命令和库)，但是彼此都看不到，都以为系统中只有自己存在</p>\n<ul>\n<li>名字空间来做权限的隔离控制</li>\n<li>利用cgroups来做资源分配</li>\n</ul>\n<h3 id=\"Cgroup-的接口和使用\"><a href=\"#Cgroup-的接口和使用\" class=\"headerlink\" title=\"__Cgroup__的接口和使用\"></a>__Cgroup__的接口和使用</h3><ol>\n<li><p>挂载cgroupfs</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看cgroupfs</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@linux-node2 cgroup]# ll /sys/fs/cgroup/</span><br><span class=\"line\">总用量 0</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cgroup.clone_children</span><br><span class=\"line\">--w--w--w- 1 root root 0 5月  18 14:08 cgroup.event_control</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cgroup.procs</span><br><span class=\"line\">-r--r--r-- 1 root root 0 5月  18 14:08 cgroup.sane_behavior</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.cpu_exclusive</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.cpus</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.mem_exclusive</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.mem_hardwall</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_migrate</span><br><span class=\"line\">-r--r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_pressure</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_pressure_enabled</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_spread_page</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.memory_spread_slab</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.mems</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.sched_load_balance</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 cpuset.sched_relax_domain_level</span><br><span class=\"line\">drwxr-xr-x 2 root root 0 7月   4 15:26 docker</span><br><span class=\"line\">drwxr-xr-x 4 root root 0 5月  18 14:09 libvirt</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 notify_on_release</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 release_agent</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 5月  18 14:08 tasks</span><br></pre></td></tr></table></figure>\n<p> 可以看到这里有很多的控制文件,其中以cpuset开头的控制文件,都是由cpuset子系统产生的,其他文件则是由Cgroup产生,<br> 这里的tasks文件记录了这个Cgroup的所有进程，包括线程，在系统启动后,默认没有对Cgroup做任何配置的情况下,cgroupfs只有一个根目录,并且系统所有进程都在这个根目录中，既进程pid都在根目录tasks文件中</p>\n</li>\n<li><p>创建Cgroup</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /sys/fs/cgroup/child</span><br></pre></td></tr></table></figure>\n<p> 这样就创建了一个新的Cgroup</p>\n</li>\n<li><p>配置Cgroup</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@linux-node2 cgroup]# echo 0 &gt; child/cpuset.cpus</span><br><span class=\"line\">[root@linux-node2 cgroup]# echo 0 &gt; child/cpuset.mems</span><br></pre></td></tr></table></figure>\n<p> 这样就可以限制这个Cgroup的进程只能在0号CPU上运行,并且只会从0号内存节点分配内存</p>\n</li>\n<li><p>使能Cgroup</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@linux-node2 child]# echo 2487 &gt; /sys/fs/cgroup/child/tasks </span><br><span class=\"line\"></span><br><span class=\"line\">这里2487代表进程的pid号</span><br><span class=\"line\"></span><br><span class=\"line\">[root@linux-node2 child]# echo $$ &gt; /sys/fs/cgroup/child/tasks 也是可以的</span><br><span class=\"line\"></span><br><span class=\"line\">这里$$代表当前进程</span><br><span class=\"line\"></span><br><span class=\"line\">-----------------</span><br><span class=\"line\">写入task只会把制定的进程加到child中.</span><br><span class=\"line\">写入cgroup.procs则会把这个进程所属的整个线程都加到child中</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Cgroup子系统介绍\"><a href=\"#Cgroup子系统介绍\" class=\"headerlink\" title=\"Cgroup子系统介绍\"></a>Cgroup子系统介绍</h2><ol>\n<li><p>cpuet子系统<br> cpuset可以为一组进程分配指定的CPU和内存节点,cpuset一开始用在高性能计算(HPC)行的.在NUMA架构的服务器上,通过将进程绑定到固定的CPU和内存节点上<br> 来避免进程在运行时因跨节点内存访问而导致的性能下降,当然,现在cpuset也广泛的用在了kvm和容器上</p>\n<ul>\n<li>cpuset主要接口: <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpuset.cpus: 允许进程使用的CPU列表 (例如:0-4,9)</span><br><span class=\"line\">cpuset.mems: 允许进程使用的内存节点列表 (例如0-1)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>CPU子系统<br>  cpu子系统用于限制进程的CPU占用率,实际上它有三个功能,分别通过不同的接口来提供</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CPU比重分配: 这个特性使用的接口是cpu.shares .如果cgroupfs目录下创建了2个Cgroup，分别是C1和C2,并且将cpu.shares分别设置为512和1024,那么当C1和C2争用CPU时,C2将会得到比C1 多一倍的CPU占用率,要值得注意的是,只有当它们争用CPU时,cpu.share才会起作用,如果C2是空闲的,那么C1可以得到全部的CPU资源</span><br><span class=\"line\"></span><br><span class=\"line\">CPU带宽限制:这个特性使用的接口是cpu.cfs_period_us和cpu.cfs_quota_us 。这2个接口单位是微秒</span><br><span class=\"line\"></span><br><span class=\"line\">实时进程的CPU带宽限制: 使用的是cpu.rt_period_us和cpu.rt__runtime_us</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cpuacct子系统<br> 用来统计个Cgroup的CPU使用情况</p>\n</li>\n<li><p>memory子系统<br> 限制Cgroup所能使用的内存上限,有如下接口</p>\n<ul>\n<li>memory.limit_in_bytes: 设定内存上限,单位是字节,也可以使用k&#x2F;K，m&#x2F;M或者g&#x2F;G 表示要设置数值单位 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 1G &gt; memory.limit_in——bytes</span><br><span class=\"line\">  </span><br><span class=\"line\">如果Cgroup使用的内存超过上限,linux内核会尝试回收内存,如果仍然无法将内存使用量控制在上限之内,系统将会触发OOM，选择并杀死该Cgroup中的某个进程</span><br></pre></td></tr></table></figure></li>\n<li>memory.memsw.limit__in_bytes:设定内存加上交换分区的使用量,通过设置这个值,可以防止进程把交换分区用光</li>\n<li>memory.oom_control: 如果设置为0，那么在内存使用量超过上限时,系统不会’杀死’ 进程,而是阻塞进程直到有内存被释放可供使用时: 另一方面,系统会向用户态发送事件通知,用户态的监控程序可以根据该事件来做相应的处理,例如提高内存上限等</li>\n</ul>\n</li>\n<li><p>blkio子系统<br>用来限制Cgroup的block I&#x2F;O带宽</p>\n</li>\n<li><p>devices子系统<br>控制Cgroup的进程对那些设备有访问权限</p>\n</li>\n</ol>\n<h1 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h1><p>Docker采用了C&#x2F;S架构<br>客户端和服务端可以运行在一个机器上,也可以通过socket或者RESTful API 来进行通信<br><img src=\"leanote://file/getImage?fileId=5c19179375a1b808b20000a8\" alt=\"Docker采用了C/S架构\"><br>Docker  daemon 一般在宿主机后台运行,等待接收客户端的消息<br>Docker客户端则为客户提供一系列可执行的命令, 用户使用这些命令跟docker daemon交互</p>\n<h1 id=\"剖析\"><a href=\"#剖析\" class=\"headerlink\" title=\"剖析\"></a>剖析</h1><h2 id=\"名字空间\"><a href=\"#名字空间\" class=\"headerlink\" title=\"名字空间\"></a>名字空间</h2><p>　　名字空间是linux内核一个强大的特性，每个容器都有自己单独的名字空间,运行在其中的应用都像是在独立的操作系统一样。名字空间保证了各容器之前互不影响</p>\n<h2 id=\"pid名字空间\"><a href=\"#pid名字空间\" class=\"headerlink\" title=\"pid名字空间\"></a>pid名字空间</h2><p>　　不同用户的进程就是通过pid名字空间隔离开来的,且不同名字空间中可以有相同的pid。所有的LXC进程在Dokcer中的父进程为dokcer进程</p>\n<p>每个LXC(<strong>基于容器的操作系统层级的虚拟化技术</strong>)进程具有不同的名字空间,同时由于永许嵌套,因此可以很方便的实现嵌套的Docker容器</p>\n<h2 id=\"net名字空间\"><a href=\"#net名字空间\" class=\"headerlink\" title=\"net名字空间\"></a>net名字空间</h2><p>　　网络端口还是共享的host端口 ，网络隔离是通过net名字空间实现的, 每个net名字空间有独立的网络设置,IP地址,路由表,&#x2F;proc&#x2F;net 目录(<strong>proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口</strong>)。这样每个容器就隔离开来。Docker默认采用veth方式(成对出现的点对点网络设置)【&#x3D;&#x3D;懵逼状态。。】 将容器中的虚拟网卡同host上的一个Dokcer网桥docker0连接在一起</p>\n<p><a href=\"http://www.open-open.com/lib/view/open1488423458438.html\">软连：http://www.open-open.com/lib/view/open1488423458438.html</a></p>\n<h2 id=\"ipc名字空间\"><a href=\"#ipc名字空间\" class=\"headerlink\" title=\"ipc名字空间\"></a>ipc名字空间</h2><p>　　容器中进程交互还是采用了linux常见的进程交互方法，包括信号量，消息队列,共享内存等，容器的进程间交互实际上还是host上具有相同pid名字空间中的进程间交互,因此需要在ipc资源申请时加入名字空间信息,每个IPC资源有一个唯一的32位ID</p>\n<h2 id=\"mnt名字空间\"><a href=\"#mnt名字空间\" class=\"headerlink\" title=\"mnt名字空间\"></a>mnt名字空间</h2><p>　　类似chroot，将一个进程放到一个特定的目录执行,mnt名字空间允许不同名字空间的进程看到文件结构，这样每个名字空间中的进程所看到的文件目录就被隔离开来了。每个名字空间中的容器在 &#x2F;proc&#x2F;mounts的信息只包含所在名字空间的mount point</p>\n<h2 id=\"uts名字空间\"><a href=\"#uts名字空间\" class=\"headerlink\" title=\"uts名字空间\"></a>uts名字空间</h2><p>　　UTS名字空间允许每个容器拥有独立的hostname和domain name 使其在网络上可以被视作一个独立的节点而非主机上的一个进程</p>\n<h2 id=\"USER-名字空间\"><a href=\"#USER-名字空间\" class=\"headerlink\" title=\"USER 名字空间\"></a>USER 名字空间</h2><p>　　每个容器可以有不同的用户和组ID，也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户</p>\n<h2 id=\"控制组\"><a href=\"#控制组\" class=\"headerlink\" title=\"控制组\"></a>控制组</h2><p>　　控制组(cgroups)是linux内核的一个特性，主要用来对共享资源进行隔离,限制,审计等.只有能控制分配到容器的资源,才能避免当多个容器同时运行时对系统资源的竞争</p>\n<p><strong>linux内核2.6.24开始支持</strong></p>\n<p>控制组可以提供对容器内的 内存，CPU,磁盘IO等资源的限制和计费管理</p>\n<h2 id=\"Union文件系统\"><a href=\"#Union文件系统\" class=\"headerlink\" title=\"Union文件系统\"></a>Union文件系统</h2><p>　　union文件系统(unionFS)是一种分层，轻量级并且高性能的文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下</p>\n<p>　　union文件系统是docker镜像的基础,镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具有应用镜像</p>\n<p>另外，不同docker容器就可以共享一些基础的文件系统层,同时再加上自己独有的改动层，大大提高了存储的效率</p>\n<p>Docker中使用的AUFS 就是一种union FS。 AUFS支持为每一个成员目录（类似git的分支）设定 只读，读写，写出 权限，同时AUFS里有一个类似分层的概念，对只读权限的分支可以逻辑上进行增量的修改(不影响只读部分)</p>\n<p>Docker目前支持的union文件系统种类包括 AUFS,btrfs，vfs和DeviceMapper</p>\n<h2 id=\"容器格式\"><a href=\"#容器格式\" class=\"headerlink\" title=\"容器格式\"></a>容器格式</h2><p>最初，docker采用了LXC中的容器格式，<strong>自1.20版本开始,Docker也开始支持新的libcontainer格式，并作业默认选项</strong></p>\n<h2 id=\"Docker网络实现\"><a href=\"#Docker网络实现\" class=\"headerlink\" title=\"Docker网络实现\"></a>Docker网络实现</h2><p>Docker 的网络实现其实就是利用了 Linux 上的网络名字空间和虚拟网络设备（特别是 veth pair）。建议先<br>熟恲了解返两部分的基本概念再阅读本章。<br>基本原理<br>首先，要实现网络通信，机器需要至少一个网络接口（物理接口戒虚拟接口）来收发数据包；此外，如果<br>丌同子网乀间要迕行通信，需要路由机制。<br>Docker 中的网络接口默讣都是虚拟的接口。虚拟接口的优势乀一是转发效率较高。 Linux 通过在内核中迕<br>行数据复制来实现虚拟接口乀间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接<br>收缓存中。对亍本地系统和容器内系统看来就像是一个正常的以太网卡，叧是它丌需要真正同外部网络设<br>备通信，速度要徆快。<br>Docker 容器网络就利用了返项技术。它在本地主机和容器内分别创建一个虚拟接口，幵讥它们彼此连通<br>（返样的一对接口叨做 veth pair ）。</p>\n<h3 id=\"veth-pair\"><a href=\"#veth-pair\" class=\"headerlink\" title=\"veth pair\"></a>veth pair</h3><p><img src=\"leanote://file/getImage?fileId=5c19179375a1b808b20000a7\" alt=\"veth pair\"></p>\n<h2 id=\"镜像的实现原理\"><a href=\"#镜像的实现原理\" class=\"headerlink\" title=\"镜像的实现原理\"></a>镜像的实现原理</h2><p>Docker 镜像是怎举实现增量的修改和维护的？ 每个镜像都由徆多层次极成，Docker 使用 Union FS 将返<br>些丌同的层结合到一个镜像中去。<br>通常 Union FS 有两个用途, 一方面可以实现丌借劣 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更<br>常用的就是将一个叧读的分支和一个可写的分支联合在一起，Live CD 正是基亍此方法可以允许在镜像丌<br>变的基础上允许用户在其上迕行一些写操作。 Docker 在 AUFS 上极建的容器也是利用了类似的原理。</p>\n<h2 id=\"Docker-容器\"><a href=\"#Docker-容器\" class=\"headerlink\" title=\"Docker 容器\"></a>Docker 容器</h2><p>容器是 Docker 又一核心概念。<br>简单的说，容器是独立运行的一个戒一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟<br>运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>\n<p>当操作docker run 内部实现<br>docker run 来创建容器时，Docker 在后台运行的标准操作包括：<br>检查本地是否存在指定的镜像，不存在就从公有仓库下载<br>利用镜像创建并启动一个容器<br>分配一个文件系统，并在叧读的镜像层外面挂载一层可读写层<br>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去<br>从地址池配置一个 ip 地址给容器<br>执行用户挃定的应用程序<br>执行完毕后容器被终止</p>\n<h2 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h2><p>数据卷是一个可供一个戒多个容器使用的特殊目录，它绕过 UFS，可以提供徆多有用的特性：<br>数据卷可以在容器之间共享和重用<br>对数据卷的修改会立马生效<br>对数据卷的更新，不会影响镜像<br>卷会一直存在，直到没有容器使用</p>\n<p>—数据卷的使用。类似于linux下对目录的mount</p>\n<p>使用 -v 标记来创建一个数据卷幵挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -P --name web -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<p>使用 -v 标记也可以挃定挂载一个本地主机的目录到容器中去。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<p>加载主机的 &#x2F;src&#x2F;webapp 目录到容器的 &#x2F;opt&#x2F;webapp 目录，</p>\n<p>本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p>\n<p>Docker 挂载数据卷的默讣权限是读写，用户也可以通过 :ro 指定为只读</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br></pre></td></tr></table></figure>","text":"写的非常详细，可以直接去原文看： Docker(1)底层实现 以下存档防止丢失～～ Docker底层实现Docker并没有传统虚拟化的Hypervisor层,因...","permalink":"/post/Docker 容器的底层实现（转载资料）","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"Docker","slug":"Docker","count":7,"path":"api/categories/Docker.json"}],"tags":[{"name":"docker","slug":"docker","count":5,"path":"api/tags/docker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Docker%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">Docker底层实现</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Cgroup%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">Cgroup是什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">容器机制:</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cgroup-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">__Cgroup__的接口和使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Cgroup%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">Cgroup子系统介绍</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">基本架构</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%96%E6%9E%90\"><span class=\"toc-text\">剖析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">名字空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pid%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">pid名字空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#net%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">net名字空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ipc%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">ipc名字空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mnt%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">mnt名字空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#uts%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">uts名字空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#USER-%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">USER 名字空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E7%BB%84\"><span class=\"toc-text\">控制组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Union%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">Union文件系统</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">容器格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Docker%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">Docker网络实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#veth-pair\"><span class=\"toc-text\">veth pair</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">镜像的实现原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Docker-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">Docker 容器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8D%B7\"><span class=\"toc-text\">数据卷</span></a></li></ol></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Deepin 安装 Docker","uid":"abb7b100693f257cce1f4583ac951898","slug":"Deepin 安装 Docker","date":"2019-08-12T03:34:46.000Z","updated":"2025-04-30T08:11:18.832Z","comments":true,"path":"api/articles/Deepin 安装 Docker.json","keywords":null,"cover":[],"text":" 最近公司发布会由于是异地举行，被部署搞的很伤，连续加了几天班，大多都是因为运行环境问题，所以这次会后，领导准备全面使用docker，将整体服务容器化，后期使用...","permalink":"/post/Deepin 安装 Docker","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Docker","slug":"Docker","count":7,"path":"api/categories/Docker.json"}],"tags":[{"name":"docker","slug":"docker","count":5,"path":"api/tags/docker.json"},{"name":"deepin","slug":"deepin","count":1,"path":"api/tags/deepin.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JS工具集","uid":"70f3dc3b65ff84d1ff3522c18e25ad00","slug":"JS 工具集","date":"2019-08-08T05:47:41.000Z","updated":"2025-04-30T08:11:18.848Z","comments":true,"path":"api/articles/JS 工具集.json","keywords":null,"cover":null,"text":"CommUtils.jsjs 工具集合: 12345678910111213141516171819202122232425262728293031323334...","permalink":"/post/JS 工具集","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"JS","slug":"JS","count":1,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":1,"path":"api/tags/JS.json"},{"name":"工具","slug":"工具","count":1,"path":"api/tags/工具.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}