{"title":"Java-高级-Day-4-GC垃圾收集算法","uid":"55e262e45820c6fc0e5602715c3359d4","slug":"Java-高级-Day-4-GC垃圾收集算法","date":"2025-04-24T05:26:47.000Z","updated":"2025-04-30T08:11:18.858Z","comments":true,"path":"api/articles/Java-高级-Day-4-GC垃圾收集算法.json","keywords":null,"cover":[],"content":"<h1 id=\"核心点\"><a href=\"#核心点\" class=\"headerlink\" title=\"核心点\"></a>核心点</h1><h2 id=\"分代收集理论\"><a href=\"#分代收集理论\" class=\"headerlink\" title=\"分代收集理论\"></a>分代收集理论</h2><ul>\n<li><strong>新升代：复制算法</strong>，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法</li>\n<li><strong>老年代：“标记-清除”或“标记-整理”算法</strong>，对象存活几率是比较高，而且没有额外的空间对它进行分配担保，必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li>\n</ul>\n<h2 id=\"核心算法\"><a href=\"#核心算法\" class=\"headerlink\" title=\"核心算法\"></a>核心算法</h2><ul>\n<li>标记-复制算法(空间换时间)：将内存分为两块相同的的大小，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉，这样就使每次的内存回收都是对内存区间的一半进行回收。</li>\n<li>标记-清除算法：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：<ul>\n<li><strong>效率问题  (如果需要标记的对象太多，效率不高)</strong></li>\n<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>\n</ul>\n</li>\n<li>标记-整理算法(标记清除算法升级): 根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</li>\n</ul>\n<h2 id=\"垃圾收集器-理论的实现\"><a href=\"#垃圾收集器-理论的实现\" class=\"headerlink\" title=\"垃圾收集器(理论的实现)\"></a>垃圾收集器(理论的实现)</h2><img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/95765.png\" class=\"\" title=\"img\">\n<ul>\n<li>Serial&#x2F;Serial Old: <strong>单线程收集器，新生代使用复制算法，老年代使用标记-整理算法</strong>。没有线程交互开销，可以获得很高的单线程收集效率，缺点：<strong>在进行垃圾收集时，必须暂停其他所有的工作线程(STW-Stop The World)，直到它收集结束, 延时高</strong>。一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</li>\n<li>Parallel Scavenge&#x2F;Parallel Old(JDK8默认)：Serial 的多线程版本，默认的收集线程数跟cpu核数相同，新生代采用复制算法，老年代采用标记-整理算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑它；</li>\n<li>ParNew：跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。新生代采用复制算法，它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作。</li>\n<li>CMS(Concurrent Mark Sweep 并发标记清除)：HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，以获取最短回收停顿时间为目标的收集器。<strong>优点：并发收集、低停顿</strong>。<br>  它的执行过程分为以下四个步骤：<br>  - <strong>初始标记</strong>： STW，并记录下<strong>GC Roots直接能引用的对象,速度很快</strong>。<br>      - <strong>并发标记</strong>： 从GC Roots的直接关联对象开始遍历整个对象图,耗时较长但是不需要停顿用户线程。因为用户线程继续运行，可能会有导致已经标记过的对象状态发生改变。<br>      - <strong>重新标记</strong>： STW, 主要是处理漏标问题, 修正并发标记期间因用户程序运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。<strong>主要用到三色标记里的增量更新算法做重新标记。</strong><br>      - <strong>并发清除</strong>： 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理。<br>      - <strong>并发重置</strong>：重置本次GC过程中的标记数据。<ul>\n<li>CMS 缺点：<ul>\n<li>对CPU资源敏感（会和服务抢资源）；</li>\n<li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li>\n<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li>\n<li>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，此时会进入stop the world，用serial old垃圾收集器来回收</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>G1 JDK8且内存大于8GB及以上推荐，JDK8的实现效率不如CMS。</li>\n</ul>\n<h2 id=\"三色标记\"><a href=\"#三色标记\" class=\"headerlink\" title=\"三色标记\"></a>三色标记</h2><p>三色标记算法是把Gc roots遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</p>\n<ul>\n<li>白色：对象遍历时初始化状态，标识未被GC Rooots 引用。若在分析结束的阶段，仍然是白色的对象，即代表不可达，可清理。</li>\n<li>灰色(没扫描完，可能被引用)：没扫描完，这个对象上至少存在一个引用还没有被扫描到，不能删除。</li>\n<li>黑色：已扫描完，肯定有引用，必须存活。</li>\n</ul>\n<h2 id=\"多标-浮动垃圾\"><a href=\"#多标-浮动垃圾\" class=\"headerlink\" title=\"多标-浮动垃圾\"></a>多标-浮动垃圾</h2><p>并发标记(还有并发清理)开始后，如果由于标记过程中对象间引用发生变化，<strong>则会导致本来应该清理的对象，没有得到及时的清理</strong>，这种情况就被称为<strong>浮动垃圾</strong>。通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p>\n<h2 id=\"漏标-写屏障\"><a href=\"#漏标-写屏障\" class=\"headerlink\" title=\"漏标-写屏障\"></a>漏标-写屏障</h2><p>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，解决方案(都使用写屏障实现)：<br>    - 增量更新(Incremental Update): 黑色对象插入新的指向白色对象的引用关系时， 将这个新插入的引用记录，等并发扫描结束后，再将记录的引用关系中的黑色对象为根,重新扫描一次。<br>    - 原始快照(Snapshot At The Beginning，SATB): 当灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用记录，等并发扫描结束之后，再将记录的引用关系中的灰色对象为根，重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)</p>\n<h3 id=\"Java-HotSpot-VM-漏标时的处理实现\"><a href=\"#Java-HotSpot-VM-漏标时的处理实现\" class=\"headerlink\" title=\"Java HotSpot VM 漏标时的处理实现\"></a>Java HotSpot VM 漏标时的处理实现</h3><ul>\n<li>CMS：写屏障 + 增量更新</li>\n<li>G1，Shenandoah：写屏障 + SATB</li>\n<li>ZGC：读屏障</li>\n</ul>\n<p>为什么G1用SATB？CMS用增量更新？<br>SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。</p>\n<h2 id=\"记忆集与卡表\"><a href=\"#记忆集与卡表\" class=\"headerlink\" title=\"记忆集与卡表\"></a>记忆集与卡表</h2><p>在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。需要建立一个“<strong>记忆集</strong>”的数据结构(相当于一张表)，记录下老年代中所有指向新生代的指针。在做GC Roots可达性扫描的时候，就能通过这个记忆集避免扫描整个老年代。<strong>卡表就是记忆集的实现。</strong><br>    - 卡表<br>    卡表使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。<br>        - 卡页：一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0. GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。<br>        - Hotspot使用写屏障维护卡表状态。</p>\n<h1 id=\"详细解析\"><a href=\"#详细解析\" class=\"headerlink\" title=\"详细解析\"></a>详细解析</h1><img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/95317.png\" class=\"\" title=\"img\">\n<h2 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h2><h3 id=\"分代收集理论-1\"><a href=\"#分代收集理论-1\" class=\"headerlink\" title=\"分代收集理论\"></a>分代收集理论</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。举例：</p>\n<ol>\n<li><strong>新升代：复制算法</strong>，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法</li>\n<li><strong>老年代：“标记-清除”或“标记-整理”算法</strong>，对象存活几率是比较高，而且没有额外的空间对它进行分配担保，必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li>\n</ol>\n<p><strong>“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</strong></p>\n<h3 id=\"标记-复制算法\"><a href=\"#标记-复制算法\" class=\"headerlink\" title=\"标记-复制算法\"></a>标记-复制算法</h3><p>为了解决效率问题，“复制” 收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/95776.png\" class=\"\" title=\"img\">\n\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：</p>\n<ul>\n<li><strong>效率问题  (如果需要标记的对象太多，效率不高)</strong></li>\n<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>\n</ul>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/94592.png\" class=\"\" title=\"img\">\n\n<h3 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h3><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/94590.png\" class=\"\" title=\"img\">\n\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/95765.png\" class=\"\" title=\"img\">\n\n<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>\n<p>没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的Java虚拟机就不会实现那么多不同的垃圾收集器了。</p>\n<h3 id=\"Serial-串行-收集器-XX-UseSerialGC-XX-UseSerialOldGC\"><a href=\"#Serial-串行-收集器-XX-UseSerialGC-XX-UseSerialOldGC\" class=\"headerlink\" title=\"Serial(串行)收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)\"></a>Serial(串行)收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p>\n<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/95646.png\" class=\"\" title=\"img\">\n\n<p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>\n<p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p>\n<p><strong>Serial Old收集器是Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，<strong>另一种用途是作为CMS收集器的后备方案</strong>。</p>\n<h3 id=\"Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代\"><a href=\"#Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代\" class=\"headerlink\" title=\"Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))\"></a>Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))</h3><p><strong>Parallel</strong>收集器其实<strong>就是Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。</p>\n<p><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong> Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>\n<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/78078.png\" class=\"\" title=\"img\">\n\n<p><strong>Parallel Old收集器是Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(<strong>JDK8默认的新生代和老年代收集器</strong>)。</p>\n<h3 id=\"ParNew收集器-XX-UseParNewGC\"><a href=\"#ParNew收集器-XX-UseParNewGC\" class=\"headerlink\" title=\"ParNew收集器(-XX:+UseParNewGC)\"></a>ParNew收集器(-XX:+UseParNewGC)</h3><p>ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。</p>\n<p><strong>新生代采用复制算法</strong></p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/92873.png\" class=\"\" title=\"img\">\n\n<p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>\n<h3 id=\"CMS收集器-XX-UseConcMarkSweepGC-old\"><a href=\"#CMS收集器-XX-UseConcMarkSweepGC-old\" class=\"headerlink\" title=\"CMS收集器(-XX:+UseConcMarkSweepGC(old))\"></a>CMS收集器(-XX:+UseConcMarkSweepGC(old))</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>\n<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>\n<ul>\n<li><p><strong>初始标记：</strong> 暂停所有的其他线程(STW)，并记录下gc roots<strong>直接能引用的对象</strong>，<strong>速度很快</strong>。</p>\n</li>\n<li><p><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</p>\n</li>\n<li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录(<strong>主要是处理漏标问题</strong>)，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。<strong>主要用到三色标记里的****增量更新算法(见下面详解)做重新标记。</strong></p>\n</li>\n<li><p><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。</p>\n</li>\n<li><p><strong>并发重置：</strong>重置本次GC过程中的标记数据。</p>\n</li>\n</ul>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/78070.png\" class=\"\" title=\"img\">\n\n<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面几个明显的缺点：</p>\n<ul>\n<li><p>对CPU资源敏感（会和服务抢资源）；</p>\n</li>\n<li><p>无法处理<strong>浮动垃圾</strong>(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</p>\n</li>\n<li><p>它使用的回收算法-<strong>“标记-清除”算法</strong>会导致收集结束时会有<strong>大量空间碎片</strong>产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</p>\n</li>\n<li><p>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，<strong>特别是在并发标记和并发清理阶段会出现</strong>，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”<strong>concurrent mode failure</strong>“，<strong>此时会进入stop the world，用serial old垃圾收集器来回收</strong></p>\n</li>\n</ul>\n<h4 id=\"CMS的相关核心参数\"><a href=\"#CMS的相关核心参数\" class=\"headerlink\" title=\"CMS的相关核心参数\"></a><strong>CMS的相关核心参数</strong></h4><ol>\n<li><p>-XX:+UseConcMarkSweepGC：启用cms </p>\n</li>\n<li><p>-XX:ConcGCThreads：并发的GC线程数</p>\n</li>\n<li><p>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）</p>\n</li>\n<li><p>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次  </p>\n</li>\n<li><p>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</p>\n</li>\n<li><p>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</p>\n</li>\n</ol>\n<p>-XX:+CMSScavengeBeforeRemark：用于在CMS垃圾收集器的重新标记阶段（Remark）之前，强制触发一次年轻代的垃圾回收。其目的是减少需要扫描的对象数量，从而缩短重新标记阶段的停顿时间。</p>\n<ol>\n<li><p>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</p>\n</li>\n<li><p>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</p>\n</li>\n</ol>\n<h2 id=\"垃圾收集底层算法实现\"><a href=\"#垃圾收集底层算法实现\" class=\"headerlink\" title=\"垃圾收集底层算法实现\"></a>垃圾收集底层算法实现</h2><h3 id=\"三色标记法-黑灰白\"><a href=\"#三色标记法-黑灰白\" class=\"headerlink\" title=\"三色标记法(黑灰白)\"></a>三色标记法(黑灰白)</h3><p>在并发标记的过程中，<strong>因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。漏标的问题主要引入了三色标记算法来解决。</strong></p>\n<p><strong>三色标记算法是把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</strong></p>\n<ul>\n<li><p><strong>黑色</strong>： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。</p>\n</li>\n<li><p><strong>灰色</strong>： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</p>\n</li>\n<li><p><strong>白色</strong>： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</p>\n</li>\n</ul>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/95383.png\" class=\"\" title=\"img\">\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 垃圾收集算法细节之三色标记</span></span><br><span class=\"line\"><span class=\"comment\"> * 为了简化例子，代码写法可能不规范，请忽略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreeColorRemark</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">        <span class=\"comment\">//开始做并发标记</span></span><br><span class=\"line\">        <span class=\"type\">D</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> a.b.d;   <span class=\"comment\">// 1.读</span></span><br><span class=\"line\">        a.b.d = <span class=\"literal\">null</span>;  <span class=\"comment\">// 2.写</span></span><br><span class=\"line\">        a.d = d;       <span class=\"comment\">// 3.写</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">B</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">B</span>();</span><br><span class=\"line\">    <span class=\"type\">D</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">C</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">C</span>();</span><br><span class=\"line\">    <span class=\"type\">D</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">D</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多标-浮动垃圾-1\"><a href=\"#多标-浮动垃圾-1\" class=\"headerlink\" title=\"多标-浮动垃圾\"></a>多标-浮动垃圾</h4><p>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“<strong>浮动垃圾</strong>”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。</p>\n<p>另外，<strong>针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色</strong>，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p>\n<h4 id=\"漏标-读写屏障\"><a href=\"#漏标-读写屏障\" class=\"headerlink\" title=\"漏标-读写屏障\"></a>漏标-读写屏障</h4><p>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： <strong>增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。</strong></p>\n<p><strong>增量更新</strong>就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， <strong>黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了</strong>。</p>\n<p><strong>原始快照</strong>就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(<strong>目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾</strong>)</p>\n<p>以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过<strong>写屏障</strong>实现的。 </p>\n<h4 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h4><p>给某个对象的成员变量赋值时，其底层代码大概长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> field 某对象的成员变量，如 a.b.d </span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> new_value 新值，如 null</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">oop_field_store</span><span class=\"params\">(oop* field, oop new_value)</span> &#123; </span><br><span class=\"line\">    *field = new_value; <span class=\"comment\">// 赋值操作</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">oop_field_store</span><span class=\"params\">(oop* field, oop new_value)</span> &#123;  </span><br><span class=\"line\">    pre_write_barrier(field);          <span class=\"comment\">// 写屏障-写前操作</span></span><br><span class=\"line\">    *field = new_value; </span><br><span class=\"line\">    post_write_barrier(field, value);  <span class=\"comment\">// 写屏障-写后操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"写屏障实现SATB\"><a href=\"#写屏障实现SATB\" class=\"headerlink\" title=\"写屏障实现SATB\"></a>写屏障实现SATB</h5><p>当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d &#x3D; null），我们可以利用写屏障，将B<strong>原来成员变量的引用</strong>对象D记录下来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">pre_write_barrier</span><span class=\"params\">(oop* field)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">oop</span> <span class=\"variable\">old_value</span> <span class=\"operator\">=</span> *field;    <span class=\"comment\">// 获取旧值</span></span><br><span class=\"line\">    remark_set.add(old_value); <span class=\"comment\">// 记录原来的引用对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"写屏障实现增量更新\"><a href=\"#写屏障实现增量更新\" class=\"headerlink\" title=\"写屏障实现增量更新\"></a>写屏障实现增量更新</h5><p>当对象A的成员变量的引用发生变化时，比如新增引用（a.d &#x3D; d），我们可以利用写屏障，将A<strong>新的成员变量引用</strong>对象D记录下来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">post_write_barrier</span><span class=\"params\">(oop* field, oop new_value)</span> &#123;  </span><br><span class=\"line\">    remark_set.add(new_value);  <span class=\"comment\">// 记录新引用的对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"读屏障\"><a href=\"#读屏障\" class=\"headerlink\" title=\"读屏障\"></a>读屏障</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oop <span class=\"title function_\">oop_field_load</span><span class=\"params\">(oop* field)</span> &#123;</span><br><span class=\"line\">    pre_load_barrier(field); <span class=\"comment\">// 读屏障-读取前操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *field;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读屏障是直接针对第一步：D d &#x3D; a.b.d，当读取成员变量时，一律记录下来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">pre_load_barrier</span><span class=\"params\">(oop* field)</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">oop</span> <span class=\"variable\">old_value</span> <span class=\"operator\">=</span> *field;</span><br><span class=\"line\">    remark_set.add(old_value); <span class=\"comment\">// 记录读取到的对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色&#x2F;黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈&#x2F;队列&#x2F;缓存日志等方式进行实现、遍历方式可以是广度&#x2F;深度遍历等等。</p>\n<p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：</p>\n<ul>\n<li><p><strong>CMS：写屏障 + 增量更新</strong></p>\n</li>\n<li><p><strong>G1，Shenandoah：写屏障 + SATB</strong></p>\n</li>\n<li><p><strong>ZGC：读屏障</strong></p>\n</li>\n</ul>\n<p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代&#x2F;区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p>\n<p><strong>为什么G1用SATB？CMS用增量更新？</strong></p>\n<p><strong>我的理解</strong>：SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。</p>\n<h3 id=\"记忆集与卡表-1\"><a href=\"#记忆集与卡表-1\" class=\"headerlink\" title=\"记忆集与卡表\"></a>记忆集与卡表</h3><p>在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。</p>\n<p>为此，在新生代可以引入记录集（<strong>Remember Set</strong>）的数据结构（记录从非收集区到收集区的指针集合），避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。</p>\n<p>垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。</p>\n<p>hotspot使用一种叫做“卡表”(<strong>Cardtable</strong>)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。</p>\n<p>卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。</p>\n<p>hotSpot使用的卡页是2^9大小，即512字节</p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-4-GC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/95719.png\" class=\"\" title=\"img\">\n\n<p>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.</p>\n<p>GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。</p>\n<p><strong>卡表的维护</strong></p>\n<p>卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。</p>\n<p>Hotspot使用<strong>写屏障</strong>维护卡表状态。\t</p>\n","feature":true,"text":"核心点分代收集理论 新升代：复制算法，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法 老年代：“标记-清除”或“标记-整理”算法，对象存活几率是比...","permalink":"/post/Java-高级-Day-4-GC垃圾收集算法","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E7%82%B9\"><span class=\"toc-text\">核心点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">分代收集理论</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">核心算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-%E7%90%86%E8%AE%BA%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">垃圾收集器(理论的实现)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0\"><span class=\"toc-text\">三色标记</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%A0%87-%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE\"><span class=\"toc-text\">多标-浮动垃圾</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%A0%87-%E5%86%99%E5%B1%8F%E9%9A%9C\"><span class=\"toc-text\">漏标-写屏障</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Java-HotSpot-VM-%E6%BC%8F%E6%A0%87%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">Java HotSpot VM 漏标时的处理实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8\"><span class=\"toc-text\">记忆集与卡表</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">详细解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">垃圾收集算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA-1\"><span class=\"toc-text\">分代收集理论</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">标记-复制算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">标记-清除算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">标记-整理算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">垃圾收集器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Serial-%E4%B8%B2%E8%A1%8C-%E6%94%B6%E9%9B%86%E5%99%A8-XX-UseSerialGC-XX-UseSerialOldGC\"><span class=\"toc-text\">Serial(串行)收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8-XX-UseParallelGC-%E5%B9%B4%E8%BD%BB%E4%BB%A3-XX-UseParallelOldGC-%E8%80%81%E5%B9%B4%E4%BB%A3\"><span class=\"toc-text\">Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ParNew%E6%94%B6%E9%9B%86%E5%99%A8-XX-UseParNewGC\"><span class=\"toc-text\">ParNew收集器(-XX:+UseParNewGC)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CMS%E6%94%B6%E9%9B%86%E5%99%A8-XX-UseConcMarkSweepGC-old\"><span class=\"toc-text\">CMS收集器(-XX:+UseConcMarkSweepGC(old))</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CMS%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">CMS的相关核心参数</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%BA%95%E5%B1%82%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">垃圾收集底层算法实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95-%E9%BB%91%E7%81%B0%E7%99%BD\"><span class=\"toc-text\">三色标记法(黑灰白)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%A0%87-%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE-1\"><span class=\"toc-text\">多标-浮动垃圾</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%A0%87-%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C\"><span class=\"toc-text\">漏标-读写屏障</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%B1%8F%E9%9A%9C\"><span class=\"toc-text\">写屏障</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%B1%8F%E9%9A%9C%E5%AE%9E%E7%8E%B0SATB\"><span class=\"toc-text\">写屏障实现SATB</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%B1%8F%E9%9A%9C%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">写屏障实现增量更新</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%B1%8F%E9%9A%9C\"><span class=\"toc-text\">读屏障</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8-1\"><span class=\"toc-text\">记忆集与卡表</span></a></li></ol></li></ol></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java-高级-Day-5-JVM性能优化","uid":"74b4ce53d861aece862753ca4c35dd9e","slug":"Java-高级-Day-5-JVM性能优化","date":"2025-04-27T08:23:22.000Z","updated":"2025-04-30T08:11:18.860Z","comments":true,"path":"api/articles/Java-高级-Day-5-JVM性能优化.json","keywords":null,"cover":[],"text":"核心点 所有优化都要根据实际服务的具体业务场景做优化配置，没有通用的配置。 GC 优化目标：降低 full gc 产生的 STW ,让短期存活的对象尽量都留在 ...","permalink":"/post/Java-高级-Day-5-JVM性能优化","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Java-高级-Day-3-GC垃圾回收","uid":"8034d4b46da16be185cdc304107292a3","slug":"Java-高级-Day-3-GC垃圾回收","date":"2025-04-24T01:33:20.000Z","updated":"2025-04-30T08:11:18.857Z","comments":true,"path":"api/articles/Java-高级-Day-3-GC垃圾回收.json","keywords":null,"cover":[],"text":"核心点堆内存分配比 老年代:新生代 2:1 新生代 Eden区:Survivor0区:Survivor1区 占比 8:1:1 分配策略 对象在分配时使用CAS算...","permalink":"/post/Java-高级-Day-3-GC垃圾回收","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}