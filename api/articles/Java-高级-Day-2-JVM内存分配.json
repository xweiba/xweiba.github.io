{"title":"Java-高级-Day-2-JVM 内存分配","uid":"8f3910e39f3a3511dc34dd9ac8d25e0b","slug":"Java-高级-Day-2-JVM内存分配","date":"2025-04-23T03:13:38.000Z","updated":"2025-04-30T08:11:18.854Z","comments":true,"path":"api/articles/Java-高级-Day-2-JVM内存分配.json","keywords":null,"cover":[],"content":"<h1 id=\"核心点\"><a href=\"#核心点\" class=\"headerlink\" title=\"核心点\"></a>核心点</h1><p>图示：颜色相同的都为一个类型</p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-2-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/95302.png\" class=\"\" title=\"img\">\n\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ul>\n<li>程序计数器：记录当前线程正在执行的字节码指令的地址，是每个线程私有的，它的大小是4 个字节，固定的，不会随着操作系统的位数而改变，它的作用就是当重新获得cpu时间片时根据记录的字节码指令地址继续执行。</li>\n<li>线程栈：用来存放方法执行时的数据的，遵循先入后出的原则。</li>\n<li>本地方法栈：和栈一样，它是用来存放本地方法的执行时数据，遵循先入后出的原则，本地方法指在 Java 中调用非 Java 语言的方法，比如 C 语言，C++ 语言，C# 语言，Python 语言，Ruby 语言，JavaScript 语言，等等</li>\n</ul>\n<h3 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h3><p>每个方法创建时都会创建一个对应的栈帧，</p>\n<ul>\n<li>局部变量表：它是一个数组，用来存放方法的参数和局部变量，局部变量表的大小是固定的，不会随着操作系统的位数而改变</li>\n<li>操作数栈：主要用于存储方法中字节码执行过程中的操作数和中间计算结果。</li>\n<li>动态链接：在字节码执行过程中，通过动态链接找到方法的地址，从而调用方法。</li>\n<li>方法出口：在方法字节码全部执行完毕后，通过方法出口找到方法的返回地址，从而返回方法的返回值。</li>\n</ul>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li>堆是用来存放对象的，它是线程共享的。</li>\n<li>堆分为年轻代和老年代<ul>\n<li>CAS 分配</li>\n<li>堆内存划分：年轻代和老年代</li>\n<li>年轻代，三个区，默认比例 8:1:1，默认会自动调节<ul>\n<li>伊甸区Eden：用来存放新创建的对象，eden区满了后会触发<code>minor gc</code>，回收eden和survivor区(非空)，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块 <code>survivor</code> 区。</li>\n<li>幸存者0区survivor0：用来存放伊甸区中经过垃圾回收后存活的对象。</li>\n<li>幸存者1区survivor1：用来存放伊甸区中经过垃圾回收后存活的对象。</li>\n</ul>\n</li>\n<li>老年代：对象每<code>minor gc</code>移动一次对象分代年龄加1，当对象的分代年龄达到某个值（默认为15）时，就会晋升到老年代中，当老年代满了后会触发<code>full gc</code>，进行一次全局的垃圾回收。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><ul>\n<li>常量，静态变量，类元信息，它是线程共享的。</li>\n</ul>\n<h2 id=\"对象的内存分配\"><a href=\"#对象的内存分配\" class=\"headerlink\" title=\"对象的内存分配\"></a>对象的内存分配</h2><ul>\n<li>TLAB 本地线程分配缓冲（Thread Local Allocation Buffer）, 为解决多线程分配内存时的资源竞争问题，在线程创建时就提前将堆中(Eden区)的一小块内存空间预留给这个线程，默认开启。</li>\n<li>CAS 一种无锁算法，包含三个操作数：内存位置(V)、预期原值(A)和新值(B)，只有当V的值等于A时，才会将V的值更新为B，优点：非阻塞算法，提高并发性能，避免线程切换开销。缺点：ABA问题(可通过版本号解决)，循环时间长时CPU开销大，只能保证一个共享变量的原子操作。</li>\n</ul>\n<ol>\n<li>分配原则<ul>\n<li>JVM会先尝试栈上分配</li>\n<li>不满足条件则使用<code>TLAB</code>分配, TLAB(在线程创建时预先在Eden区分配一块内存, 解决并发时内存分配问题)</li>\n<li>都失败则使用CAS在堆分配</li>\n</ul>\n</li>\n<li>栈上分配条件<ul>\n<li>java8默认开启逃逸分析，默认开启标量替换</li>\n<li>对象不会逃逸出方法作用域，不会作为参数或返回值传递给其他方法（方法局部对象）</li>\n<li>对象不会被其他线程访问（线程封闭）</li>\n<li>对象大小不超过栈帧可用空间，大对象仍会分配到堆中</li>\n</ul>\n</li>\n<li>标量替换<ul>\n<li>标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<strong>JVM不会创建该对象</strong>，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数<code>(-XX:+EliminateAllocations)</code>，<strong>JDK7之后默认开启</strong>。</li>\n<li><strong>标量与聚合量：</strong>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：<code>int</code>，<code>long</code>等基本数据类型以及<code>reference</code>类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</li>\n</ul>\n</li>\n<li>对象头<ul>\n<li>32位对象头<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-2-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/123316.png\" class=\"\" title=\"img\"></li>\n<li>64位对象头<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-2-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/123317.png\" class=\"\" title=\"img\"></li>\n<li>分代年龄4字节，最大数15.</li>\n<li>指针压缩：在64位平台的HotSpot中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力</li>\n<li>对其填充：确保对象大小为8字节的整数倍，优化CPU缓存行访问，防止跨缓存行访问导致缓存行失效，提高CPU性能。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"详细解析\"><a href=\"#详细解析\" class=\"headerlink\" title=\"详细解析\"></a>详细解析</h1><h1 id=\"Java-内存分布\"><a href=\"#Java-内存分布\" class=\"headerlink\" title=\"Java 内存分布\"></a>Java 内存分布</h1><p>我们通过一个例子来完成讲解对象创建的整个生命周期，对Java 内存分布有一个大致的认识。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Math</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 加载 Person.class 文件到内存</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 调用 Person 类的构造方法，创建 Person 对象</span></span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 3. 给 p 对象中的 name 成员变量赋值</span></span><br><span class=\"line\">        p.name = <span class=\"string\">&quot;张三&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 给 p 对象中的 age 成员变量赋值</span></span><br><span class=\"line\">        p.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 5. 调用 p 对象中的 eat 方法</span></span><br><span class=\"line\">        p.eat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"type\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">foodCount</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">food</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;面条&quot;</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;吃&quot;</span> + foodCount + <span class=\"string\">&quot;碗&quot;</span> + food);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-初始化main线程\"><a href=\"#1-初始化main线程\" class=\"headerlink\" title=\"1.初始化main线程\"></a>1.初始化main线程</h2><p>JVM 虚拟机启动后，通过类转载子系统创建JVM主线程，并完成线程初始化，包括：</p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><ul>\n<li>它是一个指针，指向当前线程正在执行的字节码指令的地址，是每个线程私有的</li>\n<li>它的作用就是记录当前程序执行的字节码指令的地址，当前<code>CPU时间片</code>用完后，就会切换到其他线程执行，当 <code>CPU时间片</code> 继续分配回来的时候，通过程序计数器，告诉 JVM 当前线程正在执行的字节码指令的地址，从而继续执行。</li>\n<li>它的大小是4 个字节，固定的，不会随着操作系统的位数而改变</li>\n</ul>\n<h3 id=\"线程栈-虚拟机栈\"><a href=\"#线程栈-虚拟机栈\" class=\"headerlink\" title=\"线程栈(虚拟机栈)\"></a>线程栈(虚拟机栈)</h3><p>也叫方法栈，它是用来存放方法执行时的数据的，</p>\n<ul>\n<li><p>每个方法创建时都会创建一个对应的<code>栈帧</code>，并将<code>栈帧</code>压入栈中，遵循先入后出的原则。</p>\n</li>\n<li><p>栈帧类似方法运行时的环境，栈帧中包含：</p>\n<ul>\n<li>局部变量表：它是一个数组，用来存放方法的参数和局部变量，局部变量表的大小是固定的，不会随着操作系统的位数而改变</li>\n<li>操作数栈：主要用于存储方法中字节码执行过程中的操作数和中间计算结果。</li>\n<li>动态链接：在字节码执行过程中，通过动态链接找到方法的地址，从而调用方法。</li>\n<li>方法出口：在方法字节码全部执行完毕后，通过方法出口找到方法的返回地址，从而返回方法的返回值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"本地方法栈：\"><a href=\"#本地方法栈：\" class=\"headerlink\" title=\"本地方法栈：\"></a>本地方法栈：</h3><p>和线程栈一样，每个线程都有一个本地方法栈，用来存放本地方法的执行时数据，遵循先入后出的原则，本地方法指在 Java 中调用非 Java 语言的方法，比如 C 语言，C++ 语言，C# 语言，Python 语言，Ruby 语言，JavaScript 语言，等等</p>\n<h2 id=\"2-主线程执行，并执行-main-方法\"><a href=\"#2-主线程执行，并执行-main-方法\" class=\"headerlink\" title=\"2.主线程执行，并执行 main 方法\"></a>2.主线程执行，并执行 main 方法</h2><p>根据 <code>META-INF</code> 目录下的 <code>MANIFEST.MF</code> 文件或手动指定主类，找到需要执行的主类包名称，通过类加载器将类加载到内存中，<code>main 方法</code> 是程序的入口，它是一个静态方法，它的执行是由 JVM 虚拟机完成的，</p>\n<h3 id=\"1-创建栈帧\"><a href=\"#1-创建栈帧\" class=\"headerlink\" title=\"1. 创建栈帧\"></a>1. 创建栈帧</h3><p><code>main 方法</code> 执行时，会在 <code>main线程</code>中，创建栈帧, 并将栈帧压入<code>main线程</code>栈中.</p>\n<h3 id=\"2-执行过程中，创建对象\"><a href=\"#2-执行过程中，创建对象\" class=\"headerlink\" title=\"2. 执行过程中，创建对象\"></a>2. 执行过程中，创建对象</h3><p>当字节码执行到 <code>Person p = new Person()</code> 时，会加载 <code>Person.class</code> 文件，创建 Person 对象，并为 Person 对象分配内存</p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-2-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/123315.png\" class=\"\" title=\"img\">\n\n<ol>\n<li><p>类加载检查：虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>\n<ul>\n<li>new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。</li>\n</ul>\n</li>\n<li><p>分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</p>\n<ul>\n<li><p>分配内存有几个问题：</p>\n<ol>\n<li>如何划分内存?<ul>\n<li>“指针碰撞”（Bump the Pointer）(默认)：如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li>\n<li>“空闲列表”（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录</li>\n</ul>\n</li>\n<li>在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况？<ul>\n<li>CAS（compare and swap）虚拟机采用<strong>CAS配上失败重试</strong>的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</li>\n<li>TLAB 本地线程分配缓冲（Thread Local Allocation Buffer）, 在线程创建时就提前将堆中(Eden区)的一小块内存空间预留给这个线程，通过 <code>-XX:+/-UseTLAB</code> 参数来设定虚拟机是否使用TLAB(JVM会默认开启 <code>-XX:+UseTLAB</code>)，<code>-XX:TLABSize</code> 指定TLAB大小。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>对象分配到哪里：</p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-2-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/123318.png\" class=\"\" title=\"img\">\n<ol>\n<li>分配原则<ul>\n<li>JVM会先尝试栈上分配</li>\n<li>不满足条件则使用TLAB分配</li>\n<li>都失败则使用普通的堆分配</li>\n</ul>\n</li>\n<li>对象栈上分配：我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过<strong>逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在<strong>栈上分配</strong>内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。<ul>\n<li>对象逃逸分析：分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数或返回值传递到其他方法中，称作对象逃逸。</li>\n<li>标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<strong>JVM不会创建该对象</strong>，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数<code>(-XX:+EliminateAllocations)</code>，<strong>JDK7之后默认开启</strong>。</li>\n<li><strong>标量与聚合量：</strong>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：<code>int</code>，<code>long</code>等基本数据类型以及<code>reference</code>类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</li>\n<li>栈上分配条件<ul>\n<li>对象不会逃逸出方法作用域（方法局部对象）</li>\n<li>对象不会被其他线程访问（线程封闭）</li>\n<li>对象大小不超过栈帧可用空间，大对象仍会分配到堆中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>TLAB 在线程创建时预先在Eden区分配一块内存, 解决并发时内存分配问题</li>\n<li>堆 <ul>\n<li>CAS 分配</li>\n<li>堆内存划分：年轻代和老年代<ul>\n<li>年轻代，三个区，默认比例 8:1:1，默认会自动调节<ul>\n<li>伊甸区Eden：用来存放新创建的对象，eden区满了后会触发<code>minor gc</code>，回收eden和survivor区(非空)，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块 <code>survivor</code> 区。</li>\n<li>幸存者0区survivor0：用来存放伊甸区中经过垃圾回收后存活的对象。</li>\n<li>幸存者1区survivor1：用来存放伊甸区中经过垃圾回收后存活的对象。</li>\n</ul>\n</li>\n<li>老年代：对象每<code>minor gc</code>移动一次对象分代年龄加1，当对象的分代年龄达到某个值（默认为15）时，就会晋升到老年代中，当老年代满了后会触发<code>full gc</code>，进行一次全局的垃圾回收。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>\n</li>\n<li><p>设置对象头：初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。<br> 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>\n</li>\n</ol>\n<ul>\n<li><p>32位对象头</p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-2-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/123316.png\" class=\"\" title=\"img\">\n</li>\n<li><p>64位对象头</p>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-2-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/123317.png\" class=\"\" title=\"img\">\n</li>\n<li><p>指针压缩</p>\n<ul>\n<li>在64位平台的HotSpot中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力</li>\n<li>为了减少64位平台下内存的消耗，启用指针压缩功能</li>\n<li>在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的存入<strong>堆内存</strong>时压缩编码、取出到<strong>cpu寄存器</strong>后解码方式进行优化(对象指针在堆中是32位，在寄存器中是35位，2的35次方&#x3D;32G)，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)</li>\n<li>堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间</li>\n<li>堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</li>\n</ul>\n</li>\n<li><p>对齐填充</p>\n<ul>\n<li>作用：确保对象大小为8字节的整数倍</li>\n<li>原因：<ul>\n<li>优化CPU缓存行访问（通常64字节），对齐可以避免”伪共享”问题</li>\n<li>满足硬件对齐要求</li>\n<li>提升原子操作性能</li>\n</ul>\n</li>\n<li>示例：一个对象实际需要30字节，JVM会添加2字节填充，使其变为32字节</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>执行<init>方法：执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</li>\n</ol>\n","feature":true,"text":"核心点图示：颜色相同的都为一个类型 线程 程序计数器：记录当前线程正在执行的字节码指令的地址，是每个线程私有的，它的大小是4 个字节，固定的，不会随着操作系统的...","permalink":"/post/Java-高级-Day-2-JVM内存分配","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E7%82%B9\"><span class=\"toc-text\">核心点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">栈帧</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA\"><span class=\"toc-text\">方法区</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D\"><span class=\"toc-text\">对象的内存分配</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">详细解析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83\"><span class=\"toc-text\">Java 内存分布</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%88%9D%E5%A7%8B%E5%8C%96main%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">1.初始化main线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">程序计数器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%A0%88-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\"><span class=\"toc-text\">线程栈(虚拟机栈)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%9A\"><span class=\"toc-text\">本地方法栈：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B9%B6%E6%89%A7%E8%A1%8C-main-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.主线程执行，并执行 main 方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">1. 创建栈帧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">2. 执行过程中，创建对象</span></a></li></ol></li></ol></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java-高级-Day-3-GC垃圾回收","uid":"8034d4b46da16be185cdc304107292a3","slug":"Java-高级-Day-3-GC垃圾回收","date":"2025-04-24T01:33:20.000Z","updated":"2025-04-30T08:11:18.857Z","comments":true,"path":"api/articles/Java-高级-Day-3-GC垃圾回收.json","keywords":null,"cover":[],"text":"核心点堆内存分配比 老年代:新生代 2:1 新生代 Eden区:Survivor0区:Survivor1区 占比 8:1:1 分配策略 对象在分配时使用CAS算...","permalink":"/post/Java-高级-Day-3-GC垃圾回收","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Java-高级-Day-1-Java类加载机制","uid":"13d951f30d32eed0580b85046fce3923","slug":"Java-高级-Day-1-Java类加载机制","date":"2025-04-14T03:14:36.000Z","updated":"2025-04-30T08:11:18.852Z","comments":true,"path":"api/articles/Java-高级-Day-1-Java类加载机制.json","keywords":null,"cover":[],"text":"核心点类加载器 引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar 、charsets.jar 等 扩展类加载器：负责...","permalink":"/post/Java-高级-Day-1-Java类加载机制","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}