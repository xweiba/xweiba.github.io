{"title":"Java-高级-Day-3-GC垃圾回收","uid":"8034d4b46da16be185cdc304107292a3","slug":"Java-高级-Day-3-GC垃圾回收","date":"2025-04-24T01:33:20.000Z","updated":"2025-04-30T08:11:18.857Z","comments":true,"path":"api/articles/Java-高级-Day-3-GC垃圾回收.json","keywords":null,"cover":[],"content":"<h1 id=\"核心点\"><a href=\"#核心点\" class=\"headerlink\" title=\"核心点\"></a>核心点</h1><h2 id=\"堆内存分配比\"><a href=\"#堆内存分配比\" class=\"headerlink\" title=\"堆内存分配比\"></a>堆内存分配比</h2><ul>\n<li>老年代:新生代 2:1</li>\n<li>新生代 Eden区:Survivor0区:Survivor1区 占比 8:1:1</li>\n</ul>\n<h3 id=\"分配策略\"><a href=\"#分配策略\" class=\"headerlink\" title=\"分配策略\"></a>分配策略</h3><ul>\n<li>对象在分配时使用CAS算法来保证并发时的内存分配效率</li>\n<li>大对象直接进入老年代，它需要大量连续内存空间的对象（比如：字符串、数组），当Eden区放不下这个对象时，会直接分配到老年代中，可以通过<code>-XX:PretenureSizeThreshold</code>参数来设置大对象的阈值, 默认为0，即不启用。</li>\n<li>长期存活的对象将进入老年代 分代年龄达到15岁的对象会进入老年代，可以通过<code>-XX:MaxTenuringThreshold</code>参数来设置分代年龄的阈值，默认为15，最大值15，最小值1。</li>\n<li>对象动态年龄判断: 如果某一年龄的对象总大小超过了Survivor区的50%，那么所有大于等于该年龄的对象会被直接晋升到老年代, 无需等到15岁。 可通过 <code>-XX:TargetSurvivorRatio</code> 参数来设置动态年龄的阈值, 默认为50，最大值99，最小值1。</li>\n<li>老年代空间分配担保机制: 在Minor GC发生前策略, 可通过<code>-XX:HandlePromotionFailure=true</code>配置，JDK6之后默认开启。<ol>\n<li>首先检查老年代最大可用连续空间是否大于新生代所有对象总大小，如果大于，则Minor GC可以确保安全, 执行Minor GC；</li>\n<li>如果小于，则检查<code>-XX:HandlePromotionFailure</code>参数是否设置为<code>true</code>，如果是，则会继续检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小</strong></li>\n<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>\n<li>如果小于，则会进行一次Full GC。 <img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-3-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/123319.png\" class=\"\" title=\"img\"></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h2><h3 id=\"Minor-GC\"><a href=\"#Minor-GC\" class=\"headerlink\" title=\"Minor GC\"></a>Minor GC</h3><p>Eden区满时触发,将Eden区和Survivor0区中的存活对象复制到Survivor1区中，然后清空Eden区和Survivor0区，下次Minor GC时，会将Eden区和Survivor1区中的存活对象复制到Survivor0区中，以此类推。</p>\n<ul>\n<li>新升代中分代年龄达到15，进入老年代，0&lt;分代年龄&lt;15;</li>\n<li>eden区放不下的大对象直接进入老年代。</li>\n</ul>\n<h3 id=\"Full-GC\"><a href=\"#Full-GC\" class=\"headerlink\" title=\"Full GC\"></a>Full GC</h3><h4 id=\"Full-GC-的回收目标\"><a href=\"#Full-GC-的回收目标\" class=\"headerlink\" title=\"Full GC 的回收目标\"></a>Full GC 的回收目标</h4><ol>\n<li><p><strong>新生代(Young Generation)</strong></p>\n</li>\n<li><p>**老年代(Old Generation)**：</p>\n</li>\n<li><p>**元空间(Metaspace)**：</p>\n<ul>\n<li>替代永久代(PermGen)的内存区域</li>\n<li>当元空间使用量达到MaxMetaspaceSize阈值时，会触发Full GC进行垃圾回收”</li>\n</ul>\n</li>\n<li><p><strong>方法区</strong>：</p>\n<ul>\n<li>存储类信息、常量、静态变量等</li>\n</ul>\n</li>\n<li><p><strong>其他系统区域</strong>：</p>\n<ul>\n<li>包括JVM内部数据结构</li>\n<li>系统类加载器加载的类对象等</li>\n</ul>\n</li>\n</ol>\n<p>Full GC是全局性垃圾回收，会扫描JVM管理的所有内存区域，而Minor GC只处理新生代区域。</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h4 id=\"Full-GC的触发条件\"><a href=\"#Full-GC的触发条件\" class=\"headerlink\" title=\"Full GC的触发条件\"></a>Full GC的触发条件</h4><ol>\n<li><p><strong>老年代空间不足</strong>：当老年代空间不足以存放从年轻代晋升的对象时，会触发Full GC。</p>\n</li>\n<li><p><strong>永久代&#x2F;元空间不足</strong>（取决于JVM版本）：</p>\n<ul>\n<li>Java 8之前：永久代(PermGen)空间不足</li>\n<li>Java 8及之后：元空间(Metaspace)空间不足</li>\n</ul>\n</li>\n<li><p><strong>System.gc()调用</strong>：当代码中显式调用System.gc()时，可能会触发Full GC（取决于JVM参数-XX:+DisableExplicitGC的设置）。</p>\n</li>\n<li><p><strong>CMS GC失败</strong>：在使用CMS收集器时，如果并发模式失败（Concurrent Mode Failure），会触发Full GC。</p>\n</li>\n<li><p><strong>晋升失败</strong>：当年轻代对象需要晋升到老年代，但老年代没有足够空间时。</p>\n</li>\n<li><p><strong>分配担保失败</strong>：在Minor GC之前，如果老年代最大可用连续空间小于历次晋升到老年代对象的平均大小，会触发Full GC。</p>\n</li>\n<li><p><strong>堆内存分配失败</strong>：当JVM无法为新对象分配内存时。</p>\n</li>\n<li><p><strong>手动触发</strong>：通过JVM工具（如jcmd、jconsole）手动触发Full GC。</p>\n</li>\n</ol>\n<h3 id=\"GC-Roots\"><a href=\"#GC-Roots\" class=\"headerlink\" title=\"GC Roots\"></a>GC Roots</h3><ol>\n<li>线程栈中的引用对象 ：<ul>\n<li>当前执行方法中的局部变量和参数</li>\n<li>每个线程栈帧中引用的对象</li>\n</ul>\n</li>\n<li>方法区中的静态属性引用 ：<ul>\n<li>类的静态变量(static修饰)</li>\n<li>例如： public static Object obj &#x3D; new Object();</li>\n</ul>\n</li>\n<li>方法区中的常量引用 ：<ul>\n<li>字符串常量池中的引用</li>\n<li>final修饰的常量引用的对象</li>\n</ul>\n</li>\n<li>本地方法栈中的JNI引用 ：<ul>\n<li>Native方法引用的对象</li>\n<li>JNI调用的本地代码创建的对象</li>\n</ul>\n</li>\n<li>活跃线程的引用 ：<ul>\n<li>当前运行线程对象(Thread)</li>\n<li>线程栈中的局部变量引用</li>\n</ul>\n</li>\n<li>同步锁持有的对象 ：<ul>\n<li>被 synchronized 锁持有的对象</li>\n<li>同步代码块&#x2F;方法使用的锁对象</li>\n</ul>\n</li>\n<li>JVM内部系统对象 ：<ul>\n<li>系统类加载器加载的类对象</li>\n<li>基本数据类型对应的Class对象</li>\n</ul>\n</li>\n<li>管理接口相关引用 ：<ul>\n<li>JMXBean等管理接口引用的对象</li>\n<li>JVMTI等本地接口注册的回调</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"如何判断对象是否死亡\"><a href=\"#如何判断对象是否死亡\" class=\"headerlink\" title=\"如何判断对象是否死亡\"></a>如何判断对象是否死亡</h3><ul>\n<li><p>引用计数法:给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>\n<ul>\n<li>优点: 实现简单</li>\n<li>缺点: 无法解决循环引用问题</li>\n</ul>\n</li>\n<li><p>可达性分析算法(默认使用):通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>\n<ul>\n<li>优点: 可以解决循环引用问题</li>\n<li>缺点: 实现复杂</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"finalize-不推荐使用\"><a href=\"#finalize-不推荐使用\" class=\"headerlink\" title=\"finalize() 不推荐使用\"></a>finalize() <strong>不推荐使用</strong></h3><ul>\n<li>当对象被回收时，系统会自动调用该对象的<code>finalize()</code>方法，程序员可以覆盖该方法，在该方法中进行资源释放，例如关闭文件、套接字等。但是，<code>finalize()</code>方法并不推荐使用，因为它的执行时间是不确定的，并且它可能会导致对象复活。</li>\n<li>你可以在finalize中执行逻辑让被其他对象引用，从而让对象复活。</li>\n<li>一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。</li>\n</ul>\n<h2 id=\"常见引用类型\"><a href=\"#常见引用类型\" class=\"headerlink\" title=\"常见引用类型\"></a>常见引用类型</h2><p>强引用：普通的变量引用 <code>public static User user = new User();</code><br>软引用：将对象用 <code>SoftReference</code> 软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。软引用可用来实现内存敏感的高速缓存。 <code>public static SoftReference&lt;User&gt; user = new SoftReference&lt;User&gt;(new User());</code><br>弱引用: 将对象用<code>WeakReference</code>软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用<br>虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p>\n<h1 id=\"详细解析\"><a href=\"#详细解析\" class=\"headerlink\" title=\"详细解析\"></a>详细解析</h1>\n<p>当对象无法在栈上分配且无法通过TLAB分配时，会在堆上进行分配。堆的空间并不是无限的，并且实际运行中，很多对象都是用完即弃的，所以在堆上分配对象时，会使用垃圾回收机制来回收不再使用的对象，从而释放内存空间。</p>\n<h2 id=\"堆内存布局\"><a href=\"#堆内存布局\" class=\"headerlink\" title=\"堆内存布局\"></a>堆内存布局</h2><p>堆默认分为两个区域：</p>\n<ul>\n<li>新生代 默认占比 1&#x2F;3， 新生代又分为Eden区和Survivor区<ul>\n<li>Eden区 默认占比 8&#x2F;10</li>\n<li>Survivor0区 默认占比 1&#x2F;10</li>\n<li>Survivor1区 默认占比 1&#x2F;10</li>\n</ul>\n</li>\n<li>老年代 默认占比 2&#x2F;3</li>\n</ul>\n<h2 id=\"垃圾回收机制-1\"><a href=\"#垃圾回收机制-1\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h2><p>新对象默认分配在Eden区，当Eden区满时，会触发Minor GC，Minor GC会将Eden区和Survivor0区中的存活对象复制到Survivor1区中，然后清空Eden区和Survivor0区，下次Minor GC时，会将Eden区和Survivor1区中的存活对象复制到Survivor0区中，以此类推。当Survivor区中的对象复制到另一个Survivor区中时，会将对象头中的分代年龄+1，如果对象的年龄超过了15岁，会将对象复制到老年代中。</p>\n<h3 id=\"分配策略-1\"><a href=\"#分配策略-1\" class=\"headerlink\" title=\"分配策略\"></a>分配策略</h3><ul>\n<li><p>对象在分配时使用CAS算法来分配内存</p>\n</li>\n<li><p>大对象直接进入老年代，它需要大量连续内存空间的对象（比如：字符串、数组），当Eden区放不下这个对象时，会直接分配到老年代中，可以通过<code>-XX:PretenureSizeThreshold</code>参数来设置大对象的阈值, 默认为0，即不启用。</p>\n</li>\n<li><p>长期存活的对象将进入老年代 分代年龄达到15岁的对象会进入老年代，可以通过<code>-XX:MaxTenuringThreshold</code>参数来设置分代年龄的阈值，默认为15，最大值15，最小值1。</p>\n</li>\n<li><p>对象动态年龄判断: 当某年龄的所有对象大小总和 &gt; Survivor区空间的50%时, JVM会将该年龄及以上的对象直接晋升到老年代, 无需等到15岁。 可通过 <code>-XX:TargetSurvivorRatio</code> 参数来设置动态年龄的阈值, 默认为50，最大值99，最小值1。</p>\n<ul>\n<li>使得Survivor区能保持足够的空闲空间</li>\n<li>避免频繁进行对象复制操作</li>\n<li>提高GC效率</li>\n</ul>\n</li>\n<li><p>老年代空间分配担保机制: 在Minor GC发生前，JVM会检查老年代最大可用连续空间是否大于新生代所有对象总大小，如果大于，则Minor GC可以确保安全, 执行Minor GC；如果小于，则会检查<code>-XX:HandlePromotionFailure</code>参数是否设置为<code>true</code>，如果是，则会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于，则会进行一次Full GC。可通过<code>-XX:HandlePromotionFailure=true</code>配置，JDK6之后默认开启。</p>\n<ul>\n<li>避免在Minor GC之前进行一次Full GC</li>\n<li>在内存紧张时提供弹性空间</li>\n<li>提高GC效率</li>\n</ul>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-3-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/123319.png\" class=\"\" title=\"img\"></li>\n</ul>\n<h3 id=\"如何判断对象是否死亡-1\"><a href=\"#如何判断对象是否死亡-1\" class=\"headerlink\" title=\"如何判断对象是否死亡\"></a>如何判断对象是否死亡</h3><h4 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>\n<ul>\n<li>优点: 实现简单</li>\n<li>缺点: 无法解决循环引用问题</li>\n</ul>\n<h4 id=\"可达性分析算法-默认使用\"><a href=\"#可达性分析算法-默认使用\" class=\"headerlink\" title=\"可达性分析算法(默认使用)\"></a>可达性分析算法(默认使用)</h4><p>通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>\n<ul>\n<li>优点: 可以解决循环引用问题</li>\n<li>缺点: 实现复杂</li>\n</ul>\n<img src=\"/post/Java-%E9%AB%98%E7%BA%A7-Day-3-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/123320.png\" class=\"\" title=\"img\">\n\n<h4 id=\"GC-Roots-1\"><a href=\"#GC-Roots-1\" class=\"headerlink\" title=\"GC Roots\"></a>GC Roots</h4><ol>\n<li>线程栈中的引用对象 ：<ul>\n<li>当前执行方法中的局部变量和参数</li>\n<li>每个线程栈帧中引用的对象</li>\n</ul>\n</li>\n<li>方法区中的静态属性引用 ：<ul>\n<li>类的静态变量(static修饰)</li>\n<li>例如： public static Object obj &#x3D; new Object();</li>\n</ul>\n</li>\n<li>方法区中的常量引用 ：<ul>\n<li>字符串常量池中的引用</li>\n<li>final修饰的常量引用的对象</li>\n</ul>\n</li>\n<li>本地方法栈中的JNI引用 ：<ul>\n<li>Native方法引用的对象</li>\n<li>JNI调用的本地代码创建的对象</li>\n</ul>\n</li>\n<li>活跃线程的引用 ：<ul>\n<li>当前运行线程对象(Thread)</li>\n<li>线程栈中的局部变量引用</li>\n</ul>\n</li>\n<li>同步锁持有的对象 ：<ul>\n<li>被 synchronized 锁持有的对象</li>\n<li>同步代码块&#x2F;方法使用的锁对象</li>\n</ul>\n</li>\n<li>JVM内部系统对象 ：<ul>\n<li>系统类加载器加载的类对象</li>\n<li>基本数据类型对应的Class对象</li>\n</ul>\n</li>\n<li>管理接口相关引用 ：<ul>\n<li>JMXBean等管理接口引用的对象</li>\n<li>JVMTI等本地接口注册的回调</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"常见引用类型-1\"><a href=\"#常见引用类型-1\" class=\"headerlink\" title=\"常见引用类型\"></a>常见引用类型</h4><p>java的引用类型一般分为四种：强引用、软引用、弱引用、虚引用</p>\n<p>强引用：普通的变量引用</p>\n<ul>\n<li><code>public static User user = new User();</code></li>\n</ul>\n<p>软引用：将对象用 <code>SoftReference</code> 软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。软引用可用来实现内存敏感的高速缓存。</p>\n<ul>\n<li><code>public static SoftReference&lt;User&gt; user = new SoftReference&lt;User&gt;(new User());</code></li>\n<li>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。<ol>\n<li>如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</li>\n<li>如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</li>\n</ol>\n</li>\n</ul>\n<p>弱引用: 将对象用<code>WeakReference</code>软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用</p>\n<ul>\n<li><code>public static WeakReference&lt;User&gt; user = new WeakReference&lt;User&gt;(new User());</code></li>\n</ul>\n<p>虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p>\n<h4 id=\"finalize-方法最终判定对象是否存活\"><a href=\"#finalize-方法最终判定对象是否存活\" class=\"headerlink\" title=\"finalize()方法最终判定对象是否存活\"></a>finalize()方法最终判定对象是否存活</h4><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p>\n<p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong></p>\n<ol>\n<li><p>第一次标记并进行一次筛选。</p>\n<p>筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize方法，对象将直接被回收。</p>\n</li>\n<li><p>第二次标记</p>\n<p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。<br>注意：<strong>一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。</strong></p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OOMTest</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      List&lt;Object&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">         list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(i++, UUID.randomUUID().toString()));</span><br><span class=\"line\">         <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(j--, UUID.randomUUID().toString());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//User类需要重写finalize方法</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">    OOMTest.list.add(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;关闭资源，userid=&quot;</span> + id + <span class=\"string\">&quot;即将被回收&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>finalize()方法的运行代价高昂， 不确定性大， 无法保证各个对象的调用顺序， 如今已被官方明确声明为不推荐使用的语法</strong>。 有些资料描述它适合做“关闭外部资源”之类的清理性工作， 这完全是对finalize()方法用途的一种自我安慰。 finalize()能做的所有工作， 使用try-finally或者其他方式都可以做得更好、更及时， 所以建议大家完全可以忘掉Java语言里面的这个方法。</p>\n</li>\n</ol>\n<h2 id=\"Full-GC-的回收目标-1\"><a href=\"#Full-GC-的回收目标-1\" class=\"headerlink\" title=\"Full GC 的回收目标\"></a>Full GC 的回收目标</h2><ol>\n<li><p>**新生代(Young Generation)**：</p>\n<ul>\n<li>包括Eden区和两个Survivor区</li>\n<li>文档中提到：”堆默认分为两个区域：新生代(默认占比1&#x2F;3)…老年代(默认占比2&#x2F;3)”</li>\n</ul>\n</li>\n<li><p>**老年代(Old Generation)**：</p>\n<ul>\n<li>存放长期存活的对象</li>\n<li>文档说明：”长期存活的对象将进入老年代”</li>\n</ul>\n</li>\n<li><p>**元空间(Metaspace)**：</p>\n<ul>\n<li>替代永久代(PermGen)的内存区域</li>\n<li>文档明确指出：”当元空间使用量达到MaxMetaspaceSize阈值时，会触发Full GC进行垃圾回收”</li>\n</ul>\n</li>\n<li><p><strong>方法区</strong>：</p>\n<ul>\n<li>存储类信息、常量、静态变量等</li>\n<li>文档中提到方法区回收无用类的条件</li>\n</ul>\n</li>\n<li><p><strong>其他系统区域</strong>：</p>\n<ul>\n<li>包括JVM内部数据结构</li>\n<li>系统类加载器加载的类对象等</li>\n</ul>\n</li>\n</ol>\n<p>Full GC是全局性垃圾回收，会扫描JVM管理的所有内存区域，而Minor GC只处理新生代区域。</p>\n<h2 id=\"Full-GC的触发条件-1\"><a href=\"#Full-GC的触发条件-1\" class=\"headerlink\" title=\"Full GC的触发条件\"></a>Full GC的触发条件</h2><ol>\n<li><p><strong>老年代空间不足</strong>：当老年代空间不足以存放从年轻代晋升的对象时，会触发Full GC。</p>\n</li>\n<li><p><strong>永久代&#x2F;元空间不足</strong>（取决于JVM版本）：</p>\n<ul>\n<li>Java 8之前：永久代(PermGen)空间不足</li>\n<li>Java 8及之后：元空间(Metaspace)空间不足</li>\n</ul>\n</li>\n<li><p><strong>System.gc()调用</strong>：当代码中显式调用System.gc()时，可能会触发Full GC（取决于JVM参数-XX:+DisableExplicitGC的设置）。</p>\n</li>\n<li><p><strong>CMS GC失败</strong>：在使用CMS收集器时，如果并发模式失败（Concurrent Mode Failure），会触发Full GC。</p>\n</li>\n<li><p><strong>晋升失败</strong>：当年轻代对象需要晋升到老年代，但老年代没有足够空间时。</p>\n</li>\n<li><p><strong>分配担保失败</strong>：在Minor GC之前，如果老年代最大可用连续空间小于历次晋升到老年代对象的平均大小，会触发Full GC。</p>\n</li>\n<li><p><strong>堆内存分配失败</strong>：当JVM无法为新对象分配内存时。</p>\n</li>\n<li><p><strong>手动触发</strong>：通过JVM工具（如jcmd、jconsole）手动触发Full GC。</p>\n</li>\n</ol>\n<h2 id=\"如何判断一个类是无用的类\"><a href=\"#如何判断一个类是无用的类\" class=\"headerlink\" title=\"如何判断一个类是无用的类\"></a>如何判断一个类是无用的类</h2><p>当元空间使用量达到MaxMetaspaceSize阈值时，会触发Full GC进行垃圾回收。方法区主要回收的是无用的类，需满足下面的条件：</p>\n<ul>\n<li><p>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p>\n</li>\n<li><p>加载该类的 <code>ClassLoader</code> 已经被回收。</p>\n</li>\n<li><p>该类对应的<code> java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</li>\n</ul>\n","feature":true,"text":"核心点堆内存分配比 老年代:新生代 2:1 新生代 Eden区:Survivor0区:Survivor1区 占比 8:1:1 分配策略 对象在分配时使用CAS算...","permalink":"/post/Java-高级-Day-3-GC垃圾回收","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E7%82%B9\"><span class=\"toc-text\">核心点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%AF%94\"><span class=\"toc-text\">堆内存分配比</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">分配策略</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">垃圾回收机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Minor-GC\"><span class=\"toc-text\">Minor GC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Full-GC\"><span class=\"toc-text\">Full GC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Full-GC-%E7%9A%84%E5%9B%9E%E6%94%B6%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">Full GC 的回收目标</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Full-GC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">Full GC的触发条件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GC-Roots\"><span class=\"toc-text\">GC Roots</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1\"><span class=\"toc-text\">如何判断对象是否死亡</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#finalize-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">finalize() 不推荐使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">常见引用类型</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">详细解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">堆内存布局</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-1\"><span class=\"toc-text\">垃圾回收机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-1\"><span class=\"toc-text\">分配策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1-1\"><span class=\"toc-text\">如何判断对象是否死亡</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95\"><span class=\"toc-text\">引用计数法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95-%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">可达性分析算法(默认使用)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GC-Roots-1\"><span class=\"toc-text\">GC Roots</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1\"><span class=\"toc-text\">常见引用类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#finalize-%E6%96%B9%E6%B3%95%E6%9C%80%E7%BB%88%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB\"><span class=\"toc-text\">finalize()方法最终判定对象是否存活</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Full-GC-%E7%9A%84%E5%9B%9E%E6%94%B6%E7%9B%AE%E6%A0%87-1\"><span class=\"toc-text\">Full GC 的回收目标</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Full-GC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6-1\"><span class=\"toc-text\">Full GC的触发条件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">如何判断一个类是无用的类</span></a></li></ol></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java-高级-Day-4-GC垃圾收集算法","uid":"55e262e45820c6fc0e5602715c3359d4","slug":"Java-高级-Day-4-GC垃圾收集算法","date":"2025-04-24T05:26:47.000Z","updated":"2025-04-30T08:11:18.858Z","comments":true,"path":"api/articles/Java-高级-Day-4-GC垃圾收集算法.json","keywords":null,"cover":[],"text":"核心点分代收集理论 新升代：复制算法，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法 老年代：“标记-清除”或“标记-整理”算法，对象存活几率是比...","permalink":"/post/Java-高级-Day-4-GC垃圾收集算法","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Java-高级-Day-2-JVM 内存分配","uid":"8f3910e39f3a3511dc34dd9ac8d25e0b","slug":"Java-高级-Day-2-JVM内存分配","date":"2025-04-23T03:13:38.000Z","updated":"2025-04-30T08:11:18.854Z","comments":true,"path":"api/articles/Java-高级-Day-2-JVM内存分配.json","keywords":null,"cover":[],"text":"核心点图示：颜色相同的都为一个类型 线程 程序计数器：记录当前线程正在执行的字节码指令的地址，是每个线程私有的，它的大小是4 个字节，固定的，不会随着操作系统的...","permalink":"/post/Java-高级-Day-2-JVM内存分配","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}