{"title":"Java-基于Redis的高性能任务队列设计与实现","uid":"6456b03f672a87198a79af9e60f25dff","slug":"Java-基于Redis的高性能任务队列设计与实现","date":"2025-04-29T09:19:39.000Z","updated":"2025-04-30T08:11:18.852Z","comments":true,"path":"api/articles/Java-基于Redis的高性能任务队列设计与实现.json","keywords":null,"cover":null,"content":"<p>我们早期2.0系统交卷是同步提交，交一笔写一笔，还要做各种逻辑处理，通知其他服务修改活动状态，在班级考试里还能用，只是慢，qps不超50, 后来需要支持年级考试，压测必挂。让我负责重构升级：首先想上mq，隔壁组在用rabbitmq，发现有丢数据的情况，但这个需求比较急，等不到它们解决完，所以我尝试自己建一个任务队列来实现。简单数据提交轻松上 <code>1000+/s</code>, 处理速度看实际业务复杂度，<code>300+/s</code> 交卷无问题。</p>\n<h2 id=\"首先定义核心要解决的问题\"><a href=\"#首先定义核心要解决的问题\" class=\"headerlink\" title=\"首先定义核心要解决的问题\"></a>首先定义核心要解决的问题</h2><ol>\n<li>保证高并发，部分业务场景如期末考试，校级联考，会瞬间有大量提交。</li>\n<li>必须保证让用户感知到提交成功或失败，提交成功的数据不能丢失。</li>\n<li>数据必须批量提交，否则<code>mysql</code>写入qps上不去。</li>\n<li>数据处理速度要快，不能让用户等太久。</li>\n</ol>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>经过三天调研和demo验证，最终数据入库使用请求合并将数据批量入库，数据处理使用 <code>Redis</code>的<code>List</code>做了一个任务处理队列，可实现多节点生产(瓶颈在Mysql写入，真要多节点还是上mq吧)和多节点消费。</p>\n<h3 id=\"请求合并处理器\"><a href=\"#请求合并处理器\" class=\"headerlink\" title=\"请求合并处理器\"></a>请求合并处理器</h3><ol>\n<li>包含一个无界的静态属性 <code>LinkedBlockingQueue&lt;SubmitTaskRequestBO&gt; requestQueue = new LinkedBlockingQueue&lt;&gt;();</code> 用来存储待提交的任务数据。</li>\n<li>使用 <code>ApplicationRunne扩展点</code> ，在服务启动时创建一个线程，使用自旋的方式读取 <code>requestQueue </code>, 默认阻塞。</li>\n<li>当请求线程提交数据时，将数据根据任务Type通过简单工厂封装成对应的待提交任务对象 <code>taskItem</code>，每个待提交任务对象中都封装了一个 <code>CompletableFuture&lt;TaskRequestDataBO&gt; future = new CompletableFuture&lt;&gt;();</code> 属性，将 <code>taskItem</code> 提交到 <code>requestQueue </code> 队列后，执行 <code>future.get() </code> 阻塞提交线程。</li>\n<li>当有数据提交至<code>requestQueue </code>队列中，之前的阻塞被释放，可以开始处理数据了。<ol>\n<li>当<code>requestQueue </code>队列中数据大于等于我们的要求的批量处理数据量时，直接提交。</li>\n<li>当<code>requestQueue </code>队列中数据少于我们的要求的批量处理数据量时，等待指定时间再进行检测，当超过最大等待时间直接提交。</li>\n</ol>\n</li>\n<li>数据提交：<ol>\n<li>将数据批量提交到DB，并完成任务对象的 <code>CompletableFuture</code>, 此时请求线程被释放。</li>\n<li>将数据批量提交到 <code>Redis任务队列中</code>，<code>redis</code> 挂了也不影响数据持久化。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"基于Redis的List的任务队列\"><a href=\"#基于Redis的List的任务队列\" class=\"headerlink\" title=\"基于Redis的List的任务队列\"></a>基于Redis的List的任务队列</h3><p>依靠Redis List的 <code>leftPushAll(左进)</code>  <code>rightPop(右出)</code> api 实现先进先出队列，并且依靠Redis的单线程模型，我们获取List 数据操作都是原子性的，不会出现重复数据，且可以多端无锁消费。</p>\n<h4 id=\"AbstractJedisListQueue-队列封装抽象\"><a href=\"#AbstractJedisListQueue-队列封装抽象\" class=\"headerlink\" title=\"AbstractJedisListQueue 队列封装抽象\"></a><code>AbstractJedisListQueue</code> 队列封装抽象</h4><p>通过 <code>Jedis</code> 封装 pull 和 push，实现 <code>leftPushAll(左进)</code>  <code>rightPop(右出)</code> ，通过自定义命名空间来区分不同的队列。</p>\n<p>特性：</p>\n<ul>\n<li><code>push(List&lt;T&gt; list)</code>：直接调用 <code>jedis.lpush(collectKey, collect.toArray(new String[collect.size()]));</code> api</li>\n<li><code>poll(int size)</code>:  注意它无数据时是阻塞的。<ol>\n<li>支持全速模式和非全速模式 <code>fullSpeedMode</code>, 默认 <code>fullSpeedMode</code> 为 <code>false</code>; 它是<code>AbstractJedisListQueue</code> 的成员属性。<ul>\n<li>它是因为 <code>jedis.brpop(collectKey, x, TimeUnit.MINUTES)</code> api 阻塞时间过长会导致睡死过去才添加的特性。</li>\n<li>当 <code>fullSpeedMode</code> 为true时标识任务队列中存在数据，此时<code>poll(int size)</code>api将不会有任何阻塞</li>\n</ul>\n</li>\n<li>检测是否存在任务数据<ol>\n<li><code>fullSpeedMode</code> 为false时使用阻塞api <code>jedis.brpop(collectKey, 1, TimeUnit.MINUTES)</code> 获取数据。</li>\n<li><code>fullSpeedMode</code> 为true时使用非阻塞api <code>jedis.rpop(collectKey)</code> 检测是否存在数据。</li>\n</ol>\n</li>\n<li>检测结果<ol>\n<li>有数据时，将 <code>fullSpeedMode</code> 设置为true，根据size调用非阻塞api <code>jedis.rpop(collectKey)</code> </li>\n<li>当没有数据时<ul>\n<li>记录没有值的次数 <code>reEmptyPullCount</code>，当 <code>reEmptyPullCount</code> 大于60次，将 <code>fullSpeedMode</code> 设置为 <code>false</code></li>\n<li>等待1s后返回 null。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<p>实现类：</p>\n<ul>\n<li><code>PreprocessTaskDataQueue</code> ：任务处理队列</li>\n<li><code>ErrorTaskDataQueue</code>：失败任务队列</li>\n</ul>\n<h4 id=\"TaskDataMaintenanceProcessor-任务数据维护器\"><a href=\"#TaskDataMaintenanceProcessor-任务数据维护器\" class=\"headerlink\" title=\"TaskDataMaintenanceProcessor 任务数据维护器\"></a><code>TaskDataMaintenanceProcessor</code> 任务数据维护器</h4><p>它的主要作用是服务重启后，默认从DB将任务数据加载到 <code>Redis</code> 队列中，并为所有节点提供任务数据，将执行失败且未超过重试次数的任务重新加入到执行队列中。其他处理节点通过该处理器获取任务数据，该处理器只有主节点会执行。</p>\n<p>执行过程为使用 <code>ApplicationRunner</code> 扩展点：</p>\n<ol>\n<li>初始化任务处理队列： <code>PreprocessTaskDataQueue</code> + 失败任务队列：<code>ErrorTaskDataQueue</code></li>\n<li>将DB中未处理的任务数据加载到 <code>PreprocessTaskDataQueue</code> 队列中.</li>\n<li>开启一个线程自旋开始处理失败任务数据，每次等待30s再将失败任务返回队列，防止是由于部分服务重启导致的暂时性失败。</li>\n</ol>\n<h3 id=\"TaskHandler-任务处理器\"><a href=\"#TaskHandler-任务处理器\" class=\"headerlink\" title=\"TaskHandler 任务处理器\"></a><code>TaskHandler</code> 任务处理器</h3><p>真正执行任务处理的实际逻辑。</p>\n<h4 id=\"ExecutionTask-实现-Callable-的任务执行器\"><a href=\"#ExecutionTask-实现-Callable-的任务执行器\" class=\"headerlink\" title=\"ExecutionTask 实现 Callable 的任务执行器\"></a><code>ExecutionTask</code> 实现 <code>Callable</code> 的任务执行器</h4><p>在线程池中代理执行 <code>TaskHandler</code> ，封装任务数据和<code>TaskHandler</code> ，并执行<code>TaskHandler</code> ，对 <code>TaskHandler</code> 执行状态的封装处理。</p>\n<h4 id=\"TaskDataProcessorRunner-任务数据处理器\"><a href=\"#TaskDataProcessorRunner-任务数据处理器\" class=\"headerlink\" title=\"TaskDataProcessorRunner 任务数据处理器\"></a><code>TaskDataProcessorRunner</code> 任务数据处理器</h4><p>它主要作用是处理 <code>PreprocessTaskDataQueue</code> 中的任务数据，通过<code>taskTyp</code>使用简单工厂获取并执行对应的 <code>TaskHandler</code>，封装成并将执行失败的任务加到 <code>ErrorTaskDataQueue</code> 队列中。</p>\n<p>执行过程为使用 <code>ApplicationRunner</code> 扩展点，开启一个线程自旋：</p>\n<ol>\n<li><code>taskDataMaintenanceProcessor.poll(size)</code>  获取数据, 主节点直接内部调用，跨节点 <code>sdk rpc</code>;</li>\n<li>遍历任务数据<ol>\n<li>并根据任务类型获取对应执行的线程池</li>\n<li>根据线程池获取对应的任务集合，<code>taskList</code></li>\n<li>通过任务数据，使用简单工厂构建 <code>ExecutionTask</code>，并提交到线程池中。</li>\n<li>将提交结果添加到<code>taskList</code>。</li>\n</ol>\n</li>\n<li>提交完毕开始遍历所有线程池及其对应他taskList，获取执行结果<ol>\n<li>将失败且未达到重试次数的数据放到<code>ErrorTaskDataQueue</code> (<code>TaskDataMaintenanceProcessor</code> 会自动将他放回到队列中)。</li>\n</ol>\n</li>\n</ol>\n<p>该框架最终扩展为小型的任务队列框架，在不需要使用mq的业务如批量离线试卷的导出与导入、批量Word的生成、PDF导出等场景平稳落地使用至今。</p>\n","feature":true,"text":"我们早期2.0系统交卷是同步提交，交一笔写一笔，还要做各种逻辑处理，通知其他服务修改活动状态，在班级考试里还能用，只是慢，qps不超50, 后来需要支持年级考试...","permalink":"/post/Java-基于Redis的高性能任务队列设计与实现","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"},{"name":"请求合并","slug":"请求合并","count":1,"path":"api/tags/请求合并.json"},{"name":"Redis阻塞队列","slug":"Redis阻塞队列","count":1,"path":"api/tags/Redis阻塞队列.json"},{"name":"任务队列","slug":"任务队列","count":1,"path":"api/tags/任务队列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A6%96%E5%85%88%E5%AE%9A%E4%B9%89%E6%A0%B8%E5%BF%83%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">首先定义核心要解决的问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">请求合并处理器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84List%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97\"><span class=\"toc-text\">基于Redis的List的任务队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#AbstractJedisListQueue-%E9%98%9F%E5%88%97%E5%B0%81%E8%A3%85%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">AbstractJedisListQueue 队列封装抽象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TaskDataMaintenanceProcessor-%E4%BB%BB%E5%8A%A1%E6%95%B0%E6%8D%AE%E7%BB%B4%E6%8A%A4%E5%99%A8\"><span class=\"toc-text\">TaskDataMaintenanceProcessor 任务数据维护器</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TaskHandler-%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">TaskHandler 任务处理器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ExecutionTask-%E5%AE%9E%E7%8E%B0-Callable-%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%99%A8\"><span class=\"toc-text\">ExecutionTask 实现 Callable 的任务执行器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TaskDataProcessorRunner-%E4%BB%BB%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">TaskDataProcessorRunner 任务数据处理器</span></a></li></ol></li></ol></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Js-Web转PDf框架的设计与实现","uid":"16e3b72ab86bdd03c61cdf559c2dc7de","slug":"Js-Web转PDf框架的设计与实现","date":"2025-04-29T09:38:40.000Z","updated":"2025-04-30T08:11:18.860Z","comments":true,"path":"api/articles/Js-Web转PDf框架的设计与实现.json","keywords":null,"cover":null,"text":" 设计开发了一个输出标准A3、A4等指定大小的PDF前端js框架，支持实时预览和字符级自适应分页，实时获取业务dom的精准坐标信息，所见即所得。后端使用Egg....","permalink":"/post/Js-Web转PDf框架的设计与实现","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Js，NodeJs,PDF,Js框架","slug":"Js，NodeJs-PDF-Js框架","count":1,"path":"api/tags/Js，NodeJs-PDF-Js框架.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java-高级-Day-5-JVM性能优化","uid":"74b4ce53d861aece862753ca4c35dd9e","slug":"Java-高级-Day-5-JVM性能优化","date":"2025-04-27T08:23:22.000Z","updated":"2025-04-30T08:11:18.860Z","comments":true,"path":"api/articles/Java-高级-Day-5-JVM性能优化.json","keywords":null,"cover":[],"text":"核心点 所有优化都要根据实际服务的具体业务场景做优化配置，没有通用的配置。 GC 优化目标：降低 full gc 产生的 STW ,让短期存活的对象尽量都留在 ...","permalink":"/post/Java-高级-Day-5-JVM性能优化","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java-Day","slug":"Java-Day","count":5,"path":"api/tags/Java-Day.json"},{"name":"Java-高级-Day","slug":"Java-高级-Day","count":5,"path":"api/tags/Java-高级-Day.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}