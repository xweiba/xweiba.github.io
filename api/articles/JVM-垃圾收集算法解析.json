{"title":"JVM-垃圾收集算法解析","uid":"347757ce9e70573368e0803b807e225c","slug":"JVM-垃圾收集算法解析","date":"2022-12-30T02:27:17.000Z","updated":"2025-04-30T08:11:18.848Z","comments":true,"path":"api/articles/JVM-垃圾收集算法解析.json","keywords":null,"cover":[],"content":"<h1 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h1><img src=\"/post/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/95317.png\" class=\"\" title=\"https:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;public&#x2F;resource&#x2F;21b50d8595b245f7d7d01a6bbfefe6c4&#x2F;xmlnote&#x2F;07A156E7F69C45FC9DA4D96300C7EBDB&#x2F;95317\">\n\n<h2 id=\"分代收集理论\"><a href=\"#分代收集理论\" class=\"headerlink\" title=\"分代收集理论\"></a>分代收集理论</h2><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是通过对象存活周期的不同将内存分为几块。一般将JAVA堆分为新生代和老年代 ，这样我们就可以根据各个年代的特点选择合适的垃圾手机算法。</p>\n<p>比如在新生代，每次手机都会有99%的对象死去，所有我们可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存货几率是比较高的，而且没有额外的空间对它进行担保，所以我们必须选择<strong>标记-清除算法</strong>或者<strong>标记-整理算法</strong>进行垃圾收集。</p>\n<p>注意：<strong>标记-清除算法 或 标记-整理算法 会比 复制算法 慢10倍以上！</strong></p>\n<h2 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h2><p>为了解决效率问题，复制收集算法出现了。它会将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完毕后，就将还存活的对象复制到另一块中，然后再把使用的空间一次性清理掉。这样就是每次的内存回收都是堆内存区域的一般进行回收。</p>\n<img src=\"/post/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/95776.png\" class=\"\" title=\"img\">\n\n<h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><p>算法分为<strong>标记</strong>和<strong>清除</strong>阶段，一般分为两种模式：</p>\n<ol>\n<li><strong>标记所有存活的对象，统一回收所有未标记的对象（一般选择这种）。</strong></li>\n<li><strong>标记所有需要回收的对象，统一回收所有标记的对象。</strong></li>\n</ol>\n<p>它是最基础的收集算法，但会带来两个问题：</p>\n<ul>\n<li><strong>效率不高，可能出现需要标记的对象过多。</strong></li>\n<li><strong>空间问题，清理后出现大量的内存碎片。</strong></li>\n</ul>\n<img src=\"/post/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/94592.png\" class=\"\" title=\"img\">\n\n<h2 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h2><p>根据老年代的特点设计出的一种标记算法，<strong>标记过程与标记-清楚算法一样</strong>，但后续不是直接对可回收对象回收，而是<strong>让所有存活的对象向一端移动，然后直接清理掉端边界外的内存。</strong></p>\n<img src=\"/post/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/94590.png\" class=\"\" title=\"img\">\n\n<h1 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h1><p>各GC收集器应用范围及搭配使用图，颜色相同的表示推荐组合。</p>\n<img src=\"/post/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/95765.png\" class=\"\" title=\"img\">\n\n<p><strong>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器是就是内存回收的具体实现。</strong></p>\n<p>虽然我们对各个收集器进行比较，但并非为了选择出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加<strong>没有万能的垃圾收集器</strong>，我们能做的就是<strong>根据不同的场景选择合适的垃圾收集器</strong>。</p>\n<h2 id=\"Serial收集器（年轻代，串行）\"><a href=\"#Serial收集器（年轻代，串行）\" class=\"headerlink\" title=\"Serial收集器（年轻代，串行）\"></a>Serial收集器（年轻代，串行）</h2><p>开启方法：<code>-XX:+UseSerialGC -XX:+UseSerialOldGC</code></p>\n<p>Serial收集器是最基本、历史最悠久的垃圾收集器。<strong>它是一个单线程收集器，它的单线程不仅仅意味着使用一个线程进行垃圾回收，更重要的是他在进行垃圾回收时必须暂停其他所有的工作线程（Stop The World），直到它收集结束。</strong></p>\n<ul>\n<li><strong>新生代使用复制算法。</strong></li>\n<li><strong>老年代使用标记-整理算法。</strong></li>\n</ul>\n<img src=\"/post/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/95646.png\" class=\"\" title=\"img\">\n\n<p>优点：<strong>与其它手机的单线程相比它简单高效，因为它没有线程交互的开销，自然可以获得很高的垃圾收集效率。</strong></p>\n<h4 id=\"Serial-Old-收集器（老年代，串行）\"><a href=\"#Serial-Old-收集器（老年代，串行）\" class=\"headerlink\" title=\"Serial Old 收集器（老年代，串行）\"></a>Serial Old 收集器（老年代，串行）</h4><p>Serial Old是Serial的老年代版本，它主要有两大用途:</p>\n<ol>\n<li><strong>在JDK1.5及以前的版本中与Parallel Scavenge收集器搭配使用。</strong></li>\n<li><strong>作为CMS收集器的备选方案。</strong></li>\n</ol>\n<h2 id=\"Parallel-Scavenge（年轻代，并行，JDK8默认）\"><a href=\"#Parallel-Scavenge（年轻代，并行，JDK8默认）\" class=\"headerlink\" title=\"Parallel Scavenge（年轻代，并行，JDK8默认）\"></a>Parallel Scavenge（年轻代，并行，JDK8默认）</h2><p><strong>Parallel和ParallelOld是JDK8默认的垃圾收集器。</strong></p>\n<p>开启方法：<code>-XX:+UseParallelGC, -XX:+UseParallelOldGC</code></p>\n<p><strong>Parallel是Serial的多线程版本，除了使用多线程进行垃圾回收外，其余行为（控制参数、收集算法、回收策略）和Serial类似。</strong></p>\n<p><strong>默认的线程数和CPU核数相同，也可以用参数：<code>-XX:ParallelGCThreads=N</code>指定收集线程数，但一般不推荐修改。</strong></p>\n<p><strong>Parallel收集器关注的重点是吞吐量，高效的使用CPU，CMS等垃圾收集器关注点更多的是工作线程的停顿时间。</strong></p>\n","text":"垃圾收集算法 分代收集理论当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是通过对象存活周期的不同将内存分为几块。一般将JAVA堆分为新生代...","permalink":"/post/JVM-垃圾收集算法解析","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"GC","slug":"GC","count":1,"path":"api/categories/GC.json"}],"tags":[{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"},{"name":"GC","slug":"GC","count":1,"path":"api/tags/GC.json"},{"name":"CMS","slug":"CMS","count":1,"path":"api/tags/CMS.json"},{"name":"ParNew","slug":"ParNew","count":1,"path":"api/tags/ParNew.json"},{"name":"三色标记","slug":"三色标记","count":1,"path":"api/tags/三色标记.json"},{"name":"内存屏障","slug":"内存屏障","count":1,"path":"api/tags/内存屏障.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">垃圾收集算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">分代收集理论</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">复制算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">标记-清除算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">标记-整理算法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">垃圾收集器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Serial%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%B9%B4%E8%BD%BB%E4%BB%A3%EF%BC%8C%E4%B8%B2%E8%A1%8C%EF%BC%89\"><span class=\"toc-text\">Serial收集器（年轻代，串行）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%8C%E4%B8%B2%E8%A1%8C%EF%BC%89\"><span class=\"toc-text\">Serial Old 收集器（老年代，串行）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Parallel-Scavenge%EF%BC%88%E5%B9%B4%E8%BD%BB%E4%BB%A3%EF%BC%8C%E5%B9%B6%E8%A1%8C%EF%BC%8CJDK8%E9%BB%98%E8%AE%A4%EF%BC%89\"><span class=\"toc-text\">Parallel Scavenge（年轻代，并行，JDK8默认）</span></a></li></ol></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Mysql 8.0 开启外网访问","uid":"03b0b502502bb68757a4ab4dec18ea0c","slug":"Mysql8.0开启外网访问","date":"2023-01-01T02:27:17.000Z","updated":"2025-04-30T08:11:18.862Z","comments":true,"path":"api/articles/Mysql8.0开启外网访问.json","keywords":null,"cover":null,"text":"Mysql 8.0 开启外网访问配置修改1234# vim /etc/mysql/mysql.conf.d/mysqld.cnf# 注释掉这两行#bind-ad...","permalink":"/post/Mysql8.0开启外网访问","photos":[],"count_time":{"symbolsCount":507,"symbolsTime":"1 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":4,"path":"api/categories/Mysql.json"}],"tags":[{"name":"配置","slug":"配置","count":8,"path":"api/tags/配置.json"},{"name":"Mysql","slug":"Mysql","count":6,"path":"api/tags/Mysql.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JVM类加载机制","uid":"696f58cc973f75c60837976660da7ceb","slug":"JVM类加载机制","date":"2022-12-29T05:17:00.000Z","updated":"2025-04-30T08:11:18.849Z","comments":true,"path":"api/articles/JVM类加载机制.json","keywords":null,"cover":[],"text":"类加载全过程当我们使用Java命令启动一个类的main()方法时，首先需要通过类加载器将主类加载到JVM中。 1234567891011121314151617...","permalink":"/post/JVM类加载机制","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"JVM","slug":"JVM","count":1,"path":"api/categories/JVM.json"}],"tags":[{"name":"原理","slug":"原理","count":1,"path":"api/tags/原理.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}