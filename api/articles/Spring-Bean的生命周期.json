{"title":"Spring-Bean的生命周期","uid":"fce5245168646e1e5d9fe3befd2601df","slug":"Spring-Bean的生命周期","date":"2020-12-23T07:46:50.000Z","updated":"2025-04-30T08:11:18.863Z","comments":true,"path":"api/articles/Spring-Bean的生命周期.json","keywords":null,"cover":null,"content":"<h1 id=\"Spring-AnnotationApplicationContext-核心注入流程\"><a href=\"#Spring-AnnotationApplicationContext-核心注入流程\" class=\"headerlink\" title=\"Spring-AnnotationApplicationContext 核心注入流程\"></a>Spring-AnnotationApplicationContext 核心注入流程</h1><p>在构造方法执行完毕时, 容器就已经创建好了.</p>\n<h2 id=\"1-AnnotatedBeanDefinitionReader\"><a href=\"#1-AnnotatedBeanDefinitionReader\" class=\"headerlink\" title=\"1. AnnotatedBeanDefinitionReader\"></a>1. AnnotatedBeanDefinitionReader</h2><p><code>this.reader = new AnnotatedBeanDefinitionReader(this);</code> 时会注入一个 <code>ConfigurationClassPostProcessor</code></p>\n<p><code>ConfigurationClassPostProcessor</code> 实现了 <code>BeanDefinitionRegistrarPostProcessor</code> 接口, <code>BeanDefinitionRegistrarPostProcessor</code> 继承了 <code>BeanFactoryPostProcessor</code>.</p>\n<h2 id=\"2-ClassPathBeanDefinitionScanner\"><a href=\"#2-ClassPathBeanDefinitionScanner\" class=\"headerlink\" title=\"2. ClassPathBeanDefinitionScanner\"></a>2. ClassPathBeanDefinitionScanner</h2><p><code>this.scanner = new ClassPathBeanDefinitionScanner(this)</code> 时会在 <code>includeFilters</code> 中添加一个 <code>new AnnotationTypeFilter(Component.class)</code> 用来支持 <code>@Component</code> 注解.</p>\n<h2 id=\"3-register-componentClasses\"><a href=\"#3-register-componentClasses\" class=\"headerlink\" title=\"3. register(componentClasses);\"></a>3. register(componentClasses);</h2><p>将配置类注入到 <code>beanDefinitionMap</code> 中.</p>\n<h2 id=\"4-refresh\"><a href=\"#4-refresh\" class=\"headerlink\" title=\"4. refresh()\"></a>4. refresh()</h2><p>真正的处理流程</p>\n<h3 id=\"4-1\"><a href=\"#4-1\" class=\"headerlink\" title=\"4.1\"></a>4.1</h3><ol start=\"2\">\n<li>在BeanFactory初始化完毕后开始处理 BeanDefinitionRegistrarPostProcessor, 调用 ConfigurationClassPostProcessor 的 postProcessorBeanDefinitionRegister 接口, 解析 AppConfig.class 配置类, 并将其注入为 bean.<br> 2.1 通过 ConfigurationClassParser</li>\n</ol>\n<p>FactoryBean是一个包装了对象的Bean, 他会生成两个Beandefinition, 创建两个Bean, 一个是他本身A, 还有一个是他getObject()接口返回的对象B, 他与@Bean注解到方法上的的区别就是, 他在A对象创建Bean时, 不会调用Spring创建Bean生命周期的全部方法, 只会调用BeanPostProcessor的before方法, 因为要通过这个创建动态代理. A对象撞见Bean时会调用, B对象创建Bean时不会调用, 因为B对象是在A对象doCreateBean过程中创建的.</p>\n<p>@DependsOn 依赖指定bean的注解, 被注解的类在bean的创建过程中会先创建此注解标记的beanName</p>\n<ol>\n<li>new AnnotationApplicationContext(AppConfig.class)</li>\n<li>AnnotationApplicationContext 构造方法调用父类构造方法创建FactoryBen对象。</li>\n<li>初始化扫描器Scanner, 并配置一个includefilter过滤器,添加 @ComponentScan 注解.</li>\n<li>使用 Spring 的类的元信息解析器解析 AppConfig.class, 这个解析器是使用  AMS 字节码解析技术实现的, 因为 classloader 解析类时会把 class 加载到jvm中. 在接下来扫描包时不是每一个class都是bean的.</li>\n<li>开始扫描bean的流程, 前先通过excludeFilter判断 AppConfig 是不是在排除中, 是直接返回,</li>\n<li>不在排除中, 再判断是否在includefilterr中, 因为有默认的 @ComponentScan , 取其值. 通过元信息解析器的方法获取值下的所有class的元信息,如b.</li>\n<li>还是会通过filter过滤器过滤, 过滤成功后会判断是否有 @Candidate 条件判断注解, 有的话在通过条件判断是否成功. 且不为接口|不包含非静态子类|不包含@lookup注解方法的抽象类, 成功再往下解析.最后将class的包名xxx.xxx.xxService存入Beandefinition的beanClass(此阶段的beanName),扫描完成返回所有的Beandefinition集合Beandefinitions. 此时只设置了名字. </li>\n<li>遍历Beandefinition开始做真正的解析, 设置scope值, 生成baen的名字, 首先通过Component注解的值, 没有值的话通过类的短名生成(默认首字符小写. 注意如果类的前两个字符都是大写, 那么首字符不会小写, 而是直接用类名 如ABTest.class-&gt;ABTest, Abtest-&gt; abtest)</li>\n<li>给Beandefinition设置默认值,</li>\n<li>解析 @Lazy @primary @DependsOn @Role @Description</li>\n<li>检查Spring容器中是否已经存在该Beanname, 如果有相同的的名字, 且Beandefinition相同, Beandefinition对应的class也相同, 那么会抛异常, 如果Beandefinition不同, 但class相同会忽略, 这种情况只存在于该类被两个@ComponentScan注解扫描到了, 所以会忽略, 如果在同一个@ComponentScan中出现同名的会抛出异常. </li>\n<li>Spring容器中不存在创建一个BeandefinitionHolder对象, 添加到Beandefinitions中并注册到BeandefinitionMap中.</li>\n<li>初始化完毕后开始遍历Beandefinitions, 首先合并Beandefinition, 如果Bean A有parent属性, 找到parent的Beandefinition B, 将B克隆一份, 然后将b存在的属性复制给B. 返回合并后的RootBeandefinition. 如果没有parent, 将A克隆一份, 返回RootBeandefinition, 都会存入RootBeandefinition map中. 后面都是使用这个Map的RootBeandefinition.</li>\n<li>获取到RootBeandefinition后, 判断是否为非抽象的Beandefinition(注意不是class是否是抽象类, 而是Bean的属性是否设置为了抽象的,基本没用), 非懒加载且是单例的, 开始创建Bean.</li>\n<li>创建前判断是否为FactoryBean,不是的走getBean(beanname)方法创Bean. 里面会调用doCreateBan(),内部会添加到单例池中.</li>\n<li>如果是FactoryBean, 会先创建一个带 &amp;+beanName 的Bean, 也就是FactoryBean对应的Bean,注意他在单例池中的key没有&amp;前缀, 然后判断FactoryBean实例化对象是否是实现了SmartFactoryBean(它继承了FactoryBean), 且实现的isEagerInit()接口返回true, 那么此时会调用getBean(beanName)去创建FactoryBean的getObject()对象B的Bean, B不会存到单例池, 存放的是factoryBeanObjectCache缓存map中.</li>\n<li>所有的非懒加载单例bean都创建完毕后, 判断单例bean是否实现了 SmartInitialzingSingleton接口. 实现了就调用接口的afterSingletonsInstantiated()方法. 这是一个可扩展的点.</li>\n<li>getBean(beanName) 中, 如果传入的beanname前缀包含&amp;会先将所有&amp;去掉-&gt;newBeanname, 然后通过newBeanname去单例池中获取bean, </li>\n<li>能取到Bean, 判断beanname是否包含&amp;, 如果包含&amp;会判断取出的bean是否是factoryBean, 不是的话抛异常.是的话就直接返回.  如果传入的beanname不带&amp;, 那么取出factoryBean的bean后会判断是否是FactoryBean, 是的话返回它的getObject()对应的Bean.</li>\n<li>取不到就通过newBeanname创建Bean.</li>\n</ol>\n<h1 id=\"doGetBean\"><a href=\"#doGetBean\" class=\"headerlink\" title=\"doGetBean\"></a>doGetBean</h1><ol>\n<li>tranfromeBeanName(), 将传入的beanName进行转换, 带&amp;前缀的去掉前缀(FactoryBean), 别名的取出主id;</li>\n<li>getSingleton(beanName) 获取bean. &#x2F;&#x2F;因为绝大多数都是单例bean, 所以这里会直接去单例池去拿. 28法则 </li>\n<li>拿不到开始创建, </li>\n<li>检查是否有父BeanFactory, 且当前RootBeandefinitionMap中没有beanname对应的bean, 调用父BeanFactory的getBean方法去获取.</li>\n<li>没有的话从RootBeandefinitionMap中通过beanName获取合并后的Beandefinition A;</li>\n<li>检查A是不是Abstract的</li>\n<li>遍历A中的DependsOns, 检查依赖的Beanname B, 检查B中是又否又通过@DependsOn注解依赖了A, 是抛出异常(循环依赖). 不是存入dependentBeanMap, key为B, value为A的beanname. 然后通过B的beanName创建bean. 创建完毕继续往下走.</li>\n<li>判断A是单例还是多例的还是其他的作用域(Scope)如Session等, 如果是单例的, 通过 getSingleton(beanna, lamba表达式), 获取bean</li>\n<li>进入 getSingleon方法. 首先通过BeanName判断单例池中有没有,有直接返回, 没有把beanname加入到正在创建中的singletonsCurrentluInCretaion集合中. 然后执行lamba表达式. lambda表达式中调用createBean()创建出真正的对象, 放入单例池中.</li>\n<li>如果是多例的先调用beforPrototypeCreation(beanName), 再调用createBean, 最后调用afterPrototypeCreation(beanName)</li>\n<li>如果是其他作用域先去Scope的缓存中scopes中获取, 获取不到去创建Scope对应的bean.</li>\n</ol>\n<h1 id=\"createBean-beanName-beandefinition-argas\"><a href=\"#createBean-beanName-beandefinition-argas\" class=\"headerlink\" title=\"createBean(beanName, beandefinition, argas)\"></a>createBean(beanName, beandefinition, argas)</h1><ol>\n<li>将 beandefinition 赋值给中间变量mbdTouse, 通过 beandefinition 进行class加载-&gt;resolvedClass.  加载时beanName还是类名, 如果不设置BeanClassLoader的话(过context.getBeanFactory().setBeanClassLoader(xxx)来设置),会使用默认的ClassLoader. 默认的classLoader首先会获取当前线程的classLoader(在加载Spring容器前通过Thread.currentThread().setClassLoader(xxxx)来设置, 默认是空的, 支持tomcat打破双亲委派的类加载器场景), 如果没加载到再获取当前类的类加载器, 如果当前类被放到了jre&#x2F;lib中, 他会被bootstrapClassLoader加载, 也就是jvm加载, 在运行时是拿不到的. 还拿不到的话会调用ClassLoader.getSystemClassLoader()方法, 其实就是AppClassloader.获取到类加载器后, 再通过BeanName获取到bean的类名className. 如果设置了SpringEl表达式, 会先通过El表达式去获取Bean的class.没有的话就通过ClassLoader.loadClass(className)返回class对象resolvedClass了</li>\n<li>克隆一个BeanDefinition, 并将class对象设置进去. mbdTouse &#x3D; new RootBeandefinition(beandefinition); mbdTouse.setBeanClass(resolvedClass)</li>\n<li>调用实例化前resolveBeforeInstantiation(beanName, mbdTouse)接口 InstantiationAwarBeanPosetProcessor, 会判断是否为合成Bean, 合成Bean该接口不执行., 和BeanPostProcessor接口不同, BeanPostProcessor时对象已经创建了, InstantiationAwarBeanPosetProcessor是对象创建之前. 它的接口签名是public Object Instantiation(class,beanName), 而BeanPostProcessor是public Object initialization(object, beanName), InstantiationAwarBeanPosetProcessor可以自定义对象的实例化.如果你实现了多个InstantiationAwarBeanPosetProcessor接口, 并且内部都是针对同一个bean的,那么只要有一个InstantiationAwarBeanPosetProcessor的postProcessorBeforeInstantiation(class, beanName) 返回了对象, 其他的都不会调用了. 因为这个接口就是用来自定义对象的. 注意这个接口可以返回任意对象. </li>\n<li>如果InstantiationAwarBeanPosetProcessor接口返回了对象, 他会调用一次bean &#x3D; applyBeanPostProcessorsAfterInitialization(bean, beanName); 对象实例化后的接口. BeanPostProcessor.postProcessAfterInitialization(result, beanName); 因为它要对对象做AOP. 没有创建对象执行doCreateBean(beanName, mbdToUse, args)</li>\n</ol>\n<h1 id=\"doCreateBean-beanName-mbdToUse-args\"><a href=\"#doCreateBean-beanName-mbdToUse-args\" class=\"headerlink\" title=\"doCreateBean(beanName, mbdToUse, args)\"></a>doCreateBean(beanName, mbdToUse, args)</h1><ol>\n<li>首先通过beanName在factoryBeanInstanceCache中获取instanceWrapper,(有可能在本Bean创建之前，就有其他Bean把当前Bean给创建出来了（比如依赖注入过程中）), 没有的话调用 createBeanInstance(beanName, mbd, args)创建 instanceWrapper;</li>\n<li>createBeanInstance(beanName, mbd, args) 中先判断有没有加载class, 没有的话先加载.</li>\n<li>通过 getInstanceSupplier 实例化  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BeanDefinition中添加了Supplier，则调用Supplier来得到对象</span></span><br><span class=\"line\">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (instanceSupplier != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>没有的话通过 @Bean 方式创建 instanceWrapper</li>\n<li>还没有的话开始通过构造方法创建 instanceWrapper.</li>\n<li>首先判断 args 参数是否为空, 且mbd中已经找过构造方法了, 是的话如果mbd.constructorArgumentsResolved为true, 通过有参构造方法autowireConstructor(beanName, mbd, null, null);(方法内会拿到缓存好的构造方法的入参)创建instanceWrapper, 没有的话通过无参构造instantiateBean(beanName, mbd);创建.</li>\n<li>没有找过构造方法的话下面开始通过推断构造来创建 instanceWrapper</li>\n<li>首先通过 SmartInstantiationAwareBeanPostProcessor 扩展点找构造方法, 可以利用SmartInstantiationAwareBeanPostProcessor来控制用beanClass中的哪些构造方法, 比如AutowiredAnnotationBeanPostProcessor会把加了@Autowired注解的构造方法找出来</li>\n<li>通过构造方法创建 instanceWrapper</li>\n<li>实例化之后会调用合并后的扩展点 MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);方法. 这个里面可以通过 mdb.setInitMethed(“方法名”) 设置初始化方法. 通过mdb.getPropertyValues().add(“orderService”, new orderService()), 对属性赋值.</li>\n<li>处理循环依赖</li>\n<li>调用InstantiationAwarBeanPosetProcessor的postProcessorAfterInstrantiation(instanceWrapper.instance, beanName) 实例化后方法. 注意这里传入的obj是没有被代理的对象.此时属性还是没有注入值的.</li>\n<li>开始属性注入, 首先会执行Spring自带的依赖注入, 就是如果你的@Bean(autowired&#x3D;Autowired.BY_NAME)写了autowired属性, 并设置了 Autowired.BY_NAME 或者 Autowired.BY_TYPE, 他会调用你Bean对象中的所有set方法, 通过set注入属性.注意没有属性他也会调用, ByType是通过方法入参类型调用的, ByName是通过setXXX的xxx方法注入的. 该方法可以使没有被@Component注解的类也有属性注入的能力, 因为 @Component 相对于是一个插件的能力, 如果在容器启动时不设置includeFilter @Component, 那么Spring就没有属性注入的能力了. 而且如果你使用xml方式启动容器, 且不开启注解配置, 那么没有 @Component 是不是都不能属性注入了? </li>\n<li>然后调用InstantiationAwarBeanPosetProcessor的的postProcessorProperties() 方法. Spring有一个AutowiredAnnotationBeanPostProcessor实现类完成了@Autowired 注解注入的能力. CommonAnnotationBeanPostProcessor实现类完成了 @Resource @WebServiceRef @EJB 注解注入的能力</li>\n<li>在AutowiredAnnotationBeanPostProcessor中, 如果你在前期扩展点通过BeanDefinition.getPropertyValues().add(“xxx”, new XXX())给xxx赋值, 那么@Autowired注解不会再对这个属性赋值.</li>\n<li>属性填充完毕后执行 initializeBean(beanName, exposedObject, mbd); 初始化真正的Bean</li>\n<li>调用invokeAwareMethods(String beanName, Object bean)方法, 里面会调用 ((BeanNameAware) bean).setBeanName(beanName); ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</li>\n<li>调用初始化前 wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); 执行所有的 BeanPostProcessors.postProcessBeforeInitialization(result, beanName);</li>\n<li>初始化前中有一个Spring默认的 CommonAnnotationBeanPostProcessor 实现类的构造方法中会设置setInitAnnotationType(PostConstruct.class),setDestroyAnnotationType(PreDestroy.class); 设置完成后, 在调用postProcessBeforeInitialization方法时就会处理@PostConstruct注解和@PreDestroy注解. 然后在他的父类InitDestroyAnnotationBeanPostProcessor的buildLifecycleMetadata的doWithLocalMethods中, 会找到所有的@PostConstruct注解的方法, 加入到initConstructMethod集合中, 注意这里是循环调用, 如果有父类, 会把父类的方法放到前面,先执行父类方法, 返回LifecycleMetadata, 并通过LifecycleMetadata.invokeDestroyMethods(bean, beanName);执行方法. </li>\n<li>初始化前还有一个实现类 ApplicationContextAwareProcessor, 如果bean是EnvironmentAware, EmbeddedValueResolverAware, ResourceLoaderAware, ApplicationEventPublisherAware, MessageSourceAware, ApplicationContextAware, ApplicationStartupAware其中某一个接口的实现类的, 那么就执行接口对应的方法.</li>\n<li>调用初始化 invokeInitMethods(beanName, wrappedBean, mbd);</li>\n<li>首先判断是否实现了 InitializingBean 接口, 实现了调用 ((InitializingBean) bean).afterPropertiesSet();</li>\n<li>接下来如果 BeanDefinition 中有mbd.getInitMethodName(); 且不是afterPropertiesSet方法, 执行InitMethodName对应的方法.</li>\n<li>继续执行初始化后方法 wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); 执行所有的BeanPostProcessor.postProcessAfterInitialization(result, beanName); </li>\n<li>初始化后的 BeanPostProcessor.postProcessAfterInitialization(result, beanName); 中会做AOP. 注意只有 @Configuration和添加@AspectJAutoProxyRegistrar且类上有@Aspect或类或方法上 有@Transactional 注解的才会被代理.</li>\n<li>并且AOP对应的bean也是通过 ImportBeanDefinitionRegistrar 注入的. </li>\n<li>initializeBean执行完毕后, 执行registerDisposableBeanIfNecessary(beanName, bean, mbd); 这是bean销毁相关的</li>\n</ol>\n<h1 id=\"Bean销毁\"><a href=\"#Bean销毁\" class=\"headerlink\" title=\"Bean销毁\"></a>Bean销毁</h1><p>实现DisposableBean或AutoCloseale接口或在方法上添加 @Perdestory 注解,在Bean销毁时调用. spring容器销毁的时候执行. 通过context.registerShutdownHook()注册关闭钩子也可以调用.</p>\n<p>registerDisposableBeanIfNecessary(beanName, bean, mbd); 中会记录Bean有没有实现DisposableBean或AutoCloseale接口, 然后判断 BeanDefinition 有没有指定销毁的方法, BeanDefinition.setDestoryMehodName(“xxx”),  如果你把setDestoryMehodName设置为”{inferred}”, 那么 Spring销毁时会调用类的 close方法, 如果没有继续调用shutdown方法.<br>如果前面都找不到会继续判断是否有实现了DestructionAwareBeanPostProcessor的Bean. 并执行它的requiresDestruction方法.判断是否需要执行销毁逻辑.<br>DestructionAwareBeanPostProcessor接口中有两个方法 boolean requiresDestruction(Object bean)设置bean是否需要被销毁, void postProcessBeforeDestruction(Object bean, String beanName) 执行具体的销毁逻辑.<br>InitDestroyAnnotationBeanPostProcessor是实现了DestructionAwareBeanPostProcessor的, 在初始化前时他将@PerDestory注解记录了, 在此时就会通过这个去判断是否有销毁的方法.</p>\n<p>如果有销毁方法, 且是单例bean通过beanName和(此时Bean是DisposableBean类型)Bean存入到disposableBeans map中. 原型bean因为Spring根本没有记录, 所以不会执行销毁方法</p>\n","text":"Spring-AnnotationApplicationContext 核心注入流程在构造方法执行完毕时, 容器就已经创建好了. 1. AnnotatedBea...","permalink":"/post/Spring-Bean的生命周期","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Spring","slug":"Spring","count":7,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"},{"name":"Bean","slug":"Bean","count":1,"path":"api/tags/Bean.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Spring-AnnotationApplicationContext-%E6%A0%B8%E5%BF%83%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Spring-AnnotationApplicationContext 核心注入流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-AnnotatedBeanDefinitionReader\"><span class=\"toc-text\">1. AnnotatedBeanDefinitionReader</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-ClassPathBeanDefinitionScanner\"><span class=\"toc-text\">2. ClassPathBeanDefinitionScanner</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-register-componentClasses\"><span class=\"toc-text\">3. register(componentClasses);</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-refresh\"><span class=\"toc-text\">4. refresh()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1\"><span class=\"toc-text\">4.1</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#doGetBean\"><span class=\"toc-text\">doGetBean</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#createBean-beanName-beandefinition-argas\"><span class=\"toc-text\">createBean(beanName, beandefinition, argas)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#doCreateBean-beanName-mbdToUse-args\"><span class=\"toc-text\">doCreateBean(beanName, mbdToUse, args)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Bean%E9%94%80%E6%AF%81\"><span class=\"toc-text\">Bean销毁</span></a></li></ol>","author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"CentOS 6.X yum 安装高版本 gcc","uid":"e221c7ea9d04dfff024e9e4e2166f289","slug":"CentOS 6.X yum 安装高版本 gcc","date":"2021-01-07T05:10:28.000Z","updated":"2025-04-30T08:11:18.832Z","comments":true,"path":"api/articles/CentOS 6.X yum 安装高版本 gcc.json","keywords":null,"cover":null,"text":" 为CentOS 6、7升级gcc至4.8、4.9、5.2、6.3、7.3等高版本 添加yum源安装GCC安装GCC 4.8 安装123wget http://...","permalink":"/post/CentOS 6.X yum 安装高版本 gcc","photos":[],"count_time":{"symbolsCount":986,"symbolsTime":"1 mins."},"categories":[{"name":"Linux","slug":"Linux","count":7,"path":"api/categories/Linux.json"}],"tags":[{"name":"GCC","slug":"GCC","count":2,"path":"api/tags/GCC.json"},{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"},{"name":"CentOs","slug":"CentOs","count":1,"path":"api/tags/CentOs.json"},{"name":"yum","slug":"yum","count":1,"path":"api/tags/yum.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"武汉公交实时查询接口","uid":"37b160dc5b6462bbe02a296b20c77e54","slug":"武汉公交实时查询接口","date":"2020-12-23T06:33:21.000Z","updated":"2025-04-30T08:11:18.902Z","comments":true,"path":"api/articles/武汉公交实时查询接口.json","keywords":null,"cover":null,"text":"该参数加密算法使用: https://www.jianshu.com/p/04eba47f7c07 参数加密so中的公钥和私钥: 123456789101112...","permalink":"/post/武汉公交实时查询接口","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"API","slug":"API","count":1,"path":"api/categories/API.json"}],"tags":[{"name":"武汉公交","slug":"武汉公交","count":1,"path":"api/tags/武汉公交.json"}],"author":{"name":"Weiba","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/24520686?v=4","link":"/","description":"啊 又忘了更新了！","socials":{"github":"https://github.com/xweiba","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}